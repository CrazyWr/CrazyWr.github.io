<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Node - 内存泄漏 | 面向信仰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node - 内存泄漏</h1><a id="logo" href="/.">面向信仰</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> HOME</i></a><a href="/archives/"><i class="fa fa-archive"> ARCHIVE</i></a><a href="/about/"><i class="fa fa-user"> ABOUT</i></a><a href="/book/"><i class="fa fa-book"> BOOK</i></a><a href="/wiki/"><i class="fa fa-list"> WIKI</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Node - 内存泄漏</h1><div class="post-meta">Apr 3, 2018<span> | </span><span class="category"><a href="/categories/node/">Node</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2,825</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>内存泄漏（Memory Leak）指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况</p>
<p>Node.js 使用 V8 作为 JavaScript 的执行引擎，所以讨论 Node.js 的 GC 情况就等于在讨论 V8 的 GC。在 V8 中一个对象的内存是否被释放，是看程序中是否还有地方持有改对象的引用。</p>
<p>在 V8 中，每次 GC 时，是根据 root 对象 (浏览器环境下的 window，Node.js 环境下的 global ) 依次梳理对象的引用，如果能从root的引用链到达访问，V8就会将其标记为可到达对象，反之为不可到达对象。被标记为不可到达对象（即无引用的对象）后就会被 V8 回收。(<a href="http://alinode.aliyun.com/blog/37" target="_blank" rel="external">http://alinode.aliyun.com/blog/37</a>)</p>
<h3 id="V8内存限制"><a href="#V8内存限制" class="headerlink" title="V8内存限制"></a>V8内存限制</h3><p>node基于V8构建，通过V8的方式进行分配跟管理js对象。V8对内存的使用有限制（老生代内存64位系统下约为1.4G，32位系统下约为0.7G，新生代内存64位系统下约为32MB，32系统下约为16MB）。在这样的限制下，将导致无法操作大内存对象。如果不小心触碰这个界限，就会造成进程退出。</p>
<p>原因： V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。</p>
<p>通过<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">node</span> <span class="title">--max-old-space-size</span>=xxx（单位MB）</div><div class="line"><span class="keyword">node</span> <span class="title">--max-new-space-size</span>=xxx（单位KB）</div></pre></td></tr></table></figure></p>
<p>设置新生代内存以及老生代内存来破解默认的内存限制。</p>
<h3 id="V8的堆构成"><a href="#V8的堆构成" class="headerlink" title="V8的堆构成"></a>V8的堆构成</h3><p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：</p>
<ul>
<li>新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁</li>
<li>老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li>
<li>老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针</li>
<li>大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象</li>
<li>代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li>
<li>Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</li>
</ul>
<h3 id="GC回收类型"><a href="#GC回收类型" class="headerlink" title="GC回收类型"></a>GC回收类型</h3><ul>
<li><p>增量式GC<br>表示垃圾回收器在扫描内存空间时是否收集（增加）垃圾并在扫描周期结束时清空垃圾。</p>
</li>
<li><p>非增量式GC<br>使用非增量式垃圾收集器时，一收集到垃圾即将其清空。</p>
</li>
</ul>
<p>垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。对象首先进入占用空间较少的新生代内存。大部分对象会很快失效，非增量GC直接回收这些少量内存。假如有些对象一段时间内不能被回收，则进去老生代内存区。这个区域则执行不频繁的增量GC，且耗时较长。</p>
<h3 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h3><h4 id="一、全局变量"><a href="#一、全局变量" class="headerlink" title="一、全局变量"></a>一、全局变量</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;</div><div class="line"><span class="comment">//未声明对象。</span></div><div class="line"></div><div class="line">global.b = <span class="number">11</span>;</div><div class="line"><span class="comment">//全局变量引用</span></div></pre></td></tr></table></figure>
<p>这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。</p>
<h4 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> bigData = <span class="keyword">new</span> Buffer(<span class="number">100</span>);</div><div class="line">  inner = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> bigData;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，从而导致内存泄漏（bigData 不会释放）。</p>
<p>需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的。</p>
<h4 id="三、事件监听"><a href="#三、事件监听" class="headerlink" title="三、事件监听"></a>三、事件监听</h4><p>Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除（removeListener），将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现，所以事件重复监听可能收到如下警告：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:2752</span>) Warning: Possible EventEmitter memory leak detected。<span class="number">11</span> haha listeners added。Use emitter。setMaxListeners() to increase limit</div></pre></td></tr></table></figure></p>
<p>例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。</p>
<p>原理上与前一个添加事件监听的时候忘了清除是一样的。在使用 Node.js 的 http 模块时，不通过 keepAlive 复用是没有问题的，复用了以后就会可能产生内存泄漏。所以，你需要了解添加事件监听的对象的生命周期，并注意自行移除。</p>
<p>关于这个问题的实例，可以看 Github 上的 issues（node Agent keepAlive 内存泄漏）(<a href="https://github.com/nodejs/node/issues/9268" target="_blank" rel="external">https://github.com/nodejs/node/issues/9268</a>)</p>
<h4 id="四、其他原因"><a href="#四、其他原因" class="headerlink" title="四、其他原因"></a>四、其他原因</h4><p>还有一些其他的情况可能会导致内存泄漏，比如缓存,队列消费不及时等。在使用缓存的时候，得清楚缓存的对象的多少，如果缓存对象非常多，得做限制最大缓存数量处理。还有就是非常占用CPU的代码也会导致内存泄漏，服务器在运行的时候，如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高。</p>
<h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p>文中的例子基本都可以很清楚的看出内存泄漏，但是在工作中，代码混合上业务以后就不一定能很清楚的看出内存泄漏了，还是得依靠工具来定位内存泄漏。另外下面是一些避免内存泄漏的方法。</p>
<ul>
<li><p>ESLint 检测代码检查非期望的全局变量。</p>
</li>
<li><p>使用闭包的时候，得知道闭包了什么对象，还有引用闭包的对象何时清除闭包。最好可以避免写出复杂的闭包，因为复杂的闭包引起的内存泄漏，如果没有打印内存快照的话，是很难看出来的。</p>
</li>
<li><p>绑定事件的时候，一定得在恰当的时候清除事件。在编写一个类的时候，推荐使用 init 函数对类的事件监听进行绑定和资源申请，然后 destroy 函数对事件和占用资源进行释放。</p>
</li>
</ul>
<h3 id="内存泄漏分析"><a href="#内存泄漏分析" class="headerlink" title="内存泄漏分析"></a>内存泄漏分析</h3><h4 id="查看V8内存使用情况-单位byte"><a href="#查看V8内存使用情况-单位byte" class="headerlink" title="查看V8内存使用情况(单位byte)"></a>查看V8内存使用情况(单位byte)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    <span class="selector-tag">process</span><span class="selector-class">.memoryUsage</span>();  </div><div class="line">    &#123;</div><div class="line">        <span class="attribute">ress</span>: <span class="number">47038464</span>,   </div><div class="line">        heapTotal: <span class="number">34264656</span>,   </div><div class="line">        heapUsed: <span class="number">2052866</span>   </div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="selector-tag">ress</span>：进程的常驻内存部分</div><div class="line"><span class="selector-tag">heapTotal</span>，<span class="selector-tag">heapUsed</span>：<span class="selector-tag">V8</span>堆内存信息</div></pre></td></tr></table></figure>
<h4 id="查看系统内存使用情况-单位byte"><a href="#查看系统内存使用情况-单位byte" class="headerlink" title="查看系统内存使用情况(单位byte)"></a>查看系统内存使用情况(单位byte)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">os</span><span class="selector-class">.totalmem</span>()</div><div class="line"><span class="selector-tag">os</span><span class="selector-class">.freemem</span>()</div><div class="line">返回系统总内存以及闲置内存</div></pre></td></tr></table></figure>
<h4 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">node</span> <span class="title">--trace_gc</span> -e <span class="string">"var a = []; for( var i = 0; i &lt; 1000000; i++ ) &#123; a.push(new Array(100)); &#125;"</span> &gt;&gt; gc.log  //输出垃圾回收日志</div><div class="line"></div><div class="line"><span class="keyword">node</span> <span class="title">--prof</span> </div><div class="line">//输出<span class="keyword">node</span><span class="title">执行时性能日志。 使用windows-tick</span>.processor查看。</div></pre></td></tr></table></figure>
<h4 id="分析监控工具"><a href="#分析监控工具" class="headerlink" title="分析监控工具"></a>分析监控工具</h4><ul>
<li>v8-profiler 对v8堆内存抓取快照和对cpu进行分析</li>
<li>node-heapdump 对v8堆内存抓取快照</li>
<li>node-mtrace 分析堆栈使用</li>
<li>node-memwatch 监听垃圾回收情况</li>
</ul>
<h5 id="node-memwatch"><a href="#node-memwatch" class="headerlink" title="node-memwatch"></a>node-memwatch</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">memwatch.on(<span class="string">'stats'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(info)</div><div class="line">&#125;)</div><div class="line">memwatch.on(<span class="string">'leak'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(info)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>stats事件:每次进行全堆垃圾回收时，将触发一次stats事件。这个事件将会传递内存统计信息。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"num_full_gc"</span>: <span class="number">17</span>, <span class="comment">//第几次全栈垃圾回收</span></div><div class="line">  <span class="string">"num_inc_gc"</span>: <span class="number">8</span>,   <span class="comment">//第几次增量垃圾回收</span></div><div class="line">  <span class="string">"heap_compactions"</span>: <span class="number">8</span>, <span class="comment">//第几次对老生代进行整理</span></div><div class="line">  <span class="string">"estimated_base"</span>: <span class="number">2592568</span>, <span class="comment">//预估基数</span></div><div class="line">  <span class="string">"current_base"</span>: <span class="number">2592568</span>,  <span class="comment">//当前基数</span></div><div class="line">  <span class="string">"min"</span>: <span class="number">2499912</span>, <span class="comment">//最小</span></div><div class="line">  <span class="string">"max"</span>: <span class="number">2592568</span>, <span class="comment">//最大 </span></div><div class="line">  <span class="string">"usage_trend"</span>: <span class="number">0</span> <span class="comment">//使用趋势</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">观察num_full_gc和num_inc_gc反映垃圾回收情况。</div></pre></td></tr></table></figure></p>
<p>leak事件：如果经过连续5次垃圾回收后，内存仍然没有被释放，意味着内存泄漏的发生。这个时候会触发一个leak事件。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  <span class="attribute">start</span>: Fri, <span class="number">29</span> Jun <span class="number">2012</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">13</span> GMT,</div><div class="line">  end: Fri, <span class="number">29</span> Jun <span class="number">2012</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">33</span> GMT,</div><div class="line">  growth: <span class="number">67984</span>,</div><div class="line">  reason: <span class="string">'heap growth over 5 consecutive GCs (20s) - 11.67 mb/hr'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Heap Diffing 堆内存比较 排查内存溢出代码。</p>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>下面，我们通过一个例子来演示如何排查定位内存泄漏：<br>首先我们创建一个导致内存泄漏的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</div><div class="line"><span class="keyword">var</span> heapdump = <span class="built_in">require</span>(<span class="string">'heapdump'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> leakobjs = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LeakClass</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'get /'</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</div><div class="line">      leakobjs.push(<span class="keyword">new</span> LeakClass());</div><div class="line">    &#125;</div><div class="line">    res.send(<span class="string">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  heapdump.writeSnapshot(<span class="string">'./'</span> + <span class="built_in">Date</span>.now() + <span class="string">'.heapsnapshot'</span>);</div><div class="line">&#125;, <span class="number">3000</span>);</div><div class="line"></div><div class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on port 3000'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里我们通过设置一个不断增加且不回被回收的数组，来模拟内存泄漏。</p>
<p>通过使用heap-dump模块来定时纪录内存快照，并通过chrome开发者工具profiles来导入快照，对比分析。</p>
<p>我们可以看到，在浏览器访问 localhost:3000, 并多次刷新后，快照的大小一直在增长，且即使不请求，也没有减小，说明已经发生了泄漏。 </p>
<p>接着我们通过过 chrome 开发者工具 profiles, 导入快照。通过设置 comparison，对比初始快照，发送请求，平稳，再发送请求这3个阶段的内存快照。可以发现右侧new中 LeakClass 一直增加。在delta中始终为正数，说明并没有被回收。</p>
<p>小结</p>
<p>针对内存泄漏可以采用植入 memwatch，或者定时上报 process.memoryUsage 内存使用率到 monitor，并设置告警阀值进行监控。<br>当发现内存泄漏问题时，若允许情况下，可以在本地运行 node-heapdump，使用定时生成内存快照。并把快照通过 chrome Profiles 分析泄漏原因。若无法本地调试，在测试服务器上使用 v8-profiler 输出内存快照比较分析json（需要代码侵入）。<br>需要考虑在什么情况下开启 memwatch/heapdump。考虑 heapdump 的频度以免耗尽了 CPU。 也可以考虑其他的方式来检测内存的增长，比如直接监控 process.memoryUsage()。<br>当心误判，短暂的内存使用峰值表现得很像是内存泄漏。如果你的app突然要占用大量的CPU和内存，处理时间可能会跨越数个垃圾回收周期，那样的话 memwatch 很有可能将之误判为内存泄漏。但是，这种情况下，一旦你的app使用完这些资源，内存消耗就会降回正常的水平。所以需要注意的是持续报告的内存泄漏，而可以忽略一两次突发的警报。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>BummingBoy</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/04/03/Node - 内存泄漏/">https://bummingboy.top/2018/04/03/Node - 内存泄漏/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>BummingBoy</li></ul></div><br><br><div class="tags"><a href="/tags/node/">Node</a><a href="/tags/内存/">内存</a></div><div class="post-nav"><a class="pre" href="/2018/04/03/Node - 内存管理/">Node - 内存管理</a><a class="next" href="/2018/01/05/JavaScript - commonjs vs ES6模块机制/">JavaScript - CommonJS vs ES6 import/export</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/chrome/">Chrome</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">JavaScript</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">Linux</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/centos-7/">Centos 7</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">Mac</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">Node</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">iOS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tech/">tech</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/sketch-缓存/" style="font-size: 15px;">sketch 缓存</a> <a href="/tags/centos7/" style="font-size: 15px;">Centos7</a> <a href="/tags/nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/shadowsocks/" style="font-size: 15px;">shadowsocks</a> <a href="/tags/centos-7/" style="font-size: 15px;">Centos 7</a> <a href="/tags/python3/" style="font-size: 15px;">Python3</a> <a href="/tags/nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/docker/" style="font-size: 15px;">Docker</a> <a href="/tags/private-registry/" style="font-size: 15px;">private registry</a> <a href="/tags/chrome/" style="font-size: 15px;">Chrome</a> <a href="/tags/http/" style="font-size: 15px;">HTTP</a> <a href="/tags/长连接/" style="font-size: 15px;">长连接</a> <a href="/tags/短连接/" style="font-size: 15px;">短连接</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/类型比较/" style="font-size: 15px;">类型比较</a> <a href="/tags/css/" style="font-size: 15px;">CSS</a> <a href="/tags/系统时间/" style="font-size: 15px;">系统时间</a> <a href="/tags/react/" style="font-size: 15px;">React</a> <a href="/tags/this/" style="font-size: 15px;">this</a> <a href="/tags/node/" style="font-size: 15px;">Node</a> <a href="/tags/浮点数/" style="font-size: 15px;">浮点数</a> <a href="/tags/mac/" style="font-size: 15px;">Mac</a> <a href="/tags/任何来源/" style="font-size: 15px;">任何来源</a> <a href="/tags/mongodb/" style="font-size: 15px;">MongoDB</a> <a href="/tags/tuxera/" style="font-size: 15px;">Tuxera</a> <a href="/tags/ntfs/" style="font-size: 15px;">NTFS</a> <a href="/tags/pm2/" style="font-size: 15px;">pm2</a> <a href="/tags/cluster/" style="font-size: 15px;">cluster</a> <a href="/tags/gitlab/" style="font-size: 15px;">Gitlab</a> <a href="/tags/firewall/" style="font-size: 15px;">firewall</a> <a href="/tags/ios/" style="font-size: 15px;">iOS</a> <a href="/tags/崩溃日志/" style="font-size: 15px;">崩溃日志</a> <a href="/tags/commonjs/" style="font-size: 15px;">CommonJS</a> <a href="/tags/es6/" style="font-size: 15px;">ES6</a> <a href="/tags/import-export/" style="font-size: 15px;">import/export</a> <a href="/tags/du/" style="font-size: 15px;">du</a> <a href="/tags/沙盒路径/" style="font-size: 15px;">沙盒路径</a> <a href="/tags/mysql/" style="font-size: 15px;">MySQL</a> <a href="/tags/layers-of-ios/" style="font-size: 15px;">Layers of iOS</a> <a href="/tags/cocoa-touch/" style="font-size: 15px;">Cocoa Touch</a> <a href="/tags/绘图/" style="font-size: 15px;">绘图</a> <a href="/tags/core-graphics-quartz-2d/" style="font-size: 15px;">Core Graphics/QuartZ 2D</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/私有仓库/" style="font-size: 15px;">私有仓库</a> <a href="/tags/if/" style="font-size: 15px;">if</a> <a href="/tags/yum/" style="font-size: 15px;">yum</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/regex/" style="font-size: 15px;">RegEx</a> <a href="/tags/定时器/" style="font-size: 15px;">定时器</a> <a href="/tags/原型链和继承/" style="font-size: 15px;">原型链和继承</a> <a href="/tags/数据类型/" style="font-size: 15px;">数据类型</a> <a href="/tags/隐式转换/" style="font-size: 15px;">隐式转换</a> <a href="/tags/状态码/" style="font-size: 15px;">状态码</a> <a href="/tags/各版本对比/" style="font-size: 15px;">各版本对比</a> <a href="/tags/event-loop/" style="font-size: 15px;">Event loop</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">面向信仰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/async_load_bg_image.js" async> </script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>