<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Node - Event loop | 面向信仰</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node - Event loop</h1><a id="logo" href="/.">面向信仰</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> HOME</i></a><a href="/archives/"><i class="fa fa-archive"> ARCHIVE</i></a><a href="/about/"><i class="fa fa-user"> ABOUT</i></a><a href="/book/"><i class="fa fa-book"> BOOK</i></a><a href="/wiki/"><i class="fa fa-list"> WIKI</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Node - Event loop</h1><div class="post-meta">Apr 7, 2018<span> | </span><span class="category"><a href="/categories/node/">Node</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2,118</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>Event Loop 允许Node.js执行非阻塞I/O操作, 尽管JavaScript是单线程的,只要有可能就将操作卸载到系统内核。<br>由于大多数现代内核是多线程的，所以它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会通知Node.js，以便可以将相应的回调(callbacks)添加到轮询队列(poll queue)中以最终执行。事件循环每次循环称为一次Tick 我们稍后将在本主题中进一步详细解释。</p>
<h3 id="Event-Loop的解释"><a href="#Event-Loop的解释" class="headerlink" title="Event Loop的解释"></a>Event Loop的解释</h3><p>英文原文：<br><em>When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the REPL, which is not covered in this document) which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.</em></p>
<p>当Node.js启动时会初始化event loop, 每一个event loop都会包含按如下顺序六个循环阶段</p>
<p>   ┌───────────────────────┐<br>┌─&gt;│        timers         │  (setTimeout(), setInterval())<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     I/O callbacks     │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     idle, prepare     │<br>│  └──────────┬────────────┘      ┌───────────────┐<br>│  ┌──────────┴────────────┐      │   incoming:   │<br>│  │         poll          │&lt;─────┤  connections, │<br>│  └──────────┬────────────┘      │   data, etc.  │<br>│  ┌──────────┴────────────┐      └───────────────┘<br>│  │        check          │  (setImmediate())<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>└──┤    close callbacks    │<br>   └───────────────────────┘</p>
<h3 id="阶段概览"><a href="#阶段概览" class="headerlink" title="阶段概览"></a>阶段概览</h3><ul>
<li>timers 阶段: 这个阶段执行setTimeout(callback) and setInterval(callback)预定的callback;</li>
<li>I/O callbacks 阶段: 执行除了close事件的callbacks、被timers(定时器，setTimeout、setInterval等)设定的callbacks、setImmediate()设定的callbacks之外的callbacks;</li>
<li>idle, prepare 阶段: 仅node内部使用;</li>
<li>poll 阶段: 获取新的I/O事件, 适当的条件下node将阻塞在这里;</li>
<li>check 阶段: 执行setImmediate() 设定的callbacks;</li>
<li>close callbacks 阶段: 比如socket.on(‘close’, callback)的callback会在这个阶段执行.</li>
</ul>
<p><em><strong>注意: </strong></em></p>
<ul>
<li>上面六个阶段都不包括 process.nextTick() </li>
</ul>
<p>每一个阶段都有一个装有callbacks的fifo queue(队列)，当event loop运行到一个指定阶段时，<br>node将执行该阶段的fifo queue(队列)，当队列callback执行完或者执行callbacks数量超过该阶段的上限时，<br>event loop会转入下一下阶段.</p>
<p>由于这些操作中的任何一个都可以调度更多操作，并且在轮询阶段中处理的新事件由内核排队，所以轮询事件可以在轮询事件被处理的同时排队。因此，长时间运行的回调可以使轮询阶段(poll)的运行时间远远超过计时器的阈值.有关更多详细信息，请参阅定时器和轮询部分。</p>
<p>在事件循环的每次运行之间，Node.js检查是否正在等待任何异步I/O或定时器，如果没有任何异步I/O或定时器，则清除关闭。</p>
<h3 id="各阶段详情"><a href="#各阶段详情" class="headerlink" title="各阶段详情"></a>各阶段详情</h3><h4 id="times"><a href="#times" class="headerlink" title="times"></a>times</h4><p>计时器指定阈值(threshold)，然后执行提供的回调(callback)，但是可能不是我们希望它执行的确切时间。也就是说定时器的时间是有误差的.<br>定时器回调会在指定的时间过后按照预定的时间运行; 但是，操作系统调度或其他回调的运行可能会延迟它们。 注意：从技术上讲，poll阶段控制何时执行定时器。</p>
<p>例子: 假设您计划在100 ms阈值后执行超时，然后异步开始读取需要95 ms的文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// Assume this takes 95ms to complete</span></div><div class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(delay + <span class="string">'ms have passed since I was scheduled'</span>);</div><div class="line">&#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></div><div class="line">someAsyncOperation(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">  <span class="comment">// do something that will take 10ms...</span></div><div class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</div><div class="line">    <span class="comment">// do nothing</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当事件循环进入轮询阶段时,它有一个空的队列(fs.readFile()还没有完成),所以它将等待剩余的毫秒数,直到达到最快的定时器的阈值.当它等待95ms传递时，fs.readFile（）完成读取文件，并且其需要10ms完成的回调被添加到轮询队列并被执行。 当回调完成时，队列中没有更多的回调，所以事件循环会看到最后一个定时器的阈值已经达到，然后回到定时器阶段执行定时器的回调。在这个例子中，你会看到被调度的定时器和它正在执行的回调之间的总延迟将是105ms。</p>
<h4 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h4><p>处理一些系统调用错误，比如网络 stream, pipe, tcp, udp通信的错误callback 例如，如果尝试连接时TCP套接字收到ECONNREFUSED，则某些*nix系统要等待报告错误。这将排队在I/O回调阶段执行。</p>
<h4 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle, prepare"></a>idle, prepare</h4><p>node 内部调用 忽略</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll阶段有两个主要功能： </p>
<ul>
<li>处理轮询队列(poll queue)中的事件(callback)</li>
<li>执行阈值已过的定时器timers的事件(callback)</li>
</ul>
<p>当事件循环进入poll阶段并且代码未设置计时器时，会发生以下两种情况之一：</p>
<ul>
<li>如果轮询队列(poll queue)不是空的，则事件循环将遍历队列并同步执行它们的回调队列，直到队列被清空或达到系统相关的硬限制。 </li>
<li>如果轮询队列(poll queue)为空，则会发生以下两件事情之一:<ul>
<li>如果脚本已由setImmediate（）调度，则事件循环将结束poll阶段并执行check阶段(check阶段的queue是 setImmediate设定的)</li>
<li>如果脚本没有被setImmediate（）调度，事件循环将等待callback被添加到队列，然后立即执行。</li>
</ul>
</li>
</ul>
<p>当事件循环进入poll阶段并且轮询队列(poll queue)为空, 事件循环将检查已达到时间阈值的定时器. 如果一个或多个定时器准备就绪, 则事件循环将回到timers阶段以执行这些定时器的回调(callbacks).</p>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>check阶段允许代码在poll queue空闲后立即执行回调。也就是setImmediate() 如果poll queue空闲并且代码中已经设置了setImmediate()，则事件循环直接进入到check阶段。 setImmediate（）实际上是一个特殊的定时器，它在事件循环的一个单独的阶段中运行。 它使用一个libuv API来调度poll阶段完成后执行的回调。 通常，随着代码的执行，事件循环将最终进入poll阶段，在那里它将等待传入连接，请求等。但是，如果使用setImmediate（）设置了回调并且poll queue空闲，将直接进入check阶段，而不是等待poll事件。</p>
<h3 id="setImmediate和setTimeout"><a href="#setImmediate和setTimeout" class="headerlink" title="setImmediate和setTimeout"></a>setImmediate和setTimeout</h3><p>setImmediate和setTimeout 是相似的，但取决于它们何时被调用，以不同的方式运行.</p>
<ul>
<li>setImmediate() 用于在当前的poll阶段完成后执行脚本.</li>
<li>setTimeout() 计划一个脚本，以ms为单位的最小阈值运行.</li>
</ul>
<p>setTimeout(fun(), 0) === setTimeout(fun(), 1)<br>另外, setTimeout(), HTML5中会有最低限制4ms, 这与浏览器有关, Node 中setTimeout通过libuv模块实现, 模块最终调用平台底层的高精度定时器, 并不会有这个限制. 详情(<a href="http://www.developerq.com/article/1488429596" target="_blank" rel="external">http://www.developerq.com/article/1488429596</a>)</p>
<p>以下例子的输出结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>)</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>结果:(忽略换行)<br>  理论上235401 / 235410<br>  实际由于1ms时间很短, 所以235401</p>
<p>分析:</p>
<p>  > setTimeout(func(), 0) === setTimeout(func(), 1), 并不会直接运行, 会将func()放入times queue;</p>
<p>  > setImmediate()是check阶段运行, 会将func()放入check queue;</p>
<p>  > new Promise() Promise创建就会直接执行, 所以会输出 <strong><em>2</em></strong>; 执行for循环, i === 9999时, resolve()返回一个新的Promise对象, 但是.then() 是异步执行的, 也就是会把下一个.then()放到当前的poll queue中, 等待当前poll阶段执行完, 然后输出<strong><em>3</em></strong> 和 <strong><em>5</em></strong>,  此时poll阶段执行完, 遍历poll queue输出<strong><em>4</em></strong></p>
<p>  > poll 阶段结束, 检查times阶段的定时器是否达到或超过设定的阈值, 如果超过设置的阈值, 则执行times callback 即输出 <strong><em>0</em></strong>, 然后进入check阶段 输出<strong><em>1</em></strong>; 01的输出顺序取决于执行第3步时的时间, 该时间 大于setTimuout()的阈值则先输出<strong><em>0</em></strong>, 否则先输出<strong><em>1</em></strong>; 尝试修改setTimeout(xx, 11), 则本机先输出<strong><em>1</em></strong>;</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>  从技术上来说，它并不是event loop的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前操作完成后处理，不管目前处于event loop的哪个阶段。</p>
<p>  看看我们最初给的示意图，process.nextTick()不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。</p>
<h4 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a>process.nextTick() vs setImmediate()</h4><ul>
<li>process.nextTick()立即在本阶段执行回调；</li>
<li>setImmediate()只能在 check 阶段执行回调。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>BummingBoy</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/04/07/Node - Event Loop/">https://bummingboy.top/2018/04/07/Node - Event Loop/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>BummingBoy</li></ul></div><br><br><div class="tags"><a href="/tags/node/">Node</a><a href="/tags/event-loop/">Event loop</a></div><div class="post-nav"><a class="pre" href="/2018/04/25/shell - 条件判断if中的-a到-z的意思/">shell - 条件判断 if 中 -a 到 -z 的意思</a><a class="next" href="/2018/04/04/Node - 异常捕获/">Node - 异常捕获</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/chrome/">Chrome</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">JavaScript</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">Linux</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/centos-7/">Centos 7</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">Mac</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">Node</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios/">iOS</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tech/">tech</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/sketch-缓存/" style="font-size: 15px;">sketch 缓存</a> <a href="/tags/centos7/" style="font-size: 15px;">Centos7</a> <a href="/tags/nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/linux/" style="font-size: 15px;">Linux</a> <a href="/tags/shadowsocks/" style="font-size: 15px;">shadowsocks</a> <a href="/tags/centos-7/" style="font-size: 15px;">Centos 7</a> <a href="/tags/python3/" style="font-size: 15px;">Python3</a> <a href="/tags/nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/docker/" style="font-size: 15px;">Docker</a> <a href="/tags/private-registry/" style="font-size: 15px;">private registry</a> <a href="/tags/chrome/" style="font-size: 15px;">Chrome</a> <a href="/tags/http/" style="font-size: 15px;">HTTP</a> <a href="/tags/长连接/" style="font-size: 15px;">长连接</a> <a href="/tags/短连接/" style="font-size: 15px;">短连接</a> <a href="/tags/javascript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/类型比较/" style="font-size: 15px;">类型比较</a> <a href="/tags/css/" style="font-size: 15px;">CSS</a> <a href="/tags/系统时间/" style="font-size: 15px;">系统时间</a> <a href="/tags/react/" style="font-size: 15px;">React</a> <a href="/tags/this/" style="font-size: 15px;">this</a> <a href="/tags/node/" style="font-size: 15px;">Node</a> <a href="/tags/浮点数/" style="font-size: 15px;">浮点数</a> <a href="/tags/mac/" style="font-size: 15px;">Mac</a> <a href="/tags/任何来源/" style="font-size: 15px;">任何来源</a> <a href="/tags/mongodb/" style="font-size: 15px;">MongoDB</a> <a href="/tags/tuxera/" style="font-size: 15px;">Tuxera</a> <a href="/tags/ntfs/" style="font-size: 15px;">NTFS</a> <a href="/tags/pm2/" style="font-size: 15px;">pm2</a> <a href="/tags/cluster/" style="font-size: 15px;">cluster</a> <a href="/tags/gitlab/" style="font-size: 15px;">Gitlab</a> <a href="/tags/firewall/" style="font-size: 15px;">firewall</a> <a href="/tags/ios/" style="font-size: 15px;">iOS</a> <a href="/tags/崩溃日志/" style="font-size: 15px;">崩溃日志</a> <a href="/tags/commonjs/" style="font-size: 15px;">CommonJS</a> <a href="/tags/es6/" style="font-size: 15px;">ES6</a> <a href="/tags/import-export/" style="font-size: 15px;">import/export</a> <a href="/tags/du/" style="font-size: 15px;">du</a> <a href="/tags/沙盒路径/" style="font-size: 15px;">沙盒路径</a> <a href="/tags/mysql/" style="font-size: 15px;">MySQL</a> <a href="/tags/layers-of-ios/" style="font-size: 15px;">Layers of iOS</a> <a href="/tags/cocoa-touch/" style="font-size: 15px;">Cocoa Touch</a> <a href="/tags/绘图/" style="font-size: 15px;">绘图</a> <a href="/tags/core-graphics-quartz-2d/" style="font-size: 15px;">Core Graphics/QuartZ 2D</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/私有仓库/" style="font-size: 15px;">私有仓库</a> <a href="/tags/if/" style="font-size: 15px;">if</a> <a href="/tags/yum/" style="font-size: 15px;">yum</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/regex/" style="font-size: 15px;">RegEx</a> <a href="/tags/定时器/" style="font-size: 15px;">定时器</a> <a href="/tags/原型链和继承/" style="font-size: 15px;">原型链和继承</a> <a href="/tags/数据类型/" style="font-size: 15px;">数据类型</a> <a href="/tags/隐式转换/" style="font-size: 15px;">隐式转换</a> <a href="/tags/状态码/" style="font-size: 15px;">状态码</a> <a href="/tags/各版本对比/" style="font-size: 15px;">各版本对比</a> <a href="/tags/event-loop/" style="font-size: 15px;">Event loop</a> <a href="/tags/内存/" style="font-size: 15px;">内存</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">面向信仰.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/async_load_bg_image.js" async> </script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>