<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>面向信仰</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bummingboy.top/"/>
  <updated>2018-07-03T12:02:34.483Z</updated>
  <id>https://bummingboy.top/</id>
  
  <author>
    <name>面向信仰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Network - HTTP 长连接 短连接</title>
    <link href="https://bummingboy.top/2018/05/11/HTTP%20-%20%E9%95%BF%E8%BF%9E%E6%8E%A5%20%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>https://bummingboy.top/2018/05/11/HTTP - 长连接 短连接/</id>
    <published>2018-05-11T08:33:12.972Z</published>
    <updated>2018-07-03T12:02:34.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HTTP协议与TCP-IP协议的关系"><a href="#1-HTTP协议与TCP-IP协议的关系" class="headerlink" title="1. HTTP协议与TCP/IP协议的关系"></a>1. HTTP协议与TCP/IP协议的关系</h3><p>　　<br>　　HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。<br><a id="more"></a></p><h3 id="2-如何理解HTTP协议是无状态的"><a href="#2-如何理解HTTP协议是无状态的" class="headerlink" title="2. 如何理解HTTP协议是无状态的"></a>2. 如何理解HTTP协议是无状态的</h3><p>　　HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。　　</p><h3 id="3-什么是长连接、短连接？"><a href="#3-什么是长连接、短连接？" class="headerlink" title="3. 什么是长连接、短连接？"></a>3. 什么是长连接、短连接？</h3><p>　　在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</div></pre></td></tr></table></figure></p><p>　　在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h4 id="3-1-TCP连接"><a href="#3-1-TCP连接" class="headerlink" title="3.1 TCP连接"></a>3.1 TCP连接</h4><p>　　当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p><p>经典的三次握手四次挥手示意图：<br><img src="/images/6159FF5BB9DB0467622B596D011BA80B.jpg" alt="IMAGE"><br><img src="/images/6890899C73432946708E77A8AE98FA43.jpg" alt="IMAGE"></p><h4 id="3-2-TCP短连接"><a href="#3-2-TCP短连接" class="headerlink" title="3.2 TCP短连接"></a>3.2 TCP短连接</h4><p>　　我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><h4 id="3-3-TCP长连接"><a href="#3-3-TCP长连接" class="headerlink" title="3.3 TCP长连接"></a>3.3 TCP长连接</h4><p>　　接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p><ul><li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li><li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li></ul><h4 id="3-4-长连接短连接操作过程"><a href="#3-4-长连接短连接操作过程" class="headerlink" title="3.4 长连接短连接操作过程"></a>3.4 长连接短连接操作过程</h4><p>短连接的操作步骤是：<br><code>建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接</code><br>长连接的操作步骤是：<br><code>建立连接——数据传输...（保持连接）...数据传输——关闭连接</code></p><h3 id="4-长连接和短连接的优点和缺点"><a href="#4-长连接和短连接的优点和缺点" class="headerlink" title="4. 长连接和短连接的优点和缺点"></a>4. 长连接和短连接的优点和缺点</h3><p>　　长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>　　短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p><h3 id="5-什么时候用长连接，短连接？"><a href="#5-什么时候用长连接，短连接？" class="headerlink" title="5. 什么时候用长连接，短连接？"></a>5. 什么时候用长连接，短连接？</h3><p>　  长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，每次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p><p>　　而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。<br>　　<br>　　<br>原文链接: <a href="http://www.cnblogs.com/0201zcr/p/4694945.html" target="_blank" rel="external">http://www.cnblogs.com/0201zcr/p/4694945.html</a></p><h3 id="补充-HTTP-keep-alive-和-websocket"><a href="#补充-HTTP-keep-alive-和-websocket" class="headerlink" title="补充: HTTP keep alive 和 websocket"></a>补充: HTTP keep alive 和 websocket</h3><p>可以把 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和HTTP有一些共性，是为了解决 HTTP 本身无法解决的某些问题而做出的一个改良设计。在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header；所谓的 polling 是指从客户端（一般就是浏览器）不断主动的向服务器发 HTTP 请求查询是否有新数据。这两种模式有一个共同的缺点，就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header，信息交换效率很低。它们建立的“长连接”都是伪.长连接，只不过好处是不需要对现有的 HTTP server 和浏览器架构做修改就能实现。</p><p>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。但是不需要发送 HTTP header就能交换数据显然和原有的 HTTP 协议是有区别的，所以它需要对服务器和客户端都进行升级才能实现。在此基础上 WebSocket 还是一个<strong>双通道</strong>的连接，在同一个 TCP 连接上既可以发也可以收信息。此外还有 multiplexing 功能，几个不同的 URI 可以复用同一个 WebSocket 连接。这些都是原来的 HTTP 不能做到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-HTTP协议与TCP-IP协议的关系&quot;&gt;&lt;a href=&quot;#1-HTTP协议与TCP-IP协议的关系&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP协议与TCP/IP协议的关系&quot;&gt;&lt;/a&gt;1. HTTP协议与TCP/IP协议的关系&lt;/h3&gt;&lt;p&gt;　　&lt;br&gt;　　HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="https://bummingboy.top/categories/network/"/>
    
    
      <category term="HTTP" scheme="https://bummingboy.top/tags/http/"/>
    
      <category term="长连接" scheme="https://bummingboy.top/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="短连接" scheme="https://bummingboy.top/tags/%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Node - pm2 cluster 模式无法使用babel-node启动</title>
    <link href="https://bummingboy.top/2018/04/26/Node%20-%20pm2%20cluster%20%E6%A8%A1%E5%BC%8F%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8babel-node%E5%90%AF%E5%8A%A8/"/>
    <id>https://bummingboy.top/2018/04/26/Node - pm2 cluster 模式无法使用babel-node启动/</id>
    <published>2018-04-26T06:45:38.656Z</published>
    <updated>2018-07-03T10:26:30.781Z</updated>
    
    <content type="html"><![CDATA[<p>为了使用 ES6/7 的新功能, 而且不进行转码, 项目一直使用 babel-node 启动脚本, 同时使用 pm2 进行项目管理, 开发环境下 babel-node 可以正常工作, 生产环境下 pm2 并不支持使用 babel-node,  </p><p>Because the cluster mode has an hardcoded interpreter which is node</p><p>也就是说 cluster 模式下 interpreter 是写死的使用的node, “exec_interpreter” 参数会被忽略.</p><p>通过以下方式通过 pm2 cluster 模式使用 ES6/7 新功能</p><p><a href="http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2#require-hook" target="_blank" rel="external">http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2#require-hook</a></p><ol><li>安装 babel-register, babel-polyfill</li><li><p>新建入口文件index.js, 假设原来的入口文件为app.js</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span>(<span class="string">'babel-register'</span>);</div><div class="line"><span class="keyword">require</span>(<span class="string">'babel-polyfill'</span>);</div><div class="line"><span class="keyword">require</span>(<span class="string">'app.js'</span>); <span class="regexp">//</span> 设置对应位置</div></pre></td></tr></table></figure></li><li><p>在对应的 pm2.json 文件中设置, 入口文件为 index.js.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了使用 ES6/7 的新功能, 而且不进行转码, 项目一直使用 babel-node 启动脚本, 同时使用 pm2 进行项目管理, 开发环境下 babel-node 可以正常工作, 生产环境下 pm2 并不支持使用 babel-node,  &lt;/p&gt;
&lt;p&gt;Because
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="Node" scheme="https://bummingboy.top/tags/node/"/>
    
      <category term="pm2" scheme="https://bummingboy.top/tags/pm2/"/>
    
      <category term="cluster" scheme="https://bummingboy.top/tags/cluster/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器内部无法正常解析域名</title>
    <link href="https://bummingboy.top/2018/04/25/Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E9%83%A8%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D/"/>
    <id>https://bummingboy.top/2018/04/25/Linux 服务器内部无法正常解析域名/</id>
    <published>2018-04-25T12:11:17.214Z</published>
    <updated>2018-07-03T10:26:11.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>  Linux 服务器内部无法正常解析域名, IP访问正常<br>  curl xxx.xxx Could not resolve host: xxx.xxx</p><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><p>可能的原因包括：</p><ul><li>DNS 设置问题</li><li>防火墙策略问题</li><li>NSCD 服务问题</li></ul><h2 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h2><p>1、通过如下指令，检查系统是否正确设置了 dns 服务器。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cat /etc/resolv.conf</div><div class="line"><span class="meta">#</span><span class="bash"> Generated by NetworkManager</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> No nameservers found; try putting DNS servers into your</span></div><div class="line"><span class="meta">#</span><span class="bash"> ifcfg files <span class="keyword">in</span> /etc/sysconfig/network-scripts like so:</span></div><div class="line"><span class="meta">#</span><span class="bash"></span></div><div class="line"><span class="meta">#</span><span class="bash"> DNS1=xxx.xxx.xxx.xxx</span></div><div class="line"><span class="meta">#</span><span class="bash"> DNS2=xxx.xxx.xxx.xxx</span></div><div class="line"><span class="meta">#</span><span class="bash"> DOMAIN=lab.foo.com bar.foo.com</span></div><div class="line">nameserver 10.242.197.247</div><div class="line">nameserver 10.242.197.248</div></pre></td></tr></table></figure></p><p>如果没有 DNS 的配置则需要添加设置，公网服务器可以设置为阿里云如下公共 DNS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">nameserver</span> 223<span class="selector-class">.5</span><span class="selector-class">.5</span><span class="selector-class">.5</span></div><div class="line"><span class="selector-tag">nameserver</span> 223<span class="selector-class">.6</span><span class="selector-class">.6</span><span class="selector-class">.6</span></div></pre></td></tr></table></figure></p><p>2、检查防火墙 iptables，查看是否有拦截 53 端口的相关规则。</p><p>可以先使用命令 service iptables stop 关闭防火墙对比测试。如果存在 iptables 规则，尝试删除 deny 策略或修改规则为 ACCEPT 策略。</p><p>3、检查是否开启 dns 缓存服务 nscd：</p><p>通过 service  nscd  status 命令查看服务状态。如果已经开启，尝试使用命令 service  nscd  stop 关闭服务后再对比测试。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service nscd status</div><div class="line">service nscd stop</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;  Linux 服务器内部无法正常解析域名, IP访问正常&lt;br&gt;  curl xxx.xxx Could not reso
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://bummingboy.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 阻止自动http 跳转 https</title>
    <link href="https://bummingboy.top/2018/04/25/Chrome%20%E9%98%BB%E6%AD%A2%E8%87%AA%E5%8A%A8http%20%E8%B7%B3%E8%BD%AC%20https/"/>
    <id>https://bummingboy.top/2018/04/25/Chrome 阻止自动http 跳转 https/</id>
    <published>2018-04-25T12:11:17.198Z</published>
    <updated>2018-07-03T12:00:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>配置一个服务使用SSL出错, 当前使用的是二级域名, 根域名有别的SSL证书, 然后切换回http时, 一直自动跳转到https, 使用的是根域名的SSL证书, 跟当前二级域名不相符, 一直提示不安全的连接, 很长时间无法直接访问http.</p><a id="more"></a><p>解决办法:</p><p>在chrome的地址栏输入：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">chrome:</span>//net-internals/<span class="meta">#hsts</span></div></pre></td></tr></table></figure></p><p>在打开的页面中，Delete domain栏的输入框中输入：xxxx.xxxxx(要访问的域名)，然后点击“delete”按钮，即可完成配置。</p><p>然后你可以在Query domain栏中搜索刚才输入的域名，点击“query”按钮后如果提示“Not found”，那么你现在就可以使用http来访问那个网站了！</p><p>至于 chrome hsts 的作用看这里</p><h3 id="HSTS-简介"><a href="#HSTS-简介" class="headerlink" title="HSTS 简介"></a>HSTS 简介</h3><p>国际互联网工程组织IETE正在推行一种新的Web安全协议HTTP Strict Transport Security（HSTS）<br>采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。<br>该协议将帮助网站采用全局加密，用户看到的就是该网站的安全版本。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在第一次访问https网站时，网站的回复表头带有「Strict-Transport-Security」，该表头会让浏览器记得，该网站(正确说法是域名)有提供HTTPS安全连线，并于下次连线中强制使用HTTPS，注意是强制喔，不论是点进不带有https的连接，或是你故意在网址里打入网址时使用 http:// 为开头，浏览器都会先强制转换成https再送出请求</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置一个服务使用SSL出错, 当前使用的是二级域名, 根域名有别的SSL证书, 然后切换回http时, 一直自动跳转到https, 使用的是根域名的SSL证书, 跟当前二级域名不相符, 一直提示不安全的连接, 很长时间无法直接访问http.&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome" scheme="https://bummingboy.top/categories/chrome/"/>
    
    
      <category term="Chrome" scheme="https://bummingboy.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>shell - 判断文件夹是否存在</title>
    <link href="https://bummingboy.top/2018/04/25/shell%20-%20%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <id>https://bummingboy.top/2018/04/25/shell - 判断文件夹是否存在/</id>
    <published>2018-04-25T12:11:17.171Z</published>
    <updated>2018-07-03T10:26:38.960Z</updated>
    
    <content type="html"><![CDATA[<p>#shell判断文件夹是否存在</p><p>#如果文件夹不存在，创建文件夹<br>if [ ! -d “/myfolder” ]; then<br>  mkdir /myfolder<br>fi</p><p>#shell判断文件,目录是否存在或者具有权限</p><p>folder=”/var/www/“<br>file=”/var/www/log”</p><h1 id="x-参数判断-folder-是否存在并且是否具有可执行权限"><a href="#x-参数判断-folder-是否存在并且是否具有可执行权限" class="headerlink" title="-x 参数判断 $folder 是否存在并且是否具有可执行权限"></a>-x 参数判断 $folder 是否存在并且是否具有可执行权限</h1><p>if [ ! -x “$folder”]; then<br>  mkdir “$folder”<br>fi</p><h1 id="d-参数判断-folder-是否存在"><a href="#d-参数判断-folder-是否存在" class="headerlink" title="-d 参数判断 $folder 是否存在"></a>-d 参数判断 $folder 是否存在</h1><p>if [ ! -d “$folder”]; then<br>  mkdir “$folder”<br>fi</p><h1 id="f-参数判断-file-是否存在"><a href="#f-参数判断-file-是否存在" class="headerlink" title="-f 参数判断 $file 是否存在"></a>-f 参数判断 $file 是否存在</h1><p>if [ ! -f “$file” ]; then<br>  touch “$file”<br>fi</p><h1 id="n-判断一个变量是否有值"><a href="#n-判断一个变量是否有值" class="headerlink" title="-n 判断一个变量是否有值"></a>-n 判断一个变量是否有值</h1><p>if [ ! -n “$var” ]; then<br>  echo “$var is empty”<br>  exit 0<br>fi</p><h1 id="判断两个变量是否相等"><a href="#判断两个变量是否相等" class="headerlink" title="判断两个变量是否相等"></a>判断两个变量是否相等</h1><p>if [ “$var1” = “$var2” ]; then<br>  echo ‘$var1 eq $var2’<br>else<br>  echo ‘$var1 not eq $var2’<br>fi</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#shell判断文件夹是否存在&lt;/p&gt;
&lt;p&gt;#如果文件夹不存在，创建文件夹&lt;br&gt;if [ ! -d “/myfolder” ]; then&lt;br&gt;  mkdir /myfolder&lt;br&gt;fi&lt;/p&gt;
&lt;p&gt;#shell判断文件,目录是否存在或者具有权限&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="shell" scheme="https://bummingboy.top/categories/shell/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell - 条件判断 if 中 -a 到 -z 的意思</title>
    <link href="https://bummingboy.top/2018/04/25/shell%20-%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif%E4%B8%AD%E7%9A%84-a%E5%88%B0-z%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <id>https://bummingboy.top/2018/04/25/shell - 条件判断if中的-a到-z的意思/</id>
    <published>2018-04-25T12:11:17.166Z</published>
    <updated>2018-07-03T10:26:52.735Z</updated>
    
    <content type="html"><![CDATA[<p>[ -a FILE ] 如果 FILE 存在则为真。 </p><p>[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 </p><p>[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 </p><p>[ -d FILE ] 如果 FILE 存在且是一个目录则为真。</p><p>[ -e FILE ] 如果 FILE 存在则为真。 </p><p>[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</p><p>[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</p><p>[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。</p><p>[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</p><p>[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</p><p>[ -r FILE ] 如果 FILE 存在且是可读的则为真。 </p><p>[ -s FILE ] 如果 FILE 存在且大小不为0则为真。 </p><p>[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。</p><p>[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</p><p>[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。</p><p>[ -x FILE ] 如果 FILE 存在且是可执行的则为真。 </p><p>[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 </p><p>[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</p><p>[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 </p><p>[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 </p><p>[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 </p><p>[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2,</p><p>or 如果 FILE1 exists and FILE2 does not则为真。 </p><p>[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 </p><p>[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</p><p>[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 </p><p>[ -z STRING ] “STRING” 的长度为零则为真。 </p><p>[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 </p><p>[ STRING1 == STRING2 ] 如果2个字符串相同。</p><p> “=” may be used instead of “==” for strict POSIX compliance则为真。 </p><p>[ STRING1 != STRING2 ] 如果字符串不相等则为真。 </p><p>[ STRING1 &lt; STRING2 ]</p><p>如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 </p><p>[ STRING1 &gt; STRING2 ]</p><p>如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 </p><p>[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[ -a FILE ] 如果 FILE 存在则为真。 &lt;/p&gt;
&lt;p&gt;[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 &lt;/p&gt;
&lt;p&gt;[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 &lt;/p&gt;
&lt;p&gt;[ -d FILE ] 如果
      
    
    </summary>
    
      <category term="shell" scheme="https://bummingboy.top/categories/shell/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
      <category term="if" scheme="https://bummingboy.top/tags/if/"/>
    
  </entry>
  
  <entry>
    <title>Node - Event loop</title>
    <link href="https://bummingboy.top/2018/04/07/Node%20-%20Event%20Loop/"/>
    <id>https://bummingboy.top/2018/04/07/Node - Event Loop/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-07-20T10:54:07.211Z</updated>
    
    <content type="html"><![CDATA[<p>Event Loop 允许Node.js执行非阻塞I/O操作, 尽管JavaScript是单线程的,只要有可能就将操作卸载到系统内核。<br>由于大多数现代内核是多线程的，所以它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会通知Node.js，以便可以将相应的回调(callbacks)添加到轮询队列(poll queue)中以最终执行。事件循环每次循环称为一次Tick 我们稍后将在本主题中进一步详细解释。</p><h3 id="Event-Loop的解释"><a href="#Event-Loop的解释" class="headerlink" title="Event Loop的解释"></a>Event Loop的解释</h3><p>英文原文：<br><em>When Node.js starts, it initializes the event loop, processes the provided input script (or drops into the REPL, which is not covered in this document) which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.</em></p><p>当Node.js启动时会初始化event loop, 每一个event loop都会包含按如下顺序六个循环阶段</p><p>   ┌───────────────────────┐<br>┌─&gt;│        timers         │  (setTimeout(), setInterval())<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     I/O callbacks     │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     idle, prepare     │<br>│  └──────────┬────────────┘      ┌───────────────┐<br>│  ┌──────────┴────────────┐      │   incoming:   │<br>│  │         poll          │&lt;─────┤  connections, │<br>│  └──────────┬────────────┘      │   data, etc.  │<br>│  ┌──────────┴────────────┐      └───────────────┘<br>│  │        check          │  (setImmediate())<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>└──┤    close callbacks    │<br>   └───────────────────────┘</p><h3 id="阶段概览"><a href="#阶段概览" class="headerlink" title="阶段概览"></a>阶段概览</h3><ul><li>timers 阶段: 这个阶段执行setTimeout(callback) and setInterval(callback)预定的callback;</li><li>I/O callbacks 阶段: 执行除了close事件的callbacks、被timers(定时器，setTimeout、setInterval等)设定的callbacks、setImmediate()设定的callbacks之外的callbacks;</li><li>idle, prepare 阶段: 仅node内部使用;</li><li>poll 阶段: 获取新的I/O事件, 适当的条件下node将阻塞在这里;</li><li>check 阶段: 执行setImmediate() 设定的callbacks;</li><li>close callbacks 阶段: 比如socket.on(‘close’, callback)的callback会在这个阶段执行.</li></ul><p><em><strong>注意: </strong></em></p><ul><li>上面六个阶段都不包括 process.nextTick() </li></ul><p>每一个阶段都有一个装有callbacks的fifo queue(队列)，当event loop运行到一个指定阶段时，<br>node将执行该阶段的fifo queue(队列)，当队列callback执行完或者执行callbacks数量超过该阶段的上限时，<br>event loop会转入下一下阶段.</p><p>由于这些操作中的任何一个都可以调度更多操作，并且在轮询阶段中处理的新事件由内核排队，所以轮询事件可以在轮询事件被处理的同时排队。因此，长时间运行的回调可以使轮询阶段(poll)的运行时间远远超过计时器的阈值.有关更多详细信息，请参阅定时器和轮询部分。</p><p>在事件循环的每次运行之间，Node.js检查是否正在等待任何异步I/O或定时器，如果没有任何异步I/O或定时器，则清除关闭。</p><h3 id="各阶段详情"><a href="#各阶段详情" class="headerlink" title="各阶段详情"></a>各阶段详情</h3><h4 id="times"><a href="#times" class="headerlink" title="times"></a>times</h4><p>计时器指定阈值(threshold)，然后执行提供的回调(callback)，但是可能不是我们希望它执行的确切时间。也就是说定时器的时间是有误差的.<br>定时器回调会在指定的时间过后按照预定的时间运行; 但是，操作系统调度或其他回调的运行可能会延迟它们。 注意：从技术上讲，poll阶段控制何时执行定时器。</p><p>例子: 假设您计划在100 ms阈值后执行超时，然后异步开始读取需要95 ms的文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="comment">// Assume this takes 95ms to complete</span></div><div class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(delay + <span class="string">'ms have passed since I was scheduled'</span>);</div><div class="line">&#125;, <span class="number">100</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></div><div class="line">someAsyncOperation(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</div><div class="line"></div><div class="line">  <span class="comment">// do something that will take 10ms...</span></div><div class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</div><div class="line">    <span class="comment">// do nothing</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>当事件循环进入轮询阶段时,它有一个空的队列(fs.readFile()还没有完成),所以它将等待剩余的毫秒数,直到达到最快的定时器的阈值.当它等待95ms传递时，fs.readFile（）完成读取文件，并且其需要10ms完成的回调被添加到轮询队列并被执行。 当回调完成时，队列中没有更多的回调，所以事件循环会看到最后一个定时器的阈值已经达到，然后回到定时器阶段执行定时器的回调。在这个例子中，你会看到被调度的定时器和它正在执行的回调之间的总延迟将是105ms。</p><h4 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h4><p>处理一些系统调用错误，比如网络 stream, pipe, tcp, udp通信的错误callback 例如，如果尝试连接时TCP套接字收到ECONNREFUSED，则某些*nix系统要等待报告错误。这将排队在I/O回调阶段执行。</p><h4 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle, prepare"></a>idle, prepare</h4><p>node 内部调用 忽略</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll阶段有两个主要功能： </p><ul><li>处理轮询队列(poll queue)中的事件(callback)</li><li>执行阈值已过的定时器timers的事件(callback)</li></ul><p>当事件循环进入poll阶段并且代码未设置计时器时，会发生以下两种情况之一：</p><ul><li>如果轮询队列(poll queue)不是空的，则事件循环将遍历队列并同步执行它们的回调队列，直到队列被清空或达到系统相关的硬限制。 </li><li>如果轮询队列(poll queue)为空，则会发生以下两件事情之一:<ul><li>如果脚本已由setImmediate（）调度，则事件循环将结束poll阶段并执行check阶段(check阶段的queue是 setImmediate设定的)</li><li>如果脚本没有被setImmediate（）调度，事件循环将等待callback被添加到队列，然后立即执行。</li></ul></li></ul><p>当事件循环进入poll阶段并且轮询队列(poll queue)为空, 事件循环将检查已达到时间阈值的定时器. 如果一个或多个定时器准备就绪, 则事件循环将回到timers阶段以执行这些定时器的回调(callbacks).</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>check阶段允许代码在poll queue空闲后立即执行回调。也就是setImmediate() 如果poll queue空闲并且代码中已经设置了setImmediate()，则事件循环直接进入到check阶段。 setImmediate（）实际上是一个特殊的定时器，它在事件循环的一个单独的阶段中运行。 它使用一个libuv API来调度poll阶段完成后执行的回调。 通常，随着代码的执行，事件循环将最终进入poll阶段，在那里它将等待传入连接，请求等。但是，如果使用setImmediate（）设置了回调并且poll queue空闲，将直接进入check阶段，而不是等待poll事件。</p><h3 id="setImmediate和setTimeout"><a href="#setImmediate和setTimeout" class="headerlink" title="setImmediate和setTimeout"></a>setImmediate和setTimeout</h3><p>setImmediate和setTimeout 是相似的，但取决于它们何时被调用，以不同的方式运行.</p><ul><li>setImmediate() 用于在当前的poll阶段完成后执行脚本.</li><li>setTimeout() 计划一个脚本，以ms为单位的最小阈值运行.</li></ul><p>setTimeout(fun(), 0) === setTimeout(fun(), 1)<br>另外, setTimeout(), HTML5中会有最低限制4ms, 这与浏览器有关, Node 中setTimeout通过libuv模块实现, 模块最终调用平台底层的高精度定时器, 并不会有这个限制. 详情(<a href="http://www.developerq.com/article/1488429596" target="_blank" rel="external">http://www.developerq.com/article/1488429596</a>)</p><p>以下例子的输出结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>)</div><div class="line">&#125;, <span class="number">0</span>);</div><div class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</div><div class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</div></pre></td></tr></table></figure></p><p>结果:(忽略换行)<br>  理论上235401 / 235410<br>  实际由于1ms时间很短, 所以235401</p><p>分析:</p><p>  > setTimeout(func(), 0) === setTimeout(func(), 1), 并不会直接运行, 会将func()放入times queue;</p><p>  > setImmediate()是check阶段运行, 会将func()放入check queue;</p><p>  > new Promise() Promise创建就会直接执行, 所以会输出 <strong><em>2</em></strong>; 执行for循环, i === 9999时, resolve()返回一个新的Promise对象, 但是.then() 是异步执行的, 也就是会把下一个.then()放到当前的poll queue中, 等待当前poll阶段执行完, 然后输出<strong><em>3</em></strong> 和 <strong><em>5</em></strong>,  此时poll阶段执行完, 遍历poll queue输出<strong><em>4</em></strong></p><p>  > poll 阶段结束, 检查times阶段的定时器是否达到或超过设定的阈值, 如果超过设置的阈值, 则执行times callback 即输出 <strong><em>0</em></strong>, 然后进入check阶段 输出<strong><em>1</em></strong>; 01的输出顺序取决于执行第3步时的时间, 该时间 大于setTimuout()的阈值则先输出<strong><em>0</em></strong>, 否则先输出<strong><em>1</em></strong>; 尝试修改setTimeout(xx, 11), 则本机先输出<strong><em>1</em></strong>;</p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>  从技术上来说，它并不是event loop的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前操作完成后处理，不管目前处于event loop的哪个阶段。</p><p>  看看我们最初给的示意图，process.nextTick()不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。</p><h4 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a>process.nextTick() vs setImmediate()</h4><ul><li>process.nextTick()立即在本阶段执行回调；</li><li>setImmediate()只能在 check 阶段执行回调。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Event Loop 允许Node.js执行非阻塞I/O操作, 尽管JavaScript是单线程的,只要有可能就将操作卸载到系统内核。&lt;br&gt;由于大多数现代内核是多线程的，所以它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会通知Node.js，以便可以将相应的
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="Node" scheme="https://bummingboy.top/tags/node/"/>
    
      <category term="Event loop" scheme="https://bummingboy.top/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>Node - 异常捕获</title>
    <link href="https://bummingboy.top/2018/04/04/Node%20-%20%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <id>https://bummingboy.top/2018/04/04/Node - 异常捕获/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-07-20T10:53:26.978Z</updated>
    
    <content type="html"><![CDATA[<p>当出现未被程序捕捉的异常时, 整个服务将会终止. 即使有的异常被捕捉, 但是无法返回有效的失败响应, 只能通过返回服务超时也会影响产品的体验. 总的解决方案是 try…catch 捕获程序中的同步异常, 异步异常分为多种情况</p><ul><li>Promise不需要使用try…catch，直接使用.catch()</li><li>Generator 可以直接使用co 函数库来使用try…catch</li><li>async 和 await 可以直接使用try…catch</li><li>回调函数可以通过 <strong>domain</strong> 模块来捕捉异常. (domain 模块正在被弃用, 谨慎使用)</li><li>process.on(‘uncaughtException’, function(e) { … })  捕捉未被程序捕捉的异常, 需要注意的是 ‘uncaughtException’ 异常会丢失当前环境的堆栈信息, 导致 Node 不能进行内存回收, 也就是说每一次的 uncaughtException 都有可能导致内存泄漏, 为了防止内存泄漏, 需要优雅的退出程序.</li><li>对比之下 process.on(‘unhandledRejection’, function(e){ … }), 捕捉的是未被 catch 的 promise 内的异常, 也就是 promise 内的 reject. 不同的是 unhandledRejection 并不会直接使程序退出, 只是会抛出 UnhandledPromiseRejectionWarning: …</li></ul><p>  因为 domain 即将被弃用, 就不重点研究了, 感兴趣的可以看一下相关的参考文章:<br>    <a href="https://nodejs.org/api/domain.html#" target="_blank" rel="external">https://nodejs.org/api/domain.html#</a><br>    <a href="https://cnodejs.org/topic/516b64596d38277306407936" target="_blank" rel="external">https://cnodejs.org/topic/516b64596d38277306407936</a></p><h3 id="uncaughtException"><a href="#uncaughtException" class="headerlink" title="uncaughtException"></a>uncaughtException</h3><p>为了防止 uncaughtException 导致内存泄漏, 当捕捉到 uncaughtException 时, 应该重启服务.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> uncaughtException 避免程序崩溃</div><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="keyword">function</span> (err) &#123;</div><div class="line">    console.log(err);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        <span class="regexp">//</span> 强制退出机制 </div><div class="line">        var timer = setTimeout(<span class="keyword">function</span> () &#123;</div><div class="line">            process.<span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;, <span class="number">30000</span>);</div><div class="line">        timer.unref();</div><div class="line">        </div><div class="line">        <span class="regexp">//</span> 自动退出机制</div><div class="line">        server.close();</div><div class="line">    &#125; catch (e) &#123;</div><div class="line">        console.log(<span class="string">'error when exit'</span>, e.stack);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li>Node 所有连接都被释放后进程会自动结束, 所以不需要在 server.close 方法的回调函数中退出进程</li><li>强制退出机制, 用户连接有可能因为某些原因无法释放，在这种情况下应该强制退出整个进程。</li><li>timer.unref(): 如果不使用 unref 方法，那么即使 server 的所有连接都关闭，Node 也会保持运行直到 timer 的回调函数被调用。unref 可以创建一个”不保持程序运行”的计时器。</li><li>处理异常时要小心的把异常处理逻辑用 try/catch 包住，避免处理异常时抛出新的异常</li></ul><h4 id="和-cluster-一起使用"><a href="#和-cluster-一起使用" class="headerlink" title="和 cluster 一起使用"></a>和 cluster 一起使用</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">cluster</span> = require('<span class="keyword">cluster</span>');</div><div class="line"></div><div class="line">process.<span class="keyword">on</span>('uncaughtException', function (<span class="keyword">err</span>) &#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="keyword">err</span>);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        <span class="keyword">var</span> <span class="keyword">timer</span> = setTimeout(function () &#123;</div><div class="line">            process.<span class="keyword">exit</span>(1);</div><div class="line">        &#125;, 30000);</div><div class="line">        <span class="keyword">timer</span>.unref();</div><div class="line"></div><div class="line">        server.<span class="keyword">close</span>();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">cluster</span>.worker) &#123;</div><div class="line">            <span class="keyword">cluster</span>.worker.disconnect();</div><div class="line">        &#125;</div><div class="line">    &#125; catch (<span class="keyword">e</span>) &#123;</div><div class="line">        console.<span class="built_in">log</span>('<span class="keyword">error</span> when <span class="keyword">exit</span>', <span class="keyword">e</span>.<span class="keyword">stack</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当出现未被程序捕捉的异常时, 整个服务将会终止. 即使有的异常被捕捉, 但是无法返回有效的失败响应, 只能通过返回服务超时也会影响产品的体验. 总的解决方案是 try…catch 捕获程序中的同步异常, 异步异常分为多种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise不需要使
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="Node" scheme="https://bummingboy.top/tags/node/"/>
    
      <category term="内存" scheme="https://bummingboy.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Node - 内存管理</title>
    <link href="https://bummingboy.top/2018/04/03/Node%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://bummingboy.top/2018/04/03/Node - 内存管理/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-07-20T10:27:23.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h3><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>JavaScript 自动垃圾收集最常用的方式: <strong>标记清除</strong>. 当变量进入环境(函数中声明一个变量)时, 就将这个变量标记为: “进入环境”, 进入环境的变量使用的内存, 在代码执行过程中就有可能会用到, 所以不能回收. 当变量离开环境时, 则将其标记为: “离开环境”, 在下一次垃圾回收时, 清理响应内存.<br>垃圾收集器咋运行的时候会给存储在内存中的所有变量都加上标记(可以使用任何方式, 重要的是标记策略), 然后去掉环境中正在使用的变量和有被引用的变量的标记, 还有标记的变量会被认为准备删除的变量. 原因是环境中的变量已经无法访问到这些变量了. 最后垃圾收集器清除对应的内存, 销毁那些带标记的值并回收他们所占用的空间.</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>另外还有JavaScript中不太常见的垃圾收集策略: <strong>引用计数</strong>. 引用计数的含义是跟踪记录每个值被引用的次数, 当声明了一个变量并将一个引用类型值赋给该变量时, 则这个值的引用次数就是1, 被引用次数 +1, 取消引用次数-1, 当这个值的引用计数为 0时, 说明这个值不会再被其他变量引用, 可以被销毁了. 当垃圾回收器下次运行时, 会释放对应的内存.</p><p>引用计数的策略容易出现<strong>循环引用</strong>, 简单说就是 ObjectA 和 ObjectB 通过各自属性相互引用, 引用计数永远不会变成0, 对用的内存也就不会被回收也就是内存泄漏. 解决办法就是打破引用环就可以了. JavaScript 中在不使用变量后将变量置为 null, 以防止内存泄漏. OC 和 Swift中 使用就是引用计数的垃圾回收策略, 通过弱引用的方式防止循环引用.</p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>垃圾回收是周期性运行的, 变量数量多垃圾回收的工作量会很大, 垃圾回收的时间间隔会很影响性能.</p><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>不使用变量后置为 null.</p><h3 id="V8-内存管理"><a href="#V8-内存管理" class="headerlink" title="V8 内存管理"></a>V8 内存管理</h3><h4 id="V8-内存构成"><a href="#V8-内存构成" class="headerlink" title="V8 内存构成"></a>V8 内存构成</h4><p>Node 构建于 V8 引擎之上, JavaScript 进行前端开发时内存管理的问题不会那么明显. 对于后端程序内存管理就很重要了, 长时间运行的程序一旦出现内存泄漏, 最后服务器的内存资源都会被耗尽的. </p><p>Nodejs 常驻内存组成:</p><ul><li>代码区(Code Segment): 存放即将执行的代码片段</li><li>栈(Stack): 存放即将执行的代码片段</li><li>堆(Heap): 存放对象实体, 闭包上下文</li><li><p>堆外内存: 不通过 V8 分配, 也不受 V8 管理. (例如: Buffer对象的数据)</p><p>栈内存又分为很多区域:</p></li><li><p>新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁</p></li><li>老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li><li>老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针</li><li>大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象</li><li>代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li><li><p>Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</p><p>但是为了简单就只介绍新老生代的内存管理. (原文找不到了, 只找到了快照 <a href="http://webcache.googleusercontent.com/search?q=cache:KwKkZfJ1QycJ:alinode.alicdn.com/blog/37+&amp;cd=19&amp;hl=zh-TW&amp;ct=clnk&amp;gl=us" target="_blank" rel="external">http://webcache.googleusercontent.com/search?q=cache:KwKkZfJ1QycJ:alinode.alicdn.com/blog/37+&amp;cd=19&amp;hl=zh-TW&amp;ct=clnk&amp;gl=us</a>)</p></li></ul><h4 id="V8-垃圾回收"><a href="#V8-垃圾回收" class="headerlink" title="V8 垃圾回收"></a>V8 垃圾回收</h4><ul><li>栈内存分配和回收非常直接, 当程序离开某作用域(某函数执行完成后), 其指针下移(出栈), 该作用域的局部变量会出栈, 内存回收. (闭包引用的变量是存储在堆内存中的, 下面有例子)</li><li>堆内存回收采用<strong>垃圾回收机制</strong>进行堆内存的管理, 也是开发中可能造成内存泄漏的部分.</li></ul><h5 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h5><p>老生代内存64位系统下约为1.4G，32位系统下约为0.7G，新生代内存64位系统下约为32MB，32系统下约为16MB</p><p>通过<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">node</span> <span class="title">--max-old-space-size</span>=xxx（单位MB）</div><div class="line"><span class="keyword">node</span> <span class="title">--max-new-space-size</span>=xxx（单位KB）</div></pre></td></tr></table></figure></p><p>设置新生代内存以及老生代内存来破解默认的内存限制。</p><h5 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h5><ul><li><p>新生代垃圾回收</p><p>新对象都会被分配到新生代, 当新生代空间不足以分配新对象时, 将触发新生代的垃圾回收.<br>新生代的对象主要通过 Scavenge 算法进行垃圾回收, 这是一种采用复制的方式实现内存回收的算法.<br>Sacvenge 算法将新生代的总空间一分为二, 只使用其中一个, 另一个处于闲置, 等待垃圾回收时使用. 使用中的那块空间成为 From, 闲置的空间称为 To. 当新生代触发垃圾回收时, V8 将 From 空间中所有应该存活下来的对象依次复制到 To 空间. </p><p>有两种情况不会将对象复制到 To 空间, 而是晋升至老年代:</p><ol><li>对象此前已经经历过一次新生代垃圾回收, 这次依旧应该存活, 则晋升至老年代.</li><li>To 空间已经使用了 25%, 则将对象直接晋升至老年代. 因为 From 空间复制完成后, To 空间会被作为 From 空间使用, 会为新对象分配内存, 剩余内存太少会影响程序的新对象分配.</li></ol><p>From 空间所有应该存活的对象都复制完成后, 原本的 From 空间将被释放, 成为闲置空间, 原本 To 空间则成为使用 From 空间, 两个空间进行了角色翻转.</p><p>Scavenge 算法优缺点: </p><ul><li>优点: 只复制活着的对象, 而根据统计学指导, 新生代中大多数对象寿命都不长, 长期存活对象少, 所以 Scavenge 的效率很高<pre><code>Scavenge 是依次连续复制, To 空间不存在内存碎片.</code></pre></li><li>缺点: 因为 Scavenge 的复制方式会将新生代对半划分, 导致内存的空间利用率不高.</li></ul></li><li><p>老生代垃圾回收</p><p>老生代中的对象都是经历过一个或多次垃圾回收的对象, 而且老生代空间要比新生代大得多(一般老生代空间是新生代空间的40 倍), 使用 Scavenge 算法需要复制的对象太多会导致效率降低, 而且空间利用率也很低, 所以老生代不是采用 Scavenge 算法进行垃圾回收的, 而是采用 <strong>标记清除和标记整理</strong>.</p><p>当老生代触发垃圾回收时, V8 会将需要存活的对象打上标记, 然后将没有标记的对象, 也就是死亡的对象清除, 就完成了一次<strong>标记清除</strong>.<br>被清除的对象是不连续的内存空间, 导致老生代产生很多的闲置的内存碎片, 可能并没有足够大连续的空间存储较大的对象, 此时需要解决空间碎片, 也就是内存整理, <strong>标记整理算法</strong>就是j将存活的对象移向内存一侧, 使其连续. 因为<strong>标记整理算法</strong>需要移动大量的内存空间, 执行耗费大量时间和资源, 因此只有当剩余空间无法存储新的大的对象时才会触发<strong>标记整理算法</strong></p><p><strong>增量标记清除</strong></p><p>早期的老生代垃圾回收机制, 采用全停顿, 也就是垃圾回收时程序运行会被暂. 浏览器时代使用内存不多, 卡顿不是很明显, Nodejs 时代后台程序使用大量内存, 全停顿方式很容易带来明显的迟滞, 标记阶段很容易引起卡顿, 因此后期 V8 采用增量标记, 将标记阶段分为若干小步骤, 每个步骤控制在 5ms内, 每执行一段时间标记行为, 就继续运行 JS 程序, 交替进行, 类似于 操作系统的时间片轮转, 提高程序的流畅度.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;垃圾回收策略&quot;&gt;&lt;a href=&quot;#垃圾回收策略&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收策略&quot;&gt;&lt;/a&gt;垃圾回收策略&lt;/h3&gt;&lt;h4 id=&quot;标记清除&quot;&gt;&lt;a href=&quot;#标记清除&quot; class=&quot;headerlink&quot; title=&quot;标
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="Node" scheme="https://bummingboy.top/tags/node/"/>
    
      <category term="内存" scheme="https://bummingboy.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Node - 内存泄漏</title>
    <link href="https://bummingboy.top/2018/04/03/Node%20-%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://bummingboy.top/2018/04/03/Node - 内存泄漏/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-07-20T10:26:53.819Z</updated>
    
    <content type="html"><![CDATA[<p>内存泄漏（Memory Leak）指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况</p><p>Node.js 使用 V8 作为 JavaScript 的执行引擎，所以讨论 Node.js 的 GC 情况就等于在讨论 V8 的 GC。在 V8 中一个对象的内存是否被释放，是看程序中是否还有地方持有改对象的引用。</p><p>在 V8 中，每次 GC 时，是根据 root 对象 (浏览器环境下的 window，Node.js 环境下的 global ) 依次梳理对象的引用，如果能从root的引用链到达访问，V8就会将其标记为可到达对象，反之为不可到达对象。被标记为不可到达对象（即无引用的对象）后就会被 V8 回收。(<a href="http://alinode.aliyun.com/blog/37" target="_blank" rel="external">http://alinode.aliyun.com/blog/37</a>)</p><h3 id="V8内存限制"><a href="#V8内存限制" class="headerlink" title="V8内存限制"></a>V8内存限制</h3><p>node基于V8构建，通过V8的方式进行分配跟管理js对象。V8对内存的使用有限制（老生代内存64位系统下约为1.4G，32位系统下约为0.7G，新生代内存64位系统下约为32MB，32系统下约为16MB）。在这样的限制下，将导致无法操作大内存对象。如果不小心触碰这个界限，就会造成进程退出。</p><p>原因： V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。</p><p>通过<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">node</span> <span class="title">--max-old-space-size</span>=xxx（单位MB）</div><div class="line"><span class="keyword">node</span> <span class="title">--max-new-space-size</span>=xxx（单位KB）</div></pre></td></tr></table></figure></p><p>设置新生代内存以及老生代内存来破解默认的内存限制。</p><h3 id="V8的堆构成"><a href="#V8的堆构成" class="headerlink" title="V8的堆构成"></a>V8的堆构成</h3><p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：</p><ul><li>新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回收特别频繁</li><li>老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li><li>老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针</li><li>大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象</li><li>代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li><li>Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</li></ul><h3 id="GC回收类型"><a href="#GC回收类型" class="headerlink" title="GC回收类型"></a>GC回收类型</h3><ul><li><p>增量式GC<br>表示垃圾回收器在扫描内存空间时是否收集（增加）垃圾并在扫描周期结束时清空垃圾。</p></li><li><p>非增量式GC<br>使用非增量式垃圾收集器时，一收集到垃圾即将其清空。</p></li></ul><p>垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。对象首先进入占用空间较少的新生代内存。大部分对象会很快失效，非增量GC直接回收这些少量内存。假如有些对象一段时间内不能被回收，则进去老生代内存区。这个区域则执行不频繁的增量GC，且耗时较长。</p><h3 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h3><h4 id="一、全局变量"><a href="#一、全局变量" class="headerlink" title="一、全局变量"></a>一、全局变量</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;</div><div class="line"><span class="comment">//未声明对象。</span></div><div class="line"></div><div class="line">global.b = <span class="number">11</span>;</div><div class="line"><span class="comment">//全局变量引用</span></div></pre></td></tr></table></figure><p>这种比较简单的原因，全局变量直接挂在 root 对象上，不会被清除掉。</p><h4 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> bigData = <span class="keyword">new</span> Buffer(<span class="number">100</span>);</div><div class="line">  inner = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span> bigData;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>闭包会引用到父级函数中的变量，如果闭包未释放，就会导致内存泄漏。上面例子是 inner 直接挂在了 root 上，从而导致内存泄漏（bigData 不会释放）。</p><p>需要注意的是，这里举得例子只是简单的将引用挂在全局对象上，实际的业务情况可能是挂在某个可以从 root 追溯到的对象上导致的。</p><h4 id="三、事件监听"><a href="#三、事件监听" class="headerlink" title="三、事件监听"></a>三、事件监听</h4><p>Node.js 的事件监听也可能出现的内存泄漏。例如对同一个事件重复监听，忘记移除（removeListener），将造成内存泄漏。这种情况很容易在复用对象上添加事件时出现，所以事件重复监听可能收到如下警告：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">node</span><span class="title">:2752</span>) Warning: Possible EventEmitter memory leak detected。<span class="number">11</span> haha listeners added。Use emitter。setMaxListeners() to increase limit</div></pre></td></tr></table></figure></p><p>例如，Node.js 中 Agent 的 keepAlive 为 true 时，可能造成的内存泄漏。当 Agent keepAlive 为 true 的时候，将会复用之前使用过的 socket，如果在 socket 上添加事件监听，忘记清除的话，因为 socket 的复用，将导致事件重复监听从而产生内存泄漏。</p><p>原理上与前一个添加事件监听的时候忘了清除是一样的。在使用 Node.js 的 http 模块时，不通过 keepAlive 复用是没有问题的，复用了以后就会可能产生内存泄漏。所以，你需要了解添加事件监听的对象的生命周期，并注意自行移除。</p><p>关于这个问题的实例，可以看 Github 上的 issues（node Agent keepAlive 内存泄漏）(<a href="https://github.com/nodejs/node/issues/9268" target="_blank" rel="external">https://github.com/nodejs/node/issues/9268</a>)</p><h4 id="四、其他原因"><a href="#四、其他原因" class="headerlink" title="四、其他原因"></a>四、其他原因</h4><p>还有一些其他的情况可能会导致内存泄漏，比如缓存,队列消费不及时等。在使用缓存的时候，得清楚缓存的对象的多少，如果缓存对象非常多，得做限制最大缓存数量处理。还有就是非常占用CPU的代码也会导致内存泄漏，服务器在运行的时候，如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高。</p><h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p>文中的例子基本都可以很清楚的看出内存泄漏，但是在工作中，代码混合上业务以后就不一定能很清楚的看出内存泄漏了，还是得依靠工具来定位内存泄漏。另外下面是一些避免内存泄漏的方法。</p><ul><li><p>ESLint 检测代码检查非期望的全局变量。</p></li><li><p>使用闭包的时候，得知道闭包了什么对象，还有引用闭包的对象何时清除闭包。最好可以避免写出复杂的闭包，因为复杂的闭包引起的内存泄漏，如果没有打印内存快照的话，是很难看出来的。</p></li><li><p>绑定事件的时候，一定得在恰当的时候清除事件。在编写一个类的时候，推荐使用 init 函数对类的事件监听进行绑定和资源申请，然后 destroy 函数对事件和占用资源进行释放。</p></li></ul><h3 id="内存泄漏分析"><a href="#内存泄漏分析" class="headerlink" title="内存泄漏分析"></a>内存泄漏分析</h3><h4 id="查看V8内存使用情况-单位byte"><a href="#查看V8内存使用情况-单位byte" class="headerlink" title="查看V8内存使用情况(单位byte)"></a>查看V8内存使用情况(单位byte)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    <span class="selector-tag">process</span><span class="selector-class">.memoryUsage</span>();  </div><div class="line">    &#123;</div><div class="line">        <span class="attribute">ress</span>: <span class="number">47038464</span>,   </div><div class="line">        heapTotal: <span class="number">34264656</span>,   </div><div class="line">        heapUsed: <span class="number">2052866</span>   </div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="selector-tag">ress</span>：进程的常驻内存部分</div><div class="line"><span class="selector-tag">heapTotal</span>，<span class="selector-tag">heapUsed</span>：<span class="selector-tag">V8</span>堆内存信息</div></pre></td></tr></table></figure><h4 id="查看系统内存使用情况-单位byte"><a href="#查看系统内存使用情况-单位byte" class="headerlink" title="查看系统内存使用情况(单位byte)"></a>查看系统内存使用情况(单位byte)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">os</span><span class="selector-class">.totalmem</span>()</div><div class="line"><span class="selector-tag">os</span><span class="selector-class">.freemem</span>()</div><div class="line">返回系统总内存以及闲置内存</div></pre></td></tr></table></figure><h4 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">node</span> <span class="title">--trace_gc</span> -e <span class="string">"var a = []; for( var i = 0; i &lt; 1000000; i++ ) &#123; a.push(new Array(100)); &#125;"</span> &gt;&gt; gc.log  //输出垃圾回收日志</div><div class="line"></div><div class="line"><span class="keyword">node</span> <span class="title">--prof</span> </div><div class="line">//输出<span class="keyword">node</span><span class="title">执行时性能日志。 使用windows-tick</span>.processor查看。</div></pre></td></tr></table></figure><h4 id="分析监控工具"><a href="#分析监控工具" class="headerlink" title="分析监控工具"></a>分析监控工具</h4><ul><li>v8-profiler 对v8堆内存抓取快照和对cpu进行分析</li><li>node-heapdump 对v8堆内存抓取快照</li><li>node-mtrace 分析堆栈使用</li><li>node-memwatch 监听垃圾回收情况</li></ul><h5 id="node-memwatch"><a href="#node-memwatch" class="headerlink" title="node-memwatch"></a>node-memwatch</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">memwatch.on(<span class="string">'stats'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(info)</div><div class="line">&#125;)</div><div class="line">memwatch.on(<span class="string">'leak'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(info)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>stats事件:每次进行全堆垃圾回收时，将触发一次stats事件。这个事件将会传递内存统计信息。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"num_full_gc"</span>: <span class="number">17</span>, <span class="comment">//第几次全栈垃圾回收</span></div><div class="line">  <span class="string">"num_inc_gc"</span>: <span class="number">8</span>,   <span class="comment">//第几次增量垃圾回收</span></div><div class="line">  <span class="string">"heap_compactions"</span>: <span class="number">8</span>, <span class="comment">//第几次对老生代进行整理</span></div><div class="line">  <span class="string">"estimated_base"</span>: <span class="number">2592568</span>, <span class="comment">//预估基数</span></div><div class="line">  <span class="string">"current_base"</span>: <span class="number">2592568</span>,  <span class="comment">//当前基数</span></div><div class="line">  <span class="string">"min"</span>: <span class="number">2499912</span>, <span class="comment">//最小</span></div><div class="line">  <span class="string">"max"</span>: <span class="number">2592568</span>, <span class="comment">//最大 </span></div><div class="line">  <span class="string">"usage_trend"</span>: <span class="number">0</span> <span class="comment">//使用趋势</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">观察num_full_gc和num_inc_gc反映垃圾回收情况。</div></pre></td></tr></table></figure></p><p>leak事件：如果经过连续5次垃圾回收后，内存仍然没有被释放，意味着内存泄漏的发生。这个时候会触发一个leak事件。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  <span class="attribute">start</span>: Fri, <span class="number">29</span> Jun <span class="number">2012</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">13</span> GMT,</div><div class="line">  end: Fri, <span class="number">29</span> Jun <span class="number">2012</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">33</span> GMT,</div><div class="line">  growth: <span class="number">67984</span>,</div><div class="line">  reason: <span class="string">'heap growth over 5 consecutive GCs (20s) - 11.67 mb/hr'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Heap Diffing 堆内存比较 排查内存溢出代码。</p><h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>下面，我们通过一个例子来演示如何排查定位内存泄漏：<br>首先我们创建一个导致内存泄漏的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app.js</span></div><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</div><div class="line"><span class="keyword">var</span> heapdump = <span class="built_in">require</span>(<span class="string">'heapdump'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> leakobjs = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LeakClass</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'get /'</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</div><div class="line">      leakobjs.push(<span class="keyword">new</span> LeakClass());</div><div class="line">    &#125;</div><div class="line">    res.send(<span class="string">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  heapdump.writeSnapshot(<span class="string">'./'</span> + <span class="built_in">Date</span>.now() + <span class="string">'.heapsnapshot'</span>);</div><div class="line">&#125;, <span class="number">3000</span>);</div><div class="line"></div><div class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on port 3000'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>这里我们通过设置一个不断增加且不回被回收的数组，来模拟内存泄漏。</p><p>通过使用heap-dump模块来定时纪录内存快照，并通过chrome开发者工具profiles来导入快照，对比分析。</p><p>我们可以看到，在浏览器访问 localhost:3000, 并多次刷新后，快照的大小一直在增长，且即使不请求，也没有减小，说明已经发生了泄漏。 </p><p>接着我们通过过 chrome 开发者工具 profiles, 导入快照。通过设置 comparison，对比初始快照，发送请求，平稳，再发送请求这3个阶段的内存快照。可以发现右侧new中 LeakClass 一直增加。在delta中始终为正数，说明并没有被回收。</p><p>小结</p><p>针对内存泄漏可以采用植入 memwatch，或者定时上报 process.memoryUsage 内存使用率到 monitor，并设置告警阀值进行监控。<br>当发现内存泄漏问题时，若允许情况下，可以在本地运行 node-heapdump，使用定时生成内存快照。并把快照通过 chrome Profiles 分析泄漏原因。若无法本地调试，在测试服务器上使用 v8-profiler 输出内存快照比较分析json（需要代码侵入）。<br>需要考虑在什么情况下开启 memwatch/heapdump。考虑 heapdump 的频度以免耗尽了 CPU。 也可以考虑其他的方式来检测内存的增长，比如直接监控 process.memoryUsage()。<br>当心误判，短暂的内存使用峰值表现得很像是内存泄漏。如果你的app突然要占用大量的CPU和内存，处理时间可能会跨越数个垃圾回收周期，那样的话 memwatch 很有可能将之误判为内存泄漏。但是，这种情况下，一旦你的app使用完这些资源，内存消耗就会降回正常的水平。所以需要注意的是持续报告的内存泄漏，而可以忽略一两次突发的警报。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内存泄漏（Memory Leak）指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况&lt;/p&gt;
&lt;p&gt;Node.js 使用 V8 作为 JavaScript 的执行引擎，所以讨论 Node.js 的 GC 情况就等于在讨论 V8 的 GC。在 V8 中一个对象的内存是否
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="Node" scheme="https://bummingboy.top/tags/node/"/>
    
      <category term="内存" scheme="https://bummingboy.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS vs ES6 import/export</title>
    <link href="https://bummingboy.top/2018/01/05/commonjs%20vs%20ES6%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>https://bummingboy.top/2018/01/05/commonjs vs ES6模块机制/</id>
    <published>2018-01-05T08:59:56.000Z</published>
    <updated>2018-07-03T12:00:55.844Z</updated>
    
    <content type="html"><![CDATA[<p>js 几种流行的模块机制中, node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD, seajs 不了解不过多解释.<br><a id="more"></a><br>首先明确一下 </p><ul><li>import/export 对应ES6的模块机制 用法(<a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export</a>)或(<a href="http://es6.ruanyifeng.com/#docs/module-loader%23ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" title="http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82</a>)</li><li>require/module.exports()对应CommonJS的模块机制 用法(<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="external">http://javascript.ruanyifeng.com/nodejs/module.html</a>)</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 (因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。)</li></ul><h4 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h4><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。<br>    <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">id</span>: <span class="string">'...'</span>,</div><div class="line">  exports: &#123; ... &#125;,</div><div class="line">  <span class="selector-tag">loaded</span>: <span class="selector-tag">true</span>,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p><p>以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。<br>    delete require.cache[‘path/to/config’]<br>    config = require(‘path/to/config’))</p><h4 id="ES6加载原理"><a href="#ES6加载原理" class="headerlink" title="ES6加载原理"></a>ES6加载原理</h4><p>JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><h3 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h3><h4 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h4><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br>让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.done = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'在 a.js 之中，b.done = %j'</span>, b.done);</div><div class="line">exports.done = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.js 执行完毕'</span>);</div></pre></td></tr></table></figure></code></pre><p>上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。<br>再看b.js的代码。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.done = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'在 b.js 之中，a.done = %j'</span>, a.done);</div><div class="line">exports.done = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 执行完毕'</span>);</div></pre></td></tr></table></figure></code></pre><p>上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。<br>a.js已经执行的部分，只有一行。</p><pre><code><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exports.<span class="keyword">done</span> = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></code></pre><p>因此，对于b.js来说，它从a.js只输入一个变量done，值为false。<br>然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line"><span class="keyword">var</span> b =  <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'在 main.js 之中, a.done=%j, b.done=%j'</span>, a.done, b.done);</div></pre></td></tr></table></figure></code></pre><p>执行main.js，运行结果如下。</p><pre><code><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line"></div><div class="line">在 <span class="selector-tag">b</span><span class="selector-class">.js</span> 之中，<span class="selector-tag">a</span><span class="selector-class">.done</span> = false</div><div class="line"><span class="selector-tag">b</span><span class="selector-class">.js</span> 执行完毕</div><div class="line">在 <span class="selector-tag">a</span><span class="selector-class">.js</span> 之中，<span class="selector-tag">b</span><span class="selector-class">.done</span> = true</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.js</span> 执行完毕</div><div class="line">在 main<span class="selector-class">.js</span> 之中, <span class="selector-tag">a</span>.done=true, <span class="selector-tag">b</span>.done=true</div></pre></td></tr></table></figure></code></pre><p>上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。<br>    <figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exports.<span class="keyword">done</span> = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。<br>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>); <span class="comment">// 安全的写法</span></div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'a'</span>).foo; <span class="comment">// 危险的写法</span></div><div class="line"></div><div class="line">exports.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a.foo(<span class="string">'good'</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">exports.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> foo(<span class="string">'bad'</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><p>上面代码中，如果发生循环加载，require(‘a’).foo的值很可能后面会被改写，改用require(‘a’)会更保险一点。</p><h4 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h4><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。<br>请看下面这个例子。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(bar);</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="comment">// b.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(foo);</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">'bar'</span>;</div></pre></td></tr></table></figure></code></pre><p>上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。</p><pre><code><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node --experimental-modules <span class="selector-tag">a</span>.mjs</div><div class="line"><span class="selector-tag">b</span>.mjs</div><div class="line">ReferenceError: foo is not defined</div></pre></td></tr></table></figure></code></pre><p>上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？</p><p>让我们一行行来看，ES6循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.js。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。</p><p>解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(bar());</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'foo'</span> &#125;</div><div class="line"><span class="keyword">export</span> &#123;foo&#125;;</div><div class="line"></div><div class="line"><span class="comment">// b.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(foo());</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'bar'</span> &#125;</div><div class="line"><span class="keyword">export</span> &#123;bar&#125;;</div></pre></td></tr></table></figure></p><p>这时再执行a.mjs就可以得到预期结果。<br>    <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node --experimental-modules <span class="selector-tag">a</span>.mjs</div><div class="line"><span class="selector-tag">b</span>.mjs</div><div class="line">foo</div><div class="line"><span class="selector-tag">a</span>.mjs</div><div class="line">bar</div></pre></td></tr></table></figure></p><p>这是因为函数具有提升作用，在执行import {bar} from’./b’时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(bar());</div><div class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'foo'</span>;</div><div class="line"><span class="keyword">export</span> &#123;foo&#125;;</div></pre></td></tr></table></figure></p><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。<br>我们再来看 ES6 模块加载器SystemJS给出的一个例子。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。</p><p>运行上面这段代码，结果如下。<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> babel-node</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> import * as m from <span class="string">'./even.js'</span>;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.even(10);</span></div><div class="line">true</div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.counter</span></div><div class="line">6</div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.even(20)</span></div><div class="line">true</div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.counter</span></div><div class="line">17</div></pre></td></tr></table></figure></p><p>上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">exports.counter = counter;</div><div class="line">exports.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> node</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> var m = require(<span class="string">'./even'</span>);</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.even(10)</span></div><div class="line">TypeError: even is not a function</div></pre></td></tr></table></figure></p><h3 id="import-vs-require"><a href="#import-vs-require" class="headerlink" title="import  vs require()"></a>import  vs require()</h3><h4 id="遵循规范"><a href="#遵循规范" class="headerlink" title="遵循规范"></a>遵循规范</h4><pre><code>- require 是 AMD规范引入方式- import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</code></pre><h4 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h4><pre><code>- require是运行时调用，所以require理论上可以运用在代码的任何地方- import是编译时调用，所以必须放在文件开头</code></pre><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><pre><code>- require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量- import是解构过程，node v8引擎还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 几种流行的模块机制中, node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD, seajs 不了解不过多解释.&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="CommonJS" scheme="https://bummingboy.top/tags/commonjs/"/>
    
      <category term="ES6" scheme="https://bummingboy.top/tags/es6/"/>
    
      <category term="import/export" scheme="https://bummingboy.top/tags/import-export/"/>
    
  </entry>
  
  <entry>
    <title>Mongodb 更换数据目录</title>
    <link href="https://bummingboy.top/2017/12/19/Mongodb%20%E6%9B%B4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
    <id>https://bummingboy.top/2017/12/19/Mongodb 更换数据目录/</id>
    <published>2017-12-19T10:11:04.000Z</published>
    <updated>2018-07-03T10:26:18.138Z</updated>
    
    <content type="html"><![CDATA[<p>这不是数据迁移, 迁移的话通常用mongodump, 另说.<br>本篇是因为服务器主分区只有20G, 数据库文件数据量大了, 主分区不够了需要迁移到新挂载的数据盘.挂载的知识请看().<br>下面是思路:</p><ol><li>查看MongoDB的状态, 终止数据库运行</li><li>查看数据库数据, 日志路径</li><li>压缩备份, 拷贝到新目录</li><li>重启</li></ol><h3 id="1-查看MongoDB状态"><a href="#1-查看MongoDB状态" class="headerlink" title="1.查看MongoDB状态"></a>1.查看MongoDB状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mongo</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure><p>连接成功则表示mongod已经运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$<span class="built_in"> service </span>mongod status </div><div class="line">&gt; stop/waiting 表示不是通过service运行的</div><div class="line">&gt; start/running 表示通过service运行的</div><div class="line"></div><div class="line">$<span class="built_in"> service </span>mongod stop 停止</div><div class="line">$<span class="built_in"> service </span>mongod start/restart 重启</div><div class="line"><span class="keyword">or</span></div><div class="line">$ ps -aux | grep mongo</div><div class="line">&gt;root      7695  0.3 13.5 29712004 1109256 ?    Sl   Dec14   2:37 mongod --fork --logpath /var/log/mongodb/mongodb.log --dbpath /var/lib/mongodb</div><div class="line"> ubuntu   24526  0.0  0.0  10468  2232 pts/1    R+   10:43   0:00 grep <span class="attribute">--color</span>=auto mongo</div><div class="line">表示mongod服务是通过--fork 形式手动启动的</div><div class="line"></div><div class="line">$ kill PID(7695) 终止服务</div></pre></td></tr></table></figure><h3 id="2-查看数据库数据-日志路径"><a href="#2-查看数据库数据-日志路径" class="headerlink" title="2.查看数据库数据, 日志路径"></a>2.查看数据库数据, 日志路径</h3><ul><li><p>service 启动的mongod服务<br>此时通过/etc/init.d/mongodb启动服务, 默认使用/etc/mongod.conf配置文件</p></li><li><p>mongod –fork 启动mongod服务<br>默认也会使用/etc/mongod.conf配置文件, 但是当指定dbpath logpath后以指定为准</p><p>mongod.conf文件</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="symbol">storage:</span></div><div class="line"><span class="symbol">dbPath:</span> /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span></span></div><div class="line"><span class="symbol">journal:</span></div><div class="line">  <span class="symbol">enabled:</span> <span class="literal">true</span></div><div class="line">...</div><div class="line"><span class="symbol">systemLog:</span></div><div class="line"><span class="symbol">destination:</span> file</div><div class="line"><span class="symbol">logAppend:</span> <span class="literal">true</span></div><div class="line"><span class="symbol">path:</span> /var/log/mongodb/mongod.log</div></pre></td></tr></table></figure></li></ul><p>  修改对应路径:<br>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="string">storage:</span></div><div class="line"><span class="string">dbPath:</span> <span class="regexp">/data/</span>db/mongodb</div><div class="line"><span class="string">journal:</span></div><div class="line"><span class="symbol">  enabled:</span> <span class="literal">true</span></div><div class="line">...</div><div class="line"><span class="string">systemLog:</span></div><div class="line"><span class="string">destination:</span> file</div><div class="line"><span class="string">logAppend:</span> <span class="literal">true</span></div><div class="line"><span class="string">path:</span> <span class="regexp">/data/</span>db<span class="regexp">/log/</span>mongod.log</div></pre></td></tr></table></figure></p><p>  本例中前人通过指定logpath dbpath的方式启动服务</p><h3 id="3-压缩备份-拷贝到新目录"><a href="#3-压缩备份-拷贝到新目录" class="headerlink" title="3.压缩备份, 拷贝到新目录"></a>3.压缩备份, 拷贝到新目录</h3><p>  知道了原来的数据和日志位置, 那么可以压缩备份原来的数据了, 本例以/data/db/mongodb为新的数据目录<br>  /data/db/log为新的日志目录</p>  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd /var/<span class="class"><span class="keyword">lib</span></span></div><div class="line">$ tar -zcvf mongodb_backup_xxxxxx.tar.gz /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span></span></div><div class="line">$ cp -ra /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span> /<span class="title">data</span>/<span class="title">db</span>/<span class="title">mongodb</span></span></div><div class="line">$ rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span></span></div></pre></td></tr></table></figure><h3 id="4-重启mongod服务"><a href="#4-重启mongod服务" class="headerlink" title="4.重启mongod服务"></a>4.重启mongod服务</h3>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo<span class="built_in"> service </span>mongod start</div></pre></td></tr></table></figure><p>  or<br>  <figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mongod --dbpath /<span class="keyword">data</span>/db/mongodb --logpath /<span class="keyword">data</span>/db/<span class="built_in">log</span>/mongod.<span class="built_in">log</span></div></pre></td></tr></table></figure></p><h3 id="问题-启动失败"><a href="#问题-启动失败" class="headerlink" title="问题: 启动失败"></a>问题: 启动失败</h3><ul><li><p>查看新数据目录权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /data/db</span></div><div class="line"><span class="meta">$</span><span class="bash"> ll</span></div></pre></td></tr></table></figure><p>直接拷贝 已经是mongodb:mongodb 用户组了</p></li><li><p>查看日志 访问mongodb-27017.sock 无权限</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="params">...</span></div><div class="line">Failed <span class="keyword">to</span> unlink socket file /tmp/mongodb<span class="number">-27017.</span>sock errno:<span class="number">1</span> Operation <span class="literal">not</span> permitted</div><div class="line"><span class="params">...</span></div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></div><div class="line"><span class="meta">$</span><span class="bash"> ll</span></div><div class="line"><span class="meta">$</span><span class="bash"> rm -rf mongodb-27017.sock</span></div></pre></td></tr></table></figure><p>重新启动<br>重新查看 mongodb-27017.sock 文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">ls</span> - lat <span class="string">/tmp/mongodb-27017.sock</span></div><div class="line">&gt;</div><div class="line">srwx<span class="params">------</span> 1 mongodb mongodb 0 Dec 14 21<span class="function">:12</span> <span class="string">/tmp/mongodb-27017.sock</span></div></pre></td></tr></table></figure></li></ul><p>  注: 启动相关日志  还是在/var/log/mongodb</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这不是数据迁移, 迁移的话通常用mongodump, 另说.&lt;br&gt;本篇是因为服务器主分区只有20G, 数据库文件数据量大了, 主分区不够了需要迁移到新挂载的数据盘.挂载的知识请看().&lt;br&gt;下面是思路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看MongoDB的状态, 终止数据库运
      
    
    </summary>
    
      <category term="数据库" scheme="https://bummingboy.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="https://bummingboy.top/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>npm私有仓库搭建及使用 (verdaccio)</title>
    <link href="https://bummingboy.top/2017/12/19/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%20(verdaccio)/"/>
    <id>https://bummingboy.top/2017/12/19/npm私有仓库搭建及使用 (verdaccio)/</id>
    <published>2017-12-19T10:10:56.000Z</published>
    <updated>2018-07-03T10:26:34.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载及搭建"><a href="#下载及搭建" class="headerlink" title="下载及搭建"></a>下载及搭建</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="bullet">-g</span> <span class="string">verdaccio</span></div><div class="line"><span class="string">$</span> <span class="string">verdaccio</span></div><div class="line">  <span class="string">warn</span> <span class="meta">---</span> <span class="string">config</span> <span class="string">file</span>  <span class="bullet">-</span> <span class="string">/home/ubuntu/.config/verdaccio/config.yaml</span></div><div class="line">  <span class="string">warn</span> <span class="meta">---</span> <span class="string">http</span> <span class="string">address</span> <span class="bullet">-</span> <span class="attr">http://localhost:4873/</span> <span class="bullet">-</span> <span class="string">verdaccio/2.3.2</span></div></pre></td></tr></table></figure><p>终端显示默认配置文件和verdaccio工作端口, 浏览器打开<a href="http://localhost:4873/" target="_blank" rel="external">http://localhost:4873/</a> ，页面如下<br><img src="/images/A66C4A708AB44ED80A1D2650F6217313.jpg" alt=""></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>  default config:<br>    <figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="attr">storage:</span> <span class="string">./storage</span>      <span class="comment"># 设置托管或缓存包的存放目录</span></div><div class="line"><span class="attr">auth:</span>                   <span class="comment"># 权限控制</span></div><div class="line"><span class="attr">  htpasswd:</span>             <span class="comment"># 启用 htpasswd 插件管理权限</span></div><div class="line"><span class="attr">    file:</span> <span class="string">./htpasswd</span>    <span class="comment"># 制定 htpasswd 文件路径，htpasswd 中存储者用户名和加密过的秘钥</span></div><div class="line"><span class="attr">    max_users:</span> <span class="number">1000</span>     <span class="comment"># 最多允许注册用户数</span></div><div class="line"><span class="attr">uplinks:</span>                <span class="comment"># 设置外部仓储，如果 verdaccio 找不到请求的包（非 verdaccio 托管），就会查找外部仓储</span></div><div class="line"><span class="attr">  npmjs:</span></div><div class="line"><span class="attr">    url:</span> <span class="attr">https://registry.npmjs.org/</span></div><div class="line"><span class="attr">packages:</span></div><div class="line">  <span class="string">'@*/*'</span><span class="string">:</span></div><div class="line"><span class="attr">    access:</span> <span class="string">$all</span></div><div class="line"><span class="attr">    publish:</span> <span class="string">$authenticated</span></div><div class="line"><span class="attr">    proxy:</span> <span class="string">npmjs</span></div><div class="line">  <span class="string">'**'</span><span class="string">:</span></div><div class="line"><span class="attr">    proxy:</span> <span class="string">npmjs</span></div><div class="line"><span class="attr">logs:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">&#123;type:</span> <span class="string">stdout,</span> <span class="attr">format:</span> <span class="string">pretty,</span> <span class="attr">level:</span> <span class="string">http&#125;</span></div><div class="line"><span class="attr">web:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  title:</span> <span class="string">Verdaccio</span></div><div class="line"><span class="attr">  logo:</span> <span class="string">logo.png</span></div><div class="line"><span class="attr">publish:</span></div><div class="line"><span class="attr">  allow_offline:</span> <span class="literal">false</span>    <span class="comment"># 是否支持离线发布 默认false</span></div><div class="line"><span class="attr">url_prefix:</span> <span class="attr">https://dev.company.local/verdaccio/</span> </div><div class="line"><span class="comment"># 设置资源文件路径前缀。默认不需要设置，但如果使用 nginx 代理并改写了请求路径，就需要指定了。</span></div><div class="line"><span class="attr">max_body_size:</span> <span class="number">1</span><span class="string">mb</span>        <span class="comment"># 默认JSON document size 1mb</span></div><div class="line"><span class="attr">listen:</span>                   <span class="comment"># 设置服务运行地址端口</span></div><div class="line"><span class="comment"># - localhost:4873            # default value</span></div><div class="line"><span class="comment"># - http://localhost:4873     # same thing</span></div><div class="line"><span class="comment"># - 0.0.0.0:4873              # listen on all addresses (INADDR_ANY)</span></div><div class="line"><span class="comment"># - https://example.org:4873  # if you want to use https</span></div><div class="line"><span class="comment"># - [::1]:4873                # ipv6</span></div><div class="line"><span class="comment"># - unix:/tmp/verdaccio.sock    # unix socket</span></div></pre></td></tr></table></figure></p><ul><li>uplinks常用仓储有<pre><code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">npmjs:</span></div><div class="line"><span class="string">url:</span> <span class="string">https:</span><span class="comment">//registry.npmjs.org</span></div><div class="line"><span class="string">yarnjs:</span></div><div class="line"><span class="string">url:</span> <span class="string">https:</span><span class="comment">//registry.yarnpkg.com</span></div><div class="line"><span class="string">cnpmjs:</span></div><div class="line"><span class="string">url:</span> <span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></div></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>packages: 包访问或发布控制</p><ul><li><p>{regexp}: 包名匹配正则。<br>access: 访问控制，可选值有$all（用户不限制）, $anonymous（用户不限制）, $authenticated（所有登录用户）, username( 用户名，需指定具体用户，可指定多个用户，用户间空格隔开，如 secret super-secret-area ultra-secret-area)。尽管@all, @anonymous, all, undefined,<br>publish: 发布控制，配置请参考 access<br>proxy: 代理控制，设置的值必选现在 uplinks 中定义。</p></li><li><p>常用的包名正则有：</p>   <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">*</span><span class="symbol">*</span>         <span class="comment"># 匹配任意包</span></div><div class="line"><span class="meta">@*/*</span>       <span class="comment"># 匹配任意 scope 包</span></div><div class="line"><span class="meta">@npmuser/*</span> <span class="comment"># 匹配 scope 为 npmuser 的包</span></div><div class="line">npmuser-<span class="symbol">*</span>  <span class="comment"># 匹配包名有 npmuser- 前缀的包</span></div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>包名正则规范通 gitignore 一致，verdaccio 内部使用minimatch实现的，如果需要书写更复杂的正则，可以参考 minimatch 文档。</code></pre><p>详情(<a href="https://github.com/verdaccio/verdaccio/blob/master/wiki/config.md" target="_blank" rel="external">https://github.com/verdaccio/verdaccio/blob/master/wiki/config.md</a>)</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> yarn/npm init</span></div><div class="line">... input some info</div></pre></td></tr></table></figure><h4 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h4><h4 id="注册仓库并添加用户"><a href="#注册仓库并添加用户" class="headerlink" title="注册仓库并添加用户"></a>注册仓库并添加用户</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">set</span> registry <span class="comment">ip</span>/hostname</div><div class="line">npm adduser --registry ip/<span class="comment">hostname</span></div><div class="line">input: username/password/email</div></pre></td></tr></table></figure><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> yarn/npm pulish</span></div><div class="line">... input some info</div></pre></td></tr></table></figure><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ yarn add package-name / npm <span class="keyword">install</span> <span class="keyword">package</span>-<span class="keyword">name</span></div><div class="line"><span class="keyword">or</span></div><div class="line">$ yarn / npm logout</div><div class="line">$ (yarn <span class="keyword">add</span> <span class="keyword">package</span>-<span class="keyword">name</span> / npm <span class="keyword">install</span> <span class="keyword">package</span>-<span class="keyword">name</span>) <span class="comment">--registry http://localhost:4873</span></div></pre></td></tr></table></figure><h3 id="私有包"><a href="#私有包" class="headerlink" title="私有包"></a>私有包</h3><p>现在配置org-前缀的包全部私有</p><p>只需在配置文件 config.yml 中 package 段添加配置</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'org-*'</span>:</div><div class="line">  access: $authenticated</div><div class="line">  publish: $authenticated</div><div class="line">  proxy: npmjs</div></pre></td></tr></table></figure><p>这里我们配置了所有org-前缀的包只有注册用户才能访问和发布。</p><p>你也可以对 publish 做进一步限制，只有 npmuser 用户才能发布<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'org-*'</span><span class="string">:</span></div><div class="line"><span class="attr">  access:</span> <span class="string">$authenticated</span></div><div class="line"><span class="attr">  publish:</span> <span class="string">npmuser</span></div><div class="line"><span class="attr">  proxy:</span> <span class="string">npmjs</span></div></pre></td></tr></table></figure></p><p>注意修改配置后要重启 verdaccio</p><h3 id="scope-包"><a href="#scope-包" class="headerlink" title="scope 包"></a>scope 包</h3><p>其实加前缀并不是一种很好组织包的方式，npm 提供了更好的名称空间策略 scope</p><p>scope 包包名格式：@scope-name/pkg-name</p><p>初始化包时指定 scope<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init <span class="comment">--scope org</span></div></pre></td></tr></table></figure></p><p>我们可以为 scope 绑定一个仓储<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm login --registry=http://<span class="keyword">reg</span>.example.<span class="keyword">com</span> --scope=@org</div><div class="line">npm config <span class="keyword">set</span> @or<span class="variable">g:registry</span> http://<span class="keyword">reg</span>.example.<span class="keyword">com</span></div></pre></td></tr></table></figure></p><p>这样凡是碰到 scope 为 @org 的包，npm 将自动切换作业仓储到 scope 绑定的仓储，这提供了一种多仓储策略。</p><p>scope 私有包配置<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'@org/*'</span>:</div><div class="line">  access: $authenticated</div><div class="line">  publish: $authenticated</div><div class="line">  proxy: npmjs</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载及搭建&quot;&gt;&lt;a href=&quot;#下载及搭建&quot; class=&quot;headerlink&quot; title=&quot;下载及搭建&quot;&gt;&lt;/a&gt;下载及搭建&lt;/h3&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="npm" scheme="https://bummingboy.top/tags/npm/"/>
    
      <category term="私有仓库" scheme="https://bummingboy.top/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux 修改系统时间的三种方法</title>
    <link href="https://bummingboy.top/2017/12/19/Linux%20%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://bummingboy.top/2017/12/19/Linux 修改系统时间的三种方法/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T10:26:11.609Z</updated>
    
    <content type="html"><![CDATA[<p>三种方法:</p><p>一、修改时区<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cp /etc/localtime /etc/localtime.bak</span></div><div class="line"><span class="comment"># ln -svf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></div><div class="line">修改为中国的东八区</div><div class="line"></div><div class="line"><span class="comment"># cat /etc/sysconfig/clock</span></div><div class="line">ZONE=<span class="string">"Asia/Shanghai"</span></div><div class="line">UTC=false</div><div class="line">ARC=false</div><div class="line"></div><div class="line"><span class="comment"># 与时间服务器同步</span></div><div class="line">ntpdate 0.centos.pool.ntp.org</div></pre></td></tr></table></figure></p><p>二、配置新的时间<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">日期设定：</div><div class="line"><span class="meta">#</span><span class="bash"> date -s 2013/09/26</span></div><div class="line"></div><div class="line">时间设定：</div><div class="line"><span class="meta">#</span><span class="bash"> date -s 11:47:06</span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"12:00:00 2013-12-06"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"12:00:00 20131206"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"2013-12-06 12:00:00"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"20131206 12:00:00"</span></span></div><div class="line"></div><div class="line">date 是显示的系统OS时间</div><div class="line">clock 是显示Bios的时间</div><div class="line">查看硬件时间（BIOS的）：</div><div class="line">hwclock [-rw]   </div><div class="line">  -r   查看现有BIOS时间，默认为－r参数</div><div class="line">  -w   将现在的linux系统时间写入BIOS中</div><div class="line">  -s   (systohc)将硬件时间调整为和目前的系统时间一样</div><div class="line"><span class="meta">#</span><span class="bash"> hwclock -s </span></div><div class="line"><span class="meta">#</span><span class="bash"> hwclock -w</span></div><div class="line"> 当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> hwclock</span></div><div class="line">2013年09月26日 星期四 11时49分10秒 -1.002805 seconds</div><div class="line">修改系统时间（date）后，要同步BIOS时钟，强制把系统时间写入CMOS：</div><div class="line"><span class="meta">#</span><span class="bash"> clock -w </span></div><div class="line">或者</div><div class="line"><span class="meta">#</span><span class="bash"> hwclock -w</span></div></pre></td></tr></table></figure></p><p>三、实现Internet时间同步（这里可以忽略上面两步）<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">方法<span class="number">1.</span> 开机的时候自动网络校时(首先有自己的时间服务器)： </div><div class="line"># cat /etc/rc.d/rc.local </div><div class="line">/usr/sbin/ntpdate -u <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span>;/sbin/hwclock -w</div><div class="line">后面的ip对应的是局域网内需要时间相同同步的主机。</div><div class="line"></div><div class="line">方法<span class="number">2.</span> 设定计划任务</div><div class="line"># yum -y install ntpdate # 安装时间同步命令</div><div class="line"># crontab -l(以下方法任选其一)</div><div class="line">*/<span class="number">5</span> * * * * root ntpdate <span class="number">210.72</span><span class="number">.145</span><span class="number">.44</span>;hwclock -w #每隔半个小时与中国国家授时中心服务器同步一次时间</div><div class="line">*/<span class="number">5</span> * * * * root ntpdate asia.pool.ntp.org;hwclock -w</div><div class="line">*/<span class="number">5</span> * * * * root ntpdate <span class="number">0.</span>centos.pool.ntp.org;hwclock -w</div><div class="line"></div><div class="line">手动和时间服务器校准时间：</div><div class="line"><span class="number">1.</span>首先关闭ntpd服务：</div><div class="line"># service ntpd stop</div><div class="line"></div><div class="line"><span class="number">2.</span>然后和时间服务器校准：</div><div class="line"># ntpdate asia.pool.ntp.org</div><div class="line"></div><div class="line"><span class="number">3.</span>同步BIOS时间：</div><div class="line"># hwclock -w</div><div class="line"></div><div class="line"><span class="number">4.</span>校准后然后开启ntpd服务</div><div class="line"># service ntpd start</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三种方法:&lt;/p&gt;
&lt;p&gt;一、修改时区&lt;br&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://bummingboy.top/tags/linux/"/>
    
      <category term="系统时间" scheme="https://bummingboy.top/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>firewall 使用</title>
    <link href="https://bummingboy.top/2017/12/19/firewall%20%E4%BD%BF%E7%94%A8/"/>
    <id>https://bummingboy.top/2017/12/19/firewall 使用/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T10:25:13.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h3><h4 id="运行、停止、禁用firewalld-状态"><a href="#运行、停止、禁用firewalld-状态" class="headerlink" title="运行、停止、禁用firewalld 状态"></a>运行、停止、禁用firewalld 状态</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">启动：<span class="keyword"> system</span>ctl start firewalld</div><div class="line">查看状态：<span class="keyword"> system</span>ctl status firewalld </div><div class="line">停止：<span class="keyword"> system</span>ctl disable firewalld</div><div class="line">禁用：<span class="keyword"> system</span>ctl stop firewalld</div></pre></td></tr></table></figure><h4 id="查看firewall是否运行"><a href="#查看firewall是否运行" class="headerlink" title="查看firewall是否运行"></a>查看firewall是否运行</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">下面两个命令都可以</div><div class="line">systemctl status firewalld.service</div><div class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --state</span></div></pre></td></tr></table></figure><h3 id="2-服务管理"><a href="#2-服务管理" class="headerlink" title="2. 服务管理"></a>2. 服务管理</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">启动一个服务：<span class="string">systemctl </span><span class="string">start </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">关</span>闭一个服务：<span class="string">systemctl </span><span class="string">stop </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">重</span>启一个服务：<span class="string">systemctl </span><span class="string">restart </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">显</span>示一个服务的状态：<span class="string">systemctl </span><span class="string">status </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">在</span>开机时启用一个服务：<span class="string">systemctl </span><span class="string">enable </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">在</span>开机时禁用一个服务：<span class="string">systemctl </span><span class="string">disable </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">查</span>看服务是否开机启动：<span class="string">systemctl </span><span class="string">is-enabled </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">查</span>看已启动的服务列表：<span class="string">systemctl </span><span class="built_in">list-unit-files|grep</span> <span class="string">enabled</span></div><div class="line"><span class="string">查</span>看启动失败的服务列表：<span class="string">systemctl </span><span class="built_in">--failed</span></div></pre></td></tr></table></figure><h4 id="添加一个服务到firewalld"><a href="#添加一个服务到firewalld" class="headerlink" title="添加一个服务到firewalld"></a>添加一个服务到firewalld</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --add-service=http //http换成想要开放的service</span></div><div class="line"><span class="bash">这样添加的service当前立刻生效，但系统下次启动就失效，可以测试使用。要永久开发一个service，加上 --permanent</span></div><div class="line"><span class="bash"></span></div><div class="line"><span class="bash">firewall-cmd --permanent --add-service=http</span></div></pre></td></tr></table></figure><p>如果要添加的端口并没有服务对应<br>就要新建一个服务，在/usr/lib/firewalld/services，随便拷贝一个xml文件到一个新名字，比如myservice.xml,把里面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">short</span>&gt;</span>Transmission-client<span class="tag">&lt;/<span class="name">short</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Transmission is a lightweight GTK+ BitTorrent client.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">"tcp"</span> <span class="attr">port</span>=<span class="string">"51413"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure><p>short改为想要名字（这个名字只是为了人来阅读，没有实际影响。重要的是修改 protocol和port。修改完保存。我的经验是这是要重启firewalld服务，systemctl restart firewalld.service，否则可能提示找不到刚才新建的service。然后把新建的service添加到<br>firewalld<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --permanent --add-service=myservice</span></div><div class="line"><span class="bash">重启firewalld 生效</span></div></pre></td></tr></table></figure></p><h3 id="3-配置firewalld-cmd"><a href="#3-配置firewalld-cmd" class="headerlink" title="3. 配置firewalld-cmd"></a>3. 配置firewalld-cmd</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">查看版本： firewall-<span class="keyword">cmd</span><span class="bash"> --version</span></div><div class="line"><span class="bash">查看帮助： firewall-cmd --<span class="built_in">help</span></span></div><div class="line"><span class="bash">显示状态： firewall-cmd --state</span></div><div class="line"><span class="bash">查看所有打开的端口： firewall-cmd --zone=public --list-ports</span></div><div class="line"><span class="bash">更新防火墙规则： firewall-cmd --reload</span></div><div class="line"><span class="bash">查看区域信息:  firewall-cmd --get-active-zones</span></div><div class="line"><span class="bash">查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0</span></div><div class="line"><span class="bash">拒绝所有包：firewall-cmd --panic-on</span></div><div class="line"><span class="bash">取消拒绝状态： firewall-cmd --panic-off</span></div><div class="line"><span class="bash">查看是否拒绝： firewall-cmd --query-panic</span></div><div class="line"><span class="bash"> </span></div><div class="line"><span class="bash">那怎么开启一个端口呢</span></div><div class="line"><span class="bash">添加</span></div><div class="line"><span class="bash">firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）</span></div><div class="line"><span class="bash">重新载入</span></div><div class="line"><span class="bash">firewall-cmd --reload</span></div><div class="line"><span class="bash">查看</span></div><div class="line"><span class="bash">firewall-cmd --zone= public --query-port=80/tcp</span></div><div class="line"><span class="bash">删除</span></div><div class="line"><span class="bash">firewall-cmd --zone= public --remove-port=80/tcp --permanent</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础使用&quot;&gt;&lt;a href=&quot;#1-基础使用&quot; class=&quot;headerlink&quot; title=&quot;1. 基础使用&quot;&gt;&lt;/a&gt;1. 基础使用&lt;/h3&gt;&lt;h4 id=&quot;运行、停止、禁用firewalld-状态&quot;&gt;&lt;a href=&quot;#运行、停止、禁用firewal
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="firewall" scheme="https://bummingboy.top/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 安装shadowsocks</title>
    <link href="https://bummingboy.top/2017/12/19/Centos%207%20shadowsocks/"/>
    <id>https://bummingboy.top/2017/12/19/Centos 7 shadowsocks/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-06T08:09:47.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="install-shadowsocks"><a href="#install-shadowsocks" class="headerlink" title="install shadowsocks"></a>install shadowsocks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install shadowsocks</span></div></pre></td></tr></table></figure><h3 id="config-shadowsocks"><a href="#config-shadowsocks" class="headerlink" title="config shadowsocks"></a>config shadowsocks</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd /etc</div><div class="line"><span class="variable">$ </span>mkdir shadowsocks</div><div class="line"><span class="variable">$ </span>cd shadowsocks</div><div class="line"><span class="variable">$ </span>vi config.json</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="string">"server"</span><span class="symbol">:<span class="string">"你的 ShadowSocks 服务器IP"</span></span>,</div><div class="line">    <span class="string">"server_port"</span><span class="symbol">:</span>服务器端口,</div><div class="line">    <span class="string">"local_port"</span><span class="symbol">:</span>本地端口,</div><div class="line">    <span class="string">"password"</span><span class="symbol">:<span class="string">"ShadowSocks 密码"</span></span>,</div><div class="line">    <span class="string">"timeout"</span><span class="symbol">:</span><span class="number">600</span>,</div><div class="line">    <span class="string">"method"</span><span class="symbol">:<span class="string">"aes-256-cfb"</span></span></div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2 id="run-shadowsocks"><a href="#run-shadowsocks" class="headerlink" title="run shadowsocks"></a>run shadowsocks</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sslocal -c /etc/shadowsocks/config.json</span></div><div class="line"><span class="meta">#</span><span class="bash"> 如果已经在config.json 所在路径下, 可直接执行 sslocal</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 如果想在后台一直运行shadowsocks </span></div><div class="line"><span class="meta">$</span><span class="bash"> nohup sslocal -c /etc/shadowsocks/config.json /dev/null 2&gt;&amp;1 &amp;</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 关闭shadowsocks </span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -9 pid</span></div></pre></td></tr></table></figure><h3 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h3><p>Shadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。</p><h3 id="install-privoxy"><a href="#install-privoxy" class="headerlink" title="install privoxy"></a>install privoxy</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz</span></div><div class="line"><span class="meta">$</span><span class="bash"> tar -zxvf privoxy-3.0.26-stable-src.tar.gz</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> privoxy-3.0.26-stable</span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> autuheader &amp;&amp; autoconf <span class="comment"># 如果没有安装autoconf $ yum install -y autoconf</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> ./configure</span></div><div class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></div></pre></td></tr></table></figure><h3 id="configure-privoxy"><a href="#configure-privoxy" class="headerlink" title="configure privoxy"></a>configure privoxy</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /usr/local/etc/privoxy/config</div><div class="line">$ listen-address 127.0.0.1:8118 #8118 是默认端口, 不用更改, 下面会用到</div><div class="line">$ forward-socks5t / 127.0.0.1:localport # localport 是shadowsocks/config.json 中的本地端口</div></pre></td></tr></table></figure><h3 id="run-privoxy"><a href="#run-privoxy" class="headerlink" title="run privoxy"></a>run privoxy</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> useradd privoxy</span></div><div class="line"><span class="meta">$</span><span class="bash"> privoxy --user privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config</span></div></pre></td></tr></table></figure><h3 id="configure-profile"><a href="#configure-profile" class="headerlink" title="configure profile"></a>configure profile</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /etc/profile</div><div class="line">  </div><div class="line">  <span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=http://127.0.0.1:8118</div><div class="line">  <span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=http://127.0.0.1:8118</div><div class="line">  </div><div class="line">$ source /etc/profile</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      shadowsocks config
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
      <category term="Centos 7" scheme="https://bummingboy.top/categories/linux/centos-7/"/>
    
    
      <category term="Centos7" scheme="https://bummingboy.top/tags/centos7/"/>
    
      <category term="Linux" scheme="https://bummingboy.top/tags/linux/"/>
    
      <category term="shadowsocks" scheme="https://bummingboy.top/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置</title>
    <link href="https://bummingboy.top/2017/12/19/Nginx%20%E9%85%8D%E7%BD%AE/"/>
    <id>https://bummingboy.top/2017/12/19/Nginx 配置/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T10:26:26.784Z</updated>
    
    <content type="html"><![CDATA[<p>如果是使用apt-get安装的nginx,配置文件目录在:<br>  /etc/nginx/<br>cd到这个目录之后,ls查看所有文件:</p><ul><li><p>nginx.conf<br>  这个是nginx的主配置文件,里面包含了当前目录的所有配置文件,<br>只不过有的是注释状态,需要的时候自行开启(后面几个常用的)</p></li><li><p>conf.d<br>这是一个目录,里面可以写我们自己自定义的配置文件,文件结尾一<br>定是.conf才可以生效(当然也可以通过修改nginx.conf来取消这个限制)</p></li><li><p>sites-enabled<br>这里面的配置文件其实就是sites-available里面的配置文件的软<br>连接,但是由于nginx.conf默认包含的是这个文件夹,所以我们在<br>sites-available里面建立了新的站点之后,还要建立个软连接到sites-enabled里面才行</p></li><li><p>sites-available<br>这里是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机</p></li></ul><h3 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h3><p>Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.<br>为什么要配置多站点:</p><p>当我们有了一个服务器之后,为了不浪费服务器的资源,我们可以在一个服务器上放置多个网站项目,它们共同使用80端口,通过不同的servername来区分不同的网站项目,在实际上线的项目中,这个servername就是我们的域名啦<br>具体配置(我们只举例一个,多个重复操作就行):</p><p>默认已经有一个站点了,就是defalt,在sites-available里面有一个default文件,就是默认站点的配置,servername是localhost不建议直接修改这个默认站点,我们可以复制一个:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> airobot &#123;</div><div class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:3001</span>;</div><div class="line">    <span class="attribute">keepalive</span> <span class="number">64</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="comment">#listen 80;</span></div><div class="line">    <span class="attribute">listen</span> <span class="number">443</span>;</div><div class="line">    <span class="attribute">server_name</span> <span class="regexp">*.ai-robotics.cn</span>;</div><div class="line">    <span class="comment">#ai-robotics.cn www.ai-robotics.cn;</span></div><div class="line">    <span class="comment">#access_log /usr/local/log/test.log;</span></div><div class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/1_www.ai-robotics.cn_bundle.crt;</div><div class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/2_www.ai-robotics.cn.key;</div><div class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</div><div class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</div><div class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</div><div class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;    </div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="number">443</span>;</div><div class="line">          <span class="attribute">proxy_set_header</span> Host  <span class="variable">$http_host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Nginx-Proxy <span class="literal">true</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</div><div class="line">        <span class="attribute">proxy_pass</span>      https://airobot;</div><div class="line">          <span class="attribute">client_max_body_size</span> <span class="number">128M</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ln -s <span class="regexp">/etc/</span>ngix<span class="regexp">/sites-available/</span>web1.com <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>web1.com</div><div class="line">$ nginx -s reload</div></pre></td></tr></table></figure><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li>正向代理:</li></ul><p>正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>主要为了越过局域网内的防火墙实现访问网站</p><ul><li>反向代理:</li></ul><p>反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。为了将防火墙后面的服务器提供给Internet用户访问也可以实现负载均衡,动静分离,url策略</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>前期准备:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx服务器 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></div><div class="line">web服务器<span class="number">1</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></div><div class="line">web服务器<span class="number">2</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span></div></pre></td></tr></table></figure></p><p>修改配置文件:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span><span class="keyword">default</span></div></pre></td></tr></table></figure></p><p>这样配置:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">upstream a.com &#123;</div><div class="line">  server  <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>:<span class="number">80</span>;  <span class="comment">#有多少个服务器就添加多少个ip</span></div><div class="line">  server  <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span>:<span class="number">80</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server&#123;</div><div class="line">    listen <span class="number">80</span>;</div><div class="line">    server_name a.com;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass         http:<span class="comment">//a.com;   #这个地址一定是上面定义的负载均衡的名字</span></div><div class="line">        proxy_set_header   Host             $host;</div><div class="line">        proxy_set_header   X-Real-IP        $remote_addr;</div><div class="line">        proxy_set_header   X-Forwarded-<span class="keyword">For</span>  $proxy_add_x_forwarded_for;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ps:nginx主服务器也可以当做一个负载均衡服务器,但是由于80端口已经给负载均衡食用了,所有如果我们还使用80端口的话,就会造成一个死循环,我们可以再给主服务器添加一个服务器,并使用不同的8080端口,这样,主服务器也可以当做一个负载均衡的子服务器了,不会造成资源的浪费:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">    listen 8080;</div><div class="line">    server_name a.com;</div><div class="line">    index index.html;</div><div class="line">    root /data0/htdocs/www;</div><div class="line">&#125;</div><div class="line"></div><div class="line">upstream a.com &#123;</div><div class="line"> <span class="built_in"> server </span> 192.168.5.126:80;</div><div class="line"> <span class="built_in"> server </span> 192.168.5.27:80;</div><div class="line"> <span class="built_in"> server </span> 127.0.0.1:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">重启nginx服务器就可以查看效果了<span class="symbol">:</span></div><div class="line">/etc/init.d/nginx restart</div><div class="line"><span class="keyword">or</span> </div><div class="line">nginx -s reload</div></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展:"></a>扩展:</h3><ul><li><p>轮询(默认方式)</p><p>每个请求按时间顺序逐一分配到后端服务器,如果后端服务器down掉,能自动剔除</p></li><li><p>weight</p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream bakend &#123;</div><div class="line">   <span class="built_in"> server </span>192.168.159.10 <span class="attribute">weight</span>=10;</div><div class="line">   <span class="built_in"> server </span>192.168.159.11 <span class="attribute">weight</span>=10;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>ip_hash</p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">    ip_hash;</div><div class="line">   <span class="built_in"> server </span>192.168.159.10:8080;</div><div class="line">   <span class="built_in"> server </span>192.168.159.11:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>fair(第三方)</p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">   <span class="built_in"> server </span>server1;</div><div class="line">   <span class="built_in"> server </span>server2;</div><div class="line">    fair;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>url_hash（第三方)</p><p>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">   <span class="built_in"> server </span>squid1:3128;</div><div class="line">   <span class="built_in"> server </span>squid2:3128;</div><div class="line">    hash <span class="variable">$request_uri</span>;</div><div class="line">    hash_method crc32;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p> 注意:<br> 定义负载均衡设备的Ip及设备状态<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">    ip_hash;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:8000 down;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:8080 <span class="attribute">weight</span>=2;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:6801;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:6802 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在需要使用负载均衡的server中增加<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_pass <span class="string">http:</span><span class="comment">//resinserver/;</span></div></pre></td></tr></table></figure></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">每个设备的状态设置为:</div><div class="line">  <span class="number">1</span><span class="selector-class">.down</span>   表示单前的server暂时不参与负载</div><div class="line">  <span class="number">2</span><span class="selector-class">.weight</span> 默认为<span class="number">1</span>.weight越大，负载的权重就越大。</div><div class="line">  <span class="number">3</span><span class="selector-class">.max_fails</span> 允许请求失败的次数默认为<span class="number">1</span>.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</div><div class="line">  <span class="number">4</span><span class="selector-class">.fail_timeout</span>:max_fails次失败后，暂停的时间。</div><div class="line">  <span class="number">5</span><span class="selector-class">.backup</span> 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</div><div class="line"></div><div class="line">nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</div><div class="line">  client_body_in_file_only 设置为On 可以讲client post过来的数据记录到文件中用来做debug</div><div class="line">  client_body_temp_path 设置记录文件的目录 可以设置最多<span class="number">3</span>层目录</div><div class="line">  location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</div></pre></td></tr></table></figure><ul><li><p>动静分离</p><pre><code>动静分离也是利用负载均衡的原理来实现的,为了便于管理,我们把ip分配的配置写在conf.d这个文件夹里面:</code></pre>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> <span class="keyword">conf</span>.<span class="built_in">d</span></div><div class="line">vim upstream.<span class="keyword">conf</span></div></pre></td></tr></table></figure><pre><code>里面写上动静分离的分配(以PHP和静态文件为例子):</code></pre>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> php &#123;</div><div class="line">    <span class="attribute">server</span> <span class="number">192.168.10.10:80</span>  <span class="comment">#php给这个服务器处理</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">upstream static &#123;</div><div class="line">    <span class="attribute">server</span> <span class="number">192.168.10.11:80</span> <span class="comment">#html给这个服务器处理</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">server&#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span> a.com;</div><div class="line">    <span class="attribute">location</span> / &#123; <span class="comment">#匹配所有静态资源文件用这个代理</span></div><div class="line">        <span class="attribute">proxy_pass</span>         http://static;   <span class="comment">#这个地址一定是上面定义的负载均衡的名字</span></div><div class="line">        <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123; <span class="comment">#匹配php文件用这个代理</span></div><div class="line">        <span class="attribute">proxy_pass</span>         http://php;   <span class="comment">#这个地址一定是上面定义的负载均衡的名字</span></div><div class="line">        <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果是使用apt-get安装的nginx,配置文件目录在:&lt;br&gt;  /etc/nginx/&lt;br&gt;cd到这个目录之后,ls查看所有文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;nginx.conf&lt;br&gt;  这个是nginx的主配置文件,里面包含了当前目录的所有配置文件,&lt;br
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="Nginx" scheme="https://bummingboy.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Gitlab Nginx 权限问题</title>
    <link href="https://bummingboy.top/2017/12/19/Centos%207%20Gitlab%20Nginx%20%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <id>https://bummingboy.top/2017/12/19/Centos 7 Gitlab Nginx 权限问题/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-06T08:09:47.852Z</updated>
    
    <content type="html"><![CDATA[<p>安装完GitLab之后, 正常配置可以使用, 此时使用Gitlab自带的Nginx服务器.<br>Gitlab比较消耗资源, 一般使用单独的服务器配置使用, 由于一些众所周知的原因, 有时需要使用服务器已安装的Nginx服务器, 不使用Gitlab自带的, 需要另做一下配置.</p><a id="more"></a><h3 id="修改gitlab配置文件"><a href="#修改gitlab配置文件" class="headerlink" title="修改gitlab配置文件"></a>修改gitlab配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/gitlab/gitlab.rb</span></div><div class="line"></div><div class="line">  搜索 /# nginx</div><div class="line"><span class="meta">  #</span><span class="bash"> nginx[<span class="string">'enable'</span>] = <span class="literal">true</span></span></div><div class="line"><span class="meta">  #</span><span class="bash"> nginx[<span class="string">'client_max_body_size'</span>] = <span class="string">'250m'</span></span></div><div class="line"><span class="meta">  #</span><span class="bash"> nginx[<span class="string">'redirect_http_to_https'</span>] = <span class="literal">false</span></span></div><div class="line">  </div><div class="line">  修改</div><div class="line">  nginx['enable'] = false</div></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><ol><li><p>直接将gitlab自动生成的nginx配置复制到Nginx虚拟主机配置文件夹下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp <span class="regexp">/var/</span>opt<span class="regexp">/gitlab/</span>nginx<span class="regexp">/conf/gi</span>tlab-http.conf <span class="regexp">/etc/</span>nginx<span class="regexp">/conf.d/</span></div></pre></td></tr></table></figure><p>或者 </p></li><li>自己手动生成配置文件, 放置 /etc/nginx/sites-avalible, 并生成相应软链</li></ol><h3 id="检测配置"><a href="#检测配置" class="headerlink" title="检测配置"></a>检测配置</h3>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nginx -t</span></div><div class="line"><span class="meta">$</span><span class="bash"> nginx -s reload</span></div></pre></td></tr></table></figure><h2 id="502问题"><a href="#502问题" class="headerlink" title="502问题"></a>502问题</h2><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ more /etc/gitlab/nginx/gitlab_error.<span class="built_in">log</span></div><div class="line"></div><div class="line"><span class="number">2017</span>/<span class="number">10</span>/<span class="number">10</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">58</span> [crit] <span class="number">8555</span>#<span class="number">0</span>: *<span class="number">13</span> connect() <span class="keyword">to</span> unix:/var/<span class="keyword">opt</span>/gitlab/gitlab-rails/sockets/gitlab.socket failed (<span class="number">13</span>: Permission denied) <span class="keyword">wh</span></div><div class="line">ile connecting <span class="keyword">to</span> upstream, clien<span class="variable">t:</span> <span class="number">59.108</span>.<span class="number">125.198</span>, server: gitlab.wei.<span class="keyword">com</span>, reques<span class="variable">t:</span> <span class="string">"GET / HTTP/1.1"</span>, upstream: <span class="comment">"http://unix:/var/opt/gitlab</span></div><div class="line">/gitlab-rails/sockets/gitlab.socke<span class="variable">t:</span>/<span class="string">", host: "</span>xxxxxxxxxx<span class="comment">"</span></div></pre></td></tr></table></figure><h3 id="Nginx没有访问gitlab的socket权限-nginx-用户无法执行sockets-gitlab-socket-文件"><a href="#Nginx没有访问gitlab的socket权限-nginx-用户无法执行sockets-gitlab-socket-文件" class="headerlink" title="Nginx没有访问gitlab的socket权限, nginx 用户无法执行sockets/gitlab.socket 文件"></a>Nginx没有访问gitlab的socket权限, nginx 用户无法执行sockets/gitlab.socket 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> drwxr-x--- 2 git  gitlab-www 4096 11月  3 15:57 sockets</span></div><div class="line"></div><div class="line">法1: chmod -R o+x /var/opt/gitlab/gitlab-rails/sockets</div><div class="line">法2: chmod 755 /var/opt/gitlab/gitlab-rails/sockets</div><div class="line">法3: 将Nginx用户加入gitlab-www组</div><div class="line"><span class="meta">$</span><span class="bash"> usermod -a -G gitlab-www nginx</span></div><div class="line"></div><div class="line">修改gitlab.rb</div><div class="line">搜索/# web_server</div><div class="line">web_server['external_users'] = ['nginx'] #这里与nginx进程执行用户一致 可通过ps -ef | grep nginx 查看</div><div class="line"><span class="meta">#</span><span class="bash"> web_server[<span class="string">'username'</span>] = <span class="string">'gitlab-www'</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> web_server[<span class="string">'group'</span>] = <span class="string">'gitlab-www'</span></span></div></pre></td></tr></table></figure><h2 id="111-Connection-refused"><a href="#111-Connection-refused" class="headerlink" title="( 111: Connection refused )"></a>( 111: Connection refused )</h2><p>系统内存不足. 服务启动失败</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装完GitLab之后, 正常配置可以使用, 此时使用Gitlab自带的Nginx服务器.&lt;br&gt;Gitlab比较消耗资源, 一般使用单独的服务器配置使用, 由于一些众所周知的原因, 有时需要使用服务器已安装的Nginx服务器, 不使用Gitlab自带的, 需要另做一下配置.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
      <category term="Centos 7" scheme="https://bummingboy.top/categories/linux/centos-7/"/>
    
    
      <category term="Centos7" scheme="https://bummingboy.top/tags/centos7/"/>
    
      <category term="Gitlab" scheme="https://bummingboy.top/tags/gitlab/"/>
    
      <category term="Nginx" scheme="https://bummingboy.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux du 命令</title>
    <link href="https://bummingboy.top/2017/12/19/du/"/>
    <id>https://bummingboy.top/2017/12/19/du/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T12:02:34.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看当前目录下的所有目录以及子目录的大小"><a href="#查看当前目录下的所有目录以及子目录的大小" class="headerlink" title="查看当前目录下的所有目录以及子目录的大小"></a>查看当前目录下的所有目录以及子目录的大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> du -h</span></div><div class="line"><span class="meta">$</span><span class="bash"> du -ah</span></div><div class="line"><span class="meta">#</span><span class="bash">-h:用K、M、G的人性化形式显示</span></div><div class="line"><span class="meta">#</span><span class="bash">-a:显示目录和文件</span></div></pre></td></tr></table></figure><a id="more"></a><h3 id="只查看当前目录下的tmp目录-包含子目录-的大小"><a href="#只查看当前目录下的tmp目录-包含子目录-的大小" class="headerlink" title="只查看当前目录下的tmp目录(包含子目录)的大小"></a>只查看当前目录下的tmp目录(包含子目录)的大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> du -h tmp</span></div><div class="line"><span class="meta">$</span><span class="bash"> du -ah tmp</span></div></pre></td></tr></table></figure><h3 id="查看当前目录及其指定深度目录的大小"><a href="#查看当前目录及其指定深度目录的大小" class="headerlink" title="查看当前目录及其指定深度目录的大小"></a>查看当前目录及其指定深度目录的大小</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">du -h –-<span class="built_in">max</span>-depth=<span class="number">0</span></div><div class="line">#-–<span class="built_in">max</span>-depth＝<span class="symbol">n:</span>只深入到第<span class="built_in">n</span>层目录，此处设置为<span class="number">0</span>，即表示不深入到子目录</div></pre></td></tr></table></figure><h3 id="du命令的一些常用参数"><a href="#du命令的一些常用参数" class="headerlink" title="du命令的一些常用参数:"></a>du命令的一些常用参数:</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">a或-all 显示目录中个别文件的大小</span></div><div class="line"><span class="ruby">-b或-bytes 显示目录或文件大小时，以byte为单位</span></div><div class="line"><span class="ruby">-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span></div><div class="line"><span class="ruby">-D或--dereference-args 显示指定符号连接的源文件大小</span></div><div class="line"><span class="ruby">-h或--human-readable 以K，M，G为单位，提高信息的可读性</span></div><div class="line"><span class="ruby">-k或--kilobytes 以<span class="number">1024</span> bytes为单位</span></div><div class="line"><span class="ruby">-l或--count-links 重复计算硬件连接的文件</span></div><div class="line"><span class="ruby">-L或--dereference 显示选项中所指定符号连接的源文件大小</span></div><div class="line"><span class="ruby">-m或--megabytes 以<span class="number">1</span>MB为单位</span></div><div class="line"><span class="ruby">-s或--summarize 仅显示总计</span></div><div class="line"><span class="ruby">-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小</span></div><div class="line"><span class="ruby">-X&lt;文件&gt;或--exclude-from=&lt;文件&gt;</span></div><div class="line"><span class="ruby">--exclude=&lt;目录或文件&gt; 略过指定的目录或文件</span></div><div class="line"><span class="ruby">--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略</span></div></pre></td></tr></table></figure><h3 id="查看设备使用率"><a href="#查看设备使用率" class="headerlink" title="查看设备使用率"></a>查看设备使用率</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df 用于查看设备的空间使用率</div><div class="line"><span class="meta">$</span><span class="bash"> df -lh</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;查看当前目录下的所有目录以及子目录的大小&quot;&gt;&lt;a href=&quot;#查看当前目录下的所有目录以及子目录的大小&quot; class=&quot;headerlink&quot; title=&quot;查看当前目录下的所有目录以及子目录的大小&quot;&gt;&lt;/a&gt;查看当前目录下的所有目录以及子目录的大小&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; du -h&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; du -ah&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;-h:用K、M、G的人性化形式显示&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;-a:显示目录和文件&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="du" scheme="https://bummingboy.top/tags/du/"/>
    
  </entry>
  
  <entry>
    <title>shell - 参数解析三种方式(手工, getopts, getopt)</title>
    <link href="https://bummingboy.top/2017/12/19/shell%20-%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E6%89%8B%E5%B7%A5,%20getopts,%20getopt)/"/>
    <id>https://bummingboy.top/2017/12/19/shell - 参数解析三种方式(手工, getopts, getopt)/</id>
    <published>2017-12-19T09:44:47.000Z</published>
    <updated>2018-07-03T10:26:42.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数:"></a>选项和参数:</h3><ul><li>Argument, Option: 中文对应「选项」，形如 -a, –save 的都是选项；选项可以接收参数（Parameter），也可以不接受参数。其中-a 为短选项, –save 为长选项</li><li>Flag: 中文对应「标签」，形如 -v(verbose)；标签是布尔值，不接受参数。</li></ul><p>bash shell 汇总有三种解析参数的方式:</p><ul><li>手工处理:   大多数简单的命令</li><li>getopts:  大多数复杂命令, 不支持长选项</li><li>getopt:  支持长选项, getopts和getopt功能相似但又不完全相同，其中getopt是独立的可执行文件，而getopts是由Bash内置的</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./<span class="keyword">test</span>.<span class="keyword">sh</span> -v -f -<span class="keyword">out</span> /<span class="keyword">test</span>.<span class="keyword">log</span> --prefix=/home</div></pre></td></tr></table></figure><p>  <strong>如果执行是permission denied: test.sh, 运行 chmod +x test.sh 赋予其可执行权限 或是 通过sh/bash 命令运行</strong></p><h3 id="手工处理"><a href="#手工处理" class="headerlink" title="手工处理"></a>手工处理</h3><ul><li>$0 : 在用sh 或者 ./执行脚本时，指的是脚本名，用source或.执行时，永运是bash，这也反应了sh 或者 ./执行脚本的原理和source的方式是不同的.</li><li>$1 : -v,第一个参数.</li><li>$2 : -f</li><li>$3 : -out</li><li>$4 : /test.log </li><li>依次类推 $5 $6 …</li><li>$# : 参数的个数，不包括命令本身，上例中\$#为5.</li><li>$@ : 参数本身的列表，也不包括命令本身，如上例为 -v -f -out /test.log –prefix=/home</li><li>$* : 参数本身的列表，也不包括命令本身，但”$*” 和”\$@”(加引号)并不同，”$*“将所有的参数解释成一个字符串，而”$@”是一个参数数组。如下例所示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">v -f -out /test.log --prefix=<span class="regexp">/home</span></span></div><div class="line"><span class="ruby">-v</span></div><div class="line"><span class="ruby">-f</span></div><div class="line"><span class="ruby">-out</span></div><div class="line"><span class="ruby">/test.log</span></div><div class="line"><span class="ruby">--prefix=<span class="regexp">/home</span></span></div></pre></td></tr></table></figure><p><strong>也就是说手工处理方式高度依赖命令行中参数的位置, 只适合简单的参数较少的命令, 手工处理方式能满足大多数的简单需求，配合shift使用也能构造出强大的功能</strong></p><h3 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h3><p>先来看看参数传递的典型用法:</p><ul><li>./test.sh -a -b -c  ： 短选项，各选项不需参数</li><li>./test.sh -abc   ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。</li><li>./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。</li><li>./test.sh –a-long=args –b-long ：长选项</li></ul><h4 id="getopts-用法"><a href="#getopts-用法" class="headerlink" title="getopts 用法"></a>getopts 用法</h4><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><strong>OPTIND</strong>: getopts 在解析传入 Shell 脚本的参数时（也就是 $@），并不会执行 shift 操作，而是通过变量 OPTIND 来记住接下来要解析的参数的位置。</li><li><p><strong>OPTARG</strong>: getopts 在解析到选项的参数时，就会将参数保存在 OPTARG 变量当中；如果 getopts 遇到不合法的选项，择把选项本身保存在 OPTARG 当中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getopts OPTSTRING VARNAME <span class="string">[ARGS...]</span></div></pre></td></tr></table></figure></li><li><p><strong>OPTSTRING</strong> 记录合法的选项列表（以及参数情况)</p></li><li><strong>VARNAME</strong> 则传入一个 Shell 变量的名字，用于保存 getopts 解析到的选项的名字（而不是参数值，参数值保存在 OPTARG 里）</li><li><strong>ATGS…</strong> 是可选的，默认是 $@，即传入 Shell 脚本的全部参数</li></ul><p>通常来说，我们会将 getopts 放在 while 循环的条件判断式中。getopts 在顺利解析到参数的时候，会返回 TRUE；否则返回 FALSE，用以结束循环.<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> ...; <span class="keyword">do</span></div><div class="line">    ...</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p><p>getopts 在两种情况下会停止解析并返回 FALSE：</p><ul><li>getopts 读入不以 - 开始的字符串；比如: sh test.sh flag</li><li>getopts 读入连续的两个 - (i.e. –)</li></ul><h4 id="OPTSTRING"><a href="#OPTSTRING" class="headerlink" title="OPTSTRING"></a>OPTSTRING</h4><p>通过 <strong>OPTSTRING</strong> getopts 知道哪些参数是合法的，哪些参数又是需要接受参数的。<br>OPTSTRING 的格式很简单，就是一个简单的字符串。字符串里，每一个字母（大小写均可，但区分大小写）都是一个选项的名字。</p><p><strong>值得一提的是冒号 (:)</strong><br>在 OPTSTRING 中，冒号有两种含义：</p><ul><li>首位的 : 表示「不打印错误信息」；</li><li><p>紧邻字母（选项名字）的 : 表示该选项接收一个参数。</p><p>例如: </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getopts aBcD VARNAME <span class="comment">// 该脚本接受四个标签-a, -B, -c, -D, 均不接受参数</span></div><div class="line"><span class="string">getopts :</span><span class="string">aB:</span>Cd VARNAME <span class="comment">// 该脚本接受两个标签-a, -B, 两个短选项-C, -d</span></div></pre></td></tr></table></figure></li></ul><p>下面是实例:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">":a:bc:"</span> opt; <span class="keyword">do</span> <span class="comment">#不打印错误信息, -a -c需要参数 -b 不需要传参  </span></div><div class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></div><div class="line">    a)</div><div class="line">      <span class="built_in">echo</span> <span class="string">"-a arg:<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span> <span class="comment">#$OPTIND指的下一个选项的index</span></div><div class="line">      ;;</div><div class="line">    b)</div><div class="line">      <span class="built_in">echo</span> <span class="string">"-b arg:<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span></div><div class="line">      ;;</div><div class="line">    c) </div><div class="line">      <span class="built_in">echo</span> <span class="string">"-c arg:<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span></div><div class="line">      ;;</div><div class="line">    :)</div><div class="line">      <span class="built_in">echo</span> <span class="string">"Option -<span class="variable">$OPTARG</span> requires an argument."</span> </div><div class="line">      <span class="built_in">exit</span> 1</div><div class="line">      ;;</div><div class="line">    ?) <span class="comment">#当有不认识的选项的时候arg为?</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">"Invalid option: -<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span></div><div class="line">      ;;</div><div class="line">    </div><div class="line">  <span class="keyword">esac</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ ./test<span class="selector-class">.sh</span> -<span class="selector-tag">a</span> ssss -<span class="selector-tag">b</span> ssss -c</div><div class="line">  &gt;&gt;</div><div class="line">  -<span class="selector-tag">a</span> ssss -<span class="selector-tag">b</span> ssss -c</div><div class="line">  -<span class="selector-tag">a</span> arg:ssss index:<span class="number">3</span></div><div class="line">  -<span class="selector-tag">b</span> arg: index:<span class="number">4</span> #-b并不接受参数, 解析到ssss时直接停止解析</div><div class="line"></div><div class="line">$ ./test<span class="selector-class">.sh</span>  -c xxx -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss</div><div class="line">  &gt;&gt;</div><div class="line">  -c xxx -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss</div><div class="line">  -c arg:xxx index:<span class="number">3</span></div><div class="line">  -<span class="selector-tag">b</span> arg: index:<span class="number">4</span></div><div class="line">  -<span class="selector-tag">a</span> arg:ssssss index:<span class="number">6</span></div><div class="line"></div><div class="line">$ ./test<span class="selector-class">.sh</span>  -c -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss  <span class="comment">// -c 后面没有参数 -b会解析成-c参数</span></div><div class="line">  &gt;&gt;</div><div class="line">  -c -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss</div><div class="line">  -c arg:-b</div><div class="line">  -<span class="selector-tag">a</span> arg:ssssss</div><div class="line">  </div><div class="line">$ ./test<span class="selector-class">.sh</span> -a</div><div class="line">  &gt;&gt; </div><div class="line">  a</div><div class="line">  Option -<span class="selector-tag">a</span> requires an argument.</div></pre></td></tr></table></figure><h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>  getopt较bash内置的getopts更强大，其不仅支持短参-s，还支持–longopt的长参数，甚至支持-longopt的简化参数。相较于getopts ，getopts 不但支持长短选项，其还支持选项和参数放在一起写。</p><h4 id="getopt-用法"><a href="#getopt-用法" class="headerlink" title="getopt 用法"></a>getopt 用法</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getopt [<span class="keyword">options</span>] -o|--<span class="keyword">options</span> optstring [<span class="keyword">options</span>] [--] <span class="keyword">parameters</span></div></pre></td></tr></table></figure><p>  选项说明：<br>      -a：使getopt长参数支持”-“符号打头，必须与-l同时使用<br>      -l：后面接getopt支持长参数列表<br>      -n program：如果getopt处理参数返回错误，会指出是谁处理的这个错误，这个在调用多个脚本时，很有用<br>      -o：后面接短参数列表，这种用法与getopts类似<br>      -u：不给参数列表加引号，默认是加引号的（不使用-u选项），例如在加引号的时候 –longoption “arg1 arg2” ，只会取到”arg1”，而不是完整的”arg1 arg2”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># A small example program for using the new getopt(1) program.</span></div><div class="line"><span class="comment"># This program will only work with bash(1)</span></div><div class="line"><span class="comment"># Note that we use `"$@"' to let each command-line parameter expand to a</span></div><div class="line"><span class="comment"># separate word. The quotes around `$@' are essential!</span></div><div class="line"><span class="comment"># We need TEMP as the `eval set --' would nuke the return value of getopt.</span></div><div class="line">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: -n <span class="string">'example.bash'</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</div><div class="line"><span class="keyword">if</span> [ $? != 0 ] ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"Terminating..."</span> &gt;&amp;2 ; <span class="built_in">exit</span> 1 ; <span class="keyword">fi</span></div><div class="line"><span class="comment"># Note the quotes around `$TEMP': they are essential!</span></div><div class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$TEMP</span>"</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">                -a|--a-long) <span class="built_in">echo</span> <span class="string">"Option a"</span> ; <span class="built_in">shift</span> ;;</div><div class="line">                -b|--b-long) <span class="built_in">echo</span> <span class="string">"Option b, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</div><div class="line">                -c|--c-long)</div><div class="line">                        <span class="comment"># c has an optional argument. As we are in quoted mode,</span></div><div class="line">                        <span class="comment"># an empty parameter will be generated if its optional</span></div><div class="line">                        <span class="comment"># argument is not found.</span></div><div class="line">                        <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></div><div class="line">                                <span class="string">""</span>) <span class="built_in">echo</span> <span class="string">"Option c, no argument"</span>; <span class="built_in">shift</span> 2 ;;</div><div class="line">                                *)  <span class="built_in">echo</span> <span class="string">"Option c, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</div><div class="line">                        <span class="keyword">esac</span> ;;</div><div class="line">                --) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</div><div class="line">                *) <span class="built_in">echo</span> <span class="string">"Internal error!"</span> ; <span class="built_in">exit</span> 1 ;;</div><div class="line">        <span class="keyword">esac</span></div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Remaining arguments:"</span></div><div class="line"><span class="keyword">for</span> arg <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">'--&gt; '</span><span class="string">"\`<span class="variable">$arg</span>'"</span> ; <span class="keyword">done</span></div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">ARGS=`getopt -a -o I:D:T:e:k:LMSsth -l instence:,database:,table:,excute:,key:,list,master,slave,status,tableview,<span class="built_in">help</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</div><div class="line">    <span class="built_in">echo</span>  <span class="string">'help'</span></div><div class="line">&#125;</div><div class="line">[ $? -ne 0 ] &amp;&amp; usage</div><div class="line"><span class="comment">#set -- "$&#123;ARGS&#125;"</span></div><div class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$&#123;ARGS&#125;</span>"</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span></div><div class="line"><span class="keyword">do</span></div><div class="line">      <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">      -I|--instence)</div><div class="line">              instence=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -D|--database)</div><div class="line">              database=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -T|--table)</div><div class="line">              table=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -e|--excute)</div><div class="line">              excute=<span class="string">"yes"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -k|--key)</div><div class="line">              key=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -L|--list)</div><div class="line">              LIST=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -M|--master)</div><div class="line">              MASTER=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -S|--slave)</div><div class="line">              SLAVE=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -A|--alldb)</div><div class="line">              ALLDB=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -s|--status)</div><div class="line">              STATUS=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -t|--tableview)</div><div class="line">              TABLEVIEW=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -h|--<span class="built_in">help</span>)</div><div class="line">              usage</div><div class="line">              ;;</div><div class="line">      --)</div><div class="line">              <span class="built_in">shift</span></div><div class="line">              <span class="built_in">break</span></div><div class="line">              ;;</div><div class="line">      <span class="keyword">esac</span></div><div class="line"><span class="built_in">shift</span></div><div class="line"><span class="keyword">done</span> </div><div class="line"><span class="built_in">echo</span> instence:<span class="variable">$instence</span> database:<span class="variable">$database</span> table:<span class="variable">$table</span> excute:<span class="variable">$excute</span> key:<span class="variable">$key</span></div></pre></td></tr></table></figure><h3 id="选项标准化"><a href="#选项标准化" class="headerlink" title="选项标准化"></a>选项标准化</h3><p>在创建shell脚本时，尽量保持选项与Linux通用的选项含义相同，Linux通用选项有：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">a 显示所有对象</span></div><div class="line"><span class="ruby">-c 生产一个计数</span></div><div class="line"><span class="ruby">-d 指定一个目录</span></div><div class="line"><span class="ruby">-e 扩展一个对象</span></div><div class="line"><span class="ruby">-f 指定读入数据的文件</span></div><div class="line"><span class="ruby">-h 显示命令的帮助信息</span></div><div class="line"><span class="ruby">-i 忽略文本大小写</span></div><div class="line"><span class="ruby">-l 产生输出得长格式文本</span></div><div class="line"><span class="ruby">-n 使用非交互模式</span></div><div class="line"><span class="ruby">-o 指定将所有输出重定向到输出文件</span></div><div class="line"><span class="ruby">-q 以安静模式运行    </span></div><div class="line"><span class="ruby">-r 递归的处理目录和文件</span></div><div class="line"><span class="ruby">-s 以安静模式运行    </span></div><div class="line"><span class="ruby">-v 生成详细输出  </span></div><div class="line"><span class="ruby">-x 排除某个对象 </span></div><div class="line"><span class="ruby">-y 对所有问题回答yes</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;选项和参数&quot;&gt;&lt;a href=&quot;#选项和参数&quot; class=&quot;headerlink&quot; title=&quot;选项和参数:&quot;&gt;&lt;/a&gt;选项和参数:&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Argument, Option: 中文对应「选项」，形如 -a, –save 的都是选项；选项可以
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
  </entry>
  
</feed>
