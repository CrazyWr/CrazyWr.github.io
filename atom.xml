<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>面向信仰</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bummingboy.top/"/>
  <updated>2018-07-03T12:02:34.483Z</updated>
  <id>https://bummingboy.top/</id>
  
  <author>
    <name>面向信仰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Network - HTTP 长连接 短连接</title>
    <link href="https://bummingboy.top/2018/05/11/HTTP%20-%20%E9%95%BF%E8%BF%9E%E6%8E%A5%20%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>https://bummingboy.top/2018/05/11/HTTP - 长连接 短连接/</id>
    <published>2018-05-11T08:33:12.972Z</published>
    <updated>2018-07-03T12:02:34.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HTTP协议与TCP-IP协议的关系"><a href="#1-HTTP协议与TCP-IP协议的关系" class="headerlink" title="1. HTTP协议与TCP/IP协议的关系"></a>1. HTTP协议与TCP/IP协议的关系</h3><p>　　<br>　　HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。<br><a id="more"></a></p><h3 id="2-如何理解HTTP协议是无状态的"><a href="#2-如何理解HTTP协议是无状态的" class="headerlink" title="2. 如何理解HTTP协议是无状态的"></a>2. 如何理解HTTP协议是无状态的</h3><p>　　HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。　　</p><h3 id="3-什么是长连接、短连接？"><a href="#3-什么是长连接、短连接？" class="headerlink" title="3. 什么是长连接、短连接？"></a>3. 什么是长连接、短连接？</h3><p>　　在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</div></pre></td></tr></table></figure></p><p>　　在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h4 id="3-1-TCP连接"><a href="#3-1-TCP连接" class="headerlink" title="3.1 TCP连接"></a>3.1 TCP连接</h4><p>　　当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p><p>经典的三次握手四次挥手示意图：<br><img src="/images/6159FF5BB9DB0467622B596D011BA80B.jpg" alt="IMAGE"><br><img src="/images/6890899C73432946708E77A8AE98FA43.jpg" alt="IMAGE"></p><h4 id="3-2-TCP短连接"><a href="#3-2-TCP短连接" class="headerlink" title="3.2 TCP短连接"></a>3.2 TCP短连接</h4><p>　　我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><h4 id="3-3-TCP长连接"><a href="#3-3-TCP长连接" class="headerlink" title="3.3 TCP长连接"></a>3.3 TCP长连接</h4><p>　　接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p><ul><li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li><li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li></ul><h4 id="3-4-长连接短连接操作过程"><a href="#3-4-长连接短连接操作过程" class="headerlink" title="3.4 长连接短连接操作过程"></a>3.4 长连接短连接操作过程</h4><p>短连接的操作步骤是：<br><code>建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接</code><br>长连接的操作步骤是：<br><code>建立连接——数据传输...（保持连接）...数据传输——关闭连接</code></p><h3 id="4-长连接和短连接的优点和缺点"><a href="#4-长连接和短连接的优点和缺点" class="headerlink" title="4. 长连接和短连接的优点和缺点"></a>4. 长连接和短连接的优点和缺点</h3><p>　　长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>　　短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p><h3 id="5-什么时候用长连接，短连接？"><a href="#5-什么时候用长连接，短连接？" class="headerlink" title="5. 什么时候用长连接，短连接？"></a>5. 什么时候用长连接，短连接？</h3><p>　  长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，每次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 </p><p>　　而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。<br>　　<br>　　<br>原文链接: <a href="http://www.cnblogs.com/0201zcr/p/4694945.html" target="_blank" rel="external">http://www.cnblogs.com/0201zcr/p/4694945.html</a></p><h3 id="补充-HTTP-keep-alive-和-websocket"><a href="#补充-HTTP-keep-alive-和-websocket" class="headerlink" title="补充: HTTP keep alive 和 websocket"></a>补充: HTTP keep alive 和 websocket</h3><p>可以把 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和HTTP有一些共性，是为了解决 HTTP 本身无法解决的某些问题而做出的一个改良设计。在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header；所谓的 polling 是指从客户端（一般就是浏览器）不断主动的向服务器发 HTTP 请求查询是否有新数据。这两种模式有一个共同的缺点，就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header，信息交换效率很低。它们建立的“长连接”都是伪.长连接，只不过好处是不需要对现有的 HTTP server 和浏览器架构做修改就能实现。</p><p>WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。但是不需要发送 HTTP header就能交换数据显然和原有的 HTTP 协议是有区别的，所以它需要对服务器和客户端都进行升级才能实现。在此基础上 WebSocket 还是一个<strong>双通道</strong>的连接，在同一个 TCP 连接上既可以发也可以收信息。此外还有 multiplexing 功能，几个不同的 URI 可以复用同一个 WebSocket 连接。这些都是原来的 HTTP 不能做到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-HTTP协议与TCP-IP协议的关系&quot;&gt;&lt;a href=&quot;#1-HTTP协议与TCP-IP协议的关系&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP协议与TCP/IP协议的关系&quot;&gt;&lt;/a&gt;1. HTTP协议与TCP/IP协议的关系&lt;/h3&gt;&lt;p&gt;　　&lt;br&gt;　　HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="https://bummingboy.top/categories/network/"/>
    
    
      <category term="HTTP" scheme="https://bummingboy.top/tags/http/"/>
    
      <category term="长连接" scheme="https://bummingboy.top/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="短连接" scheme="https://bummingboy.top/tags/%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>Node - pm2 cluster 模式无法使用babel-node启动</title>
    <link href="https://bummingboy.top/2018/04/26/Node%20-%20pm2%20cluster%20%E6%A8%A1%E5%BC%8F%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8babel-node%E5%90%AF%E5%8A%A8/"/>
    <id>https://bummingboy.top/2018/04/26/Node - pm2 cluster 模式无法使用babel-node启动/</id>
    <published>2018-04-26T06:45:38.656Z</published>
    <updated>2018-07-03T10:26:30.781Z</updated>
    
    <content type="html"><![CDATA[<p>为了使用 ES6/7 的新功能, 而且不进行转码, 项目一直使用 babel-node 启动脚本, 同时使用 pm2 进行项目管理, 开发环境下 babel-node 可以正常工作, 生产环境下 pm2 并不支持使用 babel-node,  </p><p>Because the cluster mode has an hardcoded interpreter which is node</p><p>也就是说 cluster 模式下 interpreter 是写死的使用的node, “exec_interpreter” 参数会被忽略.</p><p>通过以下方式通过 pm2 cluster 模式使用 ES6/7 新功能</p><p><a href="http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2#require-hook" target="_blank" rel="external">http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2#require-hook</a></p><ol><li>安装 babel-register, babel-polyfill</li><li><p>新建入口文件index.js, 假设原来的入口文件为app.js</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span>(<span class="string">'babel-register'</span>);</div><div class="line"><span class="keyword">require</span>(<span class="string">'babel-polyfill'</span>);</div><div class="line"><span class="keyword">require</span>(<span class="string">'app.js'</span>); <span class="regexp">//</span> 设置对应位置</div></pre></td></tr></table></figure></li><li><p>在对应的 pm2.json 文件中设置, 入口文件为 index.js.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了使用 ES6/7 的新功能, 而且不进行转码, 项目一直使用 babel-node 启动脚本, 同时使用 pm2 进行项目管理, 开发环境下 babel-node 可以正常工作, 生产环境下 pm2 并不支持使用 babel-node,  &lt;/p&gt;
&lt;p&gt;Because
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="Node" scheme="https://bummingboy.top/tags/node/"/>
    
      <category term="pm2" scheme="https://bummingboy.top/tags/pm2/"/>
    
      <category term="cluster" scheme="https://bummingboy.top/tags/cluster/"/>
    
  </entry>
  
  <entry>
    <title>Linux 服务器内部无法正常解析域名</title>
    <link href="https://bummingboy.top/2018/04/25/Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E9%83%A8%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D/"/>
    <id>https://bummingboy.top/2018/04/25/Linux 服务器内部无法正常解析域名/</id>
    <published>2018-04-25T12:11:17.214Z</published>
    <updated>2018-07-03T10:26:11.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>  Linux 服务器内部无法正常解析域名, IP访问正常<br>  curl xxx.xxx Could not resolve host: xxx.xxx</p><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><p>可能的原因包括：</p><ul><li>DNS 设置问题</li><li>防火墙策略问题</li><li>NSCD 服务问题</li></ul><h2 id="处理办法"><a href="#处理办法" class="headerlink" title="处理办法"></a>处理办法</h2><p>1、通过如下指令，检查系统是否正确设置了 dns 服务器。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cat /etc/resolv.conf</div><div class="line"><span class="meta">#</span><span class="bash"> Generated by NetworkManager</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> No nameservers found; try putting DNS servers into your</span></div><div class="line"><span class="meta">#</span><span class="bash"> ifcfg files <span class="keyword">in</span> /etc/sysconfig/network-scripts like so:</span></div><div class="line"><span class="meta">#</span><span class="bash"></span></div><div class="line"><span class="meta">#</span><span class="bash"> DNS1=xxx.xxx.xxx.xxx</span></div><div class="line"><span class="meta">#</span><span class="bash"> DNS2=xxx.xxx.xxx.xxx</span></div><div class="line"><span class="meta">#</span><span class="bash"> DOMAIN=lab.foo.com bar.foo.com</span></div><div class="line">nameserver 10.242.197.247</div><div class="line">nameserver 10.242.197.248</div></pre></td></tr></table></figure></p><p>如果没有 DNS 的配置则需要添加设置，公网服务器可以设置为阿里云如下公共 DNS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">nameserver</span> 223<span class="selector-class">.5</span><span class="selector-class">.5</span><span class="selector-class">.5</span></div><div class="line"><span class="selector-tag">nameserver</span> 223<span class="selector-class">.6</span><span class="selector-class">.6</span><span class="selector-class">.6</span></div></pre></td></tr></table></figure></p><p>2、检查防火墙 iptables，查看是否有拦截 53 端口的相关规则。</p><p>可以先使用命令 service iptables stop 关闭防火墙对比测试。如果存在 iptables 规则，尝试删除 deny 策略或修改规则为 ACCEPT 策略。</p><p>3、检查是否开启 dns 缓存服务 nscd：</p><p>通过 service  nscd  status 命令查看服务状态。如果已经开启，尝试使用命令 service  nscd  stop 关闭服务后再对比测试。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service nscd status</div><div class="line">service nscd stop</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;  Linux 服务器内部无法正常解析域名, IP访问正常&lt;br&gt;  curl xxx.xxx Could not reso
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://bummingboy.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 阻止自动http 跳转 https</title>
    <link href="https://bummingboy.top/2018/04/25/Chrome%20%E9%98%BB%E6%AD%A2%E8%87%AA%E5%8A%A8http%20%E8%B7%B3%E8%BD%AC%20https/"/>
    <id>https://bummingboy.top/2018/04/25/Chrome 阻止自动http 跳转 https/</id>
    <published>2018-04-25T12:11:17.198Z</published>
    <updated>2018-07-03T12:00:25.560Z</updated>
    
    <content type="html"><![CDATA[<p>配置一个服务使用SSL出错, 当前使用的是二级域名, 根域名有别的SSL证书, 然后切换回http时, 一直自动跳转到https, 使用的是根域名的SSL证书, 跟当前二级域名不相符, 一直提示不安全的连接, 很长时间无法直接访问http.</p><a id="more"></a><p>解决办法:</p><p>在chrome的地址栏输入：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">chrome:</span>//net-internals/<span class="meta">#hsts</span></div></pre></td></tr></table></figure></p><p>在打开的页面中，Delete domain栏的输入框中输入：xxxx.xxxxx(要访问的域名)，然后点击“delete”按钮，即可完成配置。</p><p>然后你可以在Query domain栏中搜索刚才输入的域名，点击“query”按钮后如果提示“Not found”，那么你现在就可以使用http来访问那个网站了！</p><p>至于 chrome hsts 的作用看这里</p><h3 id="HSTS-简介"><a href="#HSTS-简介" class="headerlink" title="HSTS 简介"></a>HSTS 简介</h3><p>国际互联网工程组织IETE正在推行一种新的Web安全协议HTTP Strict Transport Security（HSTS）<br>采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。<br>该协议将帮助网站采用全局加密，用户看到的就是该网站的安全版本。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在第一次访问https网站时，网站的回复表头带有「Strict-Transport-Security」，该表头会让浏览器记得，该网站(正确说法是域名)有提供HTTPS安全连线，并于下次连线中强制使用HTTPS，注意是强制喔，不论是点进不带有https的连接，或是你故意在网址里打入网址时使用 http:// 为开头，浏览器都会先强制转换成https再送出请求</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;配置一个服务使用SSL出错, 当前使用的是二级域名, 根域名有别的SSL证书, 然后切换回http时, 一直自动跳转到https, 使用的是根域名的SSL证书, 跟当前二级域名不相符, 一直提示不安全的连接, 很长时间无法直接访问http.&lt;/p&gt;
    
    </summary>
    
      <category term="Chrome" scheme="https://bummingboy.top/categories/chrome/"/>
    
    
      <category term="Chrome" scheme="https://bummingboy.top/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>shell - 判断文件夹是否存在</title>
    <link href="https://bummingboy.top/2018/04/25/shell%20-%20%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/"/>
    <id>https://bummingboy.top/2018/04/25/shell - 判断文件夹是否存在/</id>
    <published>2018-04-25T12:11:17.171Z</published>
    <updated>2018-07-03T10:26:38.960Z</updated>
    
    <content type="html"><![CDATA[<p>#shell判断文件夹是否存在</p><p>#如果文件夹不存在，创建文件夹<br>if [ ! -d “/myfolder” ]; then<br>  mkdir /myfolder<br>fi</p><p>#shell判断文件,目录是否存在或者具有权限</p><p>folder=”/var/www/“<br>file=”/var/www/log”</p><h1 id="x-参数判断-folder-是否存在并且是否具有可执行权限"><a href="#x-参数判断-folder-是否存在并且是否具有可执行权限" class="headerlink" title="-x 参数判断 $folder 是否存在并且是否具有可执行权限"></a>-x 参数判断 $folder 是否存在并且是否具有可执行权限</h1><p>if [ ! -x “$folder”]; then<br>  mkdir “$folder”<br>fi</p><h1 id="d-参数判断-folder-是否存在"><a href="#d-参数判断-folder-是否存在" class="headerlink" title="-d 参数判断 $folder 是否存在"></a>-d 参数判断 $folder 是否存在</h1><p>if [ ! -d “$folder”]; then<br>  mkdir “$folder”<br>fi</p><h1 id="f-参数判断-file-是否存在"><a href="#f-参数判断-file-是否存在" class="headerlink" title="-f 参数判断 $file 是否存在"></a>-f 参数判断 $file 是否存在</h1><p>if [ ! -f “$file” ]; then<br>  touch “$file”<br>fi</p><h1 id="n-判断一个变量是否有值"><a href="#n-判断一个变量是否有值" class="headerlink" title="-n 判断一个变量是否有值"></a>-n 判断一个变量是否有值</h1><p>if [ ! -n “$var” ]; then<br>  echo “$var is empty”<br>  exit 0<br>fi</p><h1 id="判断两个变量是否相等"><a href="#判断两个变量是否相等" class="headerlink" title="判断两个变量是否相等"></a>判断两个变量是否相等</h1><p>if [ “$var1” = “$var2” ]; then<br>  echo ‘$var1 eq $var2’<br>else<br>  echo ‘$var1 not eq $var2’<br>fi</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#shell判断文件夹是否存在&lt;/p&gt;
&lt;p&gt;#如果文件夹不存在，创建文件夹&lt;br&gt;if [ ! -d “/myfolder” ]; then&lt;br&gt;  mkdir /myfolder&lt;br&gt;fi&lt;/p&gt;
&lt;p&gt;#shell判断文件,目录是否存在或者具有权限&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="shell" scheme="https://bummingboy.top/categories/shell/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell - 条件判断 if 中 -a 到 -z 的意思</title>
    <link href="https://bummingboy.top/2018/04/25/shell%20-%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif%E4%B8%AD%E7%9A%84-a%E5%88%B0-z%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <id>https://bummingboy.top/2018/04/25/shell - 条件判断if中的-a到-z的意思/</id>
    <published>2018-04-25T12:11:17.166Z</published>
    <updated>2018-07-03T10:26:52.735Z</updated>
    
    <content type="html"><![CDATA[<p>[ -a FILE ] 如果 FILE 存在则为真。 </p><p>[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 </p><p>[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 </p><p>[ -d FILE ] 如果 FILE 存在且是一个目录则为真。</p><p>[ -e FILE ] 如果 FILE 存在则为真。 </p><p>[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</p><p>[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</p><p>[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。</p><p>[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</p><p>[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</p><p>[ -r FILE ] 如果 FILE 存在且是可读的则为真。 </p><p>[ -s FILE ] 如果 FILE 存在且大小不为0则为真。 </p><p>[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。</p><p>[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</p><p>[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。</p><p>[ -x FILE ] 如果 FILE 存在且是可执行的则为真。 </p><p>[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 </p><p>[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</p><p>[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 </p><p>[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 </p><p>[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 </p><p>[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2,</p><p>or 如果 FILE1 exists and FILE2 does not则为真。 </p><p>[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 </p><p>[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</p><p>[ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 </p><p>[ -z STRING ] “STRING” 的长度为零则为真。 </p><p>[ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 </p><p>[ STRING1 == STRING2 ] 如果2个字符串相同。</p><p> “=” may be used instead of “==” for strict POSIX compliance则为真。 </p><p>[ STRING1 != STRING2 ] 如果字符串不相等则为真。 </p><p>[ STRING1 &lt; STRING2 ]</p><p>如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 </p><p>[ STRING1 &gt; STRING2 ]</p><p>如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 </p><p>[ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[ -a FILE ] 如果 FILE 存在则为真。 &lt;/p&gt;
&lt;p&gt;[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 &lt;/p&gt;
&lt;p&gt;[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 &lt;/p&gt;
&lt;p&gt;[ -d FILE ] 如果
      
    
    </summary>
    
      <category term="shell" scheme="https://bummingboy.top/categories/shell/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
      <category term="if" scheme="https://bummingboy.top/tags/if/"/>
    
  </entry>
  
  <entry>
    <title>CommonJS vs ES6 import/export</title>
    <link href="https://bummingboy.top/2018/01/05/commonjs%20vs%20ES6%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>https://bummingboy.top/2018/01/05/commonjs vs ES6模块机制/</id>
    <published>2018-01-05T08:59:56.000Z</published>
    <updated>2018-07-03T12:00:55.844Z</updated>
    
    <content type="html"><![CDATA[<p>js 几种流行的模块机制中, node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD, seajs 不了解不过多解释.<br><a id="more"></a><br>首先明确一下 </p><ul><li>import/export 对应ES6的模块机制 用法(<a href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export</a>)或(<a href="http://es6.ruanyifeng.com/#docs/module-loader%23ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" title="http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" target="_blank" rel="external">http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82</a>)</li><li>require/module.exports()对应CommonJS的模块机制 用法(<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="external">http://javascript.ruanyifeng.com/nodejs/module.html</a>)</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 (因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。)</li></ul><h4 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h4><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。<br>    <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attribute">id</span>: <span class="string">'...'</span>,</div><div class="line">  exports: &#123; ... &#125;,</div><div class="line">  <span class="selector-tag">loaded</span>: <span class="selector-tag">true</span>,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p><p>以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。<br>    delete require.cache[‘path/to/config’]<br>    config = require(‘path/to/config’))</p><h4 id="ES6加载原理"><a href="#ES6加载原理" class="headerlink" title="ES6加载原理"></a>ES6加载原理</h4><p>JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><h3 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h3><h4 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h4><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。<br>让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.done = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'在 a.js 之中，b.done = %j'</span>, b.done);</div><div class="line">exports.done = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.js 执行完毕'</span>);</div></pre></td></tr></table></figure></code></pre><p>上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。<br>再看b.js的代码。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.done = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'在 b.js 之中，a.done = %j'</span>, a.done);</div><div class="line">exports.done = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 执行完毕'</span>);</div></pre></td></tr></table></figure></code></pre><p>上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。<br>a.js已经执行的部分，只有一行。</p><pre><code><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exports.<span class="keyword">done</span> = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></code></pre><p>因此，对于b.js来说，它从a.js只输入一个变量done，值为false。<br>然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</div><div class="line"><span class="keyword">var</span> b =  <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'在 main.js 之中, a.done=%j, b.done=%j'</span>, a.done, b.done);</div></pre></td></tr></table></figure></code></pre><p>执行main.js，运行结果如下。</p><pre><code><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node main.js</div><div class="line"></div><div class="line">在 <span class="selector-tag">b</span><span class="selector-class">.js</span> 之中，<span class="selector-tag">a</span><span class="selector-class">.done</span> = false</div><div class="line"><span class="selector-tag">b</span><span class="selector-class">.js</span> 执行完毕</div><div class="line">在 <span class="selector-tag">a</span><span class="selector-class">.js</span> 之中，<span class="selector-tag">b</span><span class="selector-class">.done</span> = true</div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.js</span> 执行完毕</div><div class="line">在 main<span class="selector-class">.js</span> 之中, <span class="selector-tag">a</span>.done=true, <span class="selector-tag">b</span>.done=true</div></pre></td></tr></table></figure></code></pre><p>上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。<br>    <figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exports.<span class="keyword">done</span> = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。<br>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>); <span class="comment">// 安全的写法</span></div><div class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'a'</span>).foo; <span class="comment">// 危险的写法</span></div><div class="line"></div><div class="line">exports.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a.foo(<span class="string">'good'</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">exports.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> foo(<span class="string">'bad'</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></code></pre><p>上面代码中，如果发生循环加载，require(‘a’).foo的值很可能后面会被改写，改用require(‘a’)会更保险一点。</p><h4 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h4><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。<br>请看下面这个例子。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(bar);</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">'foo'</span>;</div><div class="line"></div><div class="line"><span class="comment">// b.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(foo);</div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">'bar'</span>;</div></pre></td></tr></table></figure></code></pre><p>上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。</p><pre><code><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node --experimental-modules <span class="selector-tag">a</span>.mjs</div><div class="line"><span class="selector-tag">b</span>.mjs</div><div class="line">ReferenceError: foo is not defined</div></pre></td></tr></table></figure></code></pre><p>上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？</p><p>让我们一行行来看，ES6循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.js。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。</p><p>解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(bar());</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'foo'</span> &#125;</div><div class="line"><span class="keyword">export</span> &#123;foo&#125;;</div><div class="line"></div><div class="line"><span class="comment">// b.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">'./a'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'b.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(foo());</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'bar'</span> &#125;</div><div class="line"><span class="keyword">export</span> &#123;bar&#125;;</div></pre></td></tr></table></figure></p><p>这时再执行a.mjs就可以得到预期结果。<br>    <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node --experimental-modules <span class="selector-tag">a</span>.mjs</div><div class="line"><span class="selector-tag">b</span>.mjs</div><div class="line">foo</div><div class="line"><span class="selector-tag">a</span>.mjs</div><div class="line">bar</div></pre></td></tr></table></figure></p><p>这是因为函数具有提升作用，在执行import {bar} from’./b’时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.mjs</span></div><div class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">'./b'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'a.mjs'</span>);</div><div class="line"><span class="built_in">console</span>.log(bar());</div><div class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'foo'</span>;</div><div class="line"><span class="keyword">export</span> &#123;foo&#125;;</div></pre></td></tr></table></figure></p><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。<br>我们再来看 ES6 模块加载器SystemJS给出的一个例子。</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">'./odd'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">'./even'</span>;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><p>上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。</p><p>运行上面这段代码，结果如下。<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> babel-node</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> import * as m from <span class="string">'./even.js'</span>;</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.even(10);</span></div><div class="line">true</div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.counter</span></div><div class="line">6</div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.even(20)</span></div><div class="line">true</div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.counter</span></div><div class="line">17</div></pre></td></tr></table></figure></p><p>上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// even.js</span></div><div class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">'./odd'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">exports.counter = counter;</div><div class="line">exports.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  counter++;</div><div class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// odd.js</span></div><div class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">'./even'</span>).even;</div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> node</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> var m = require(<span class="string">'./even'</span>);</span></div><div class="line"><span class="meta">&gt;</span><span class="bash"> m.even(10)</span></div><div class="line">TypeError: even is not a function</div></pre></td></tr></table></figure></p><h3 id="import-vs-require"><a href="#import-vs-require" class="headerlink" title="import  vs require()"></a>import  vs require()</h3><h4 id="遵循规范"><a href="#遵循规范" class="headerlink" title="遵循规范"></a>遵循规范</h4><pre><code>- require 是 AMD规范引入方式- import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</code></pre><h4 id="调用时间"><a href="#调用时间" class="headerlink" title="调用时间"></a>调用时间</h4><pre><code>- require是运行时调用，所以require理论上可以运用在代码的任何地方- import是编译时调用，所以必须放在文件开头</code></pre><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><pre><code>- require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量- import是解构过程，node v8引擎还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 几种流行的模块机制中, node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD, seajs 不了解不过多解释.&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="CommonJS" scheme="https://bummingboy.top/tags/commonjs/"/>
    
      <category term="ES6" scheme="https://bummingboy.top/tags/es6/"/>
    
      <category term="import/export" scheme="https://bummingboy.top/tags/import-export/"/>
    
  </entry>
  
  <entry>
    <title>Mongodb 更换数据目录</title>
    <link href="https://bummingboy.top/2017/12/19/Mongodb%20%E6%9B%B4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
    <id>https://bummingboy.top/2017/12/19/Mongodb 更换数据目录/</id>
    <published>2017-12-19T10:11:04.000Z</published>
    <updated>2018-07-03T10:26:18.138Z</updated>
    
    <content type="html"><![CDATA[<p>这不是数据迁移, 迁移的话通常用mongodump, 另说.<br>本篇是因为服务器主分区只有20G, 数据库文件数据量大了, 主分区不够了需要迁移到新挂载的数据盘.挂载的知识请看().<br>下面是思路:</p><ol><li>查看MongoDB的状态, 终止数据库运行</li><li>查看数据库数据, 日志路径</li><li>压缩备份, 拷贝到新目录</li><li>重启</li></ol><h3 id="1-查看MongoDB状态"><a href="#1-查看MongoDB状态" class="headerlink" title="1.查看MongoDB状态"></a>1.查看MongoDB状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mongo</span></div><div class="line">...</div><div class="line"><span class="meta">&gt;</span><span class="bash"></span></div></pre></td></tr></table></figure><p>连接成功则表示mongod已经运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$<span class="built_in"> service </span>mongod status </div><div class="line">&gt; stop/waiting 表示不是通过service运行的</div><div class="line">&gt; start/running 表示通过service运行的</div><div class="line"></div><div class="line">$<span class="built_in"> service </span>mongod stop 停止</div><div class="line">$<span class="built_in"> service </span>mongod start/restart 重启</div><div class="line"><span class="keyword">or</span></div><div class="line">$ ps -aux | grep mongo</div><div class="line">&gt;root      7695  0.3 13.5 29712004 1109256 ?    Sl   Dec14   2:37 mongod --fork --logpath /var/log/mongodb/mongodb.log --dbpath /var/lib/mongodb</div><div class="line"> ubuntu   24526  0.0  0.0  10468  2232 pts/1    R+   10:43   0:00 grep <span class="attribute">--color</span>=auto mongo</div><div class="line">表示mongod服务是通过--fork 形式手动启动的</div><div class="line"></div><div class="line">$ kill PID(7695) 终止服务</div></pre></td></tr></table></figure><h3 id="2-查看数据库数据-日志路径"><a href="#2-查看数据库数据-日志路径" class="headerlink" title="2.查看数据库数据, 日志路径"></a>2.查看数据库数据, 日志路径</h3><ul><li><p>service 启动的mongod服务<br>此时通过/etc/init.d/mongodb启动服务, 默认使用/etc/mongod.conf配置文件</p></li><li><p>mongod –fork 启动mongod服务<br>默认也会使用/etc/mongod.conf配置文件, 但是当指定dbpath logpath后以指定为准</p><p>mongod.conf文件</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="symbol">storage:</span></div><div class="line"><span class="symbol">dbPath:</span> /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span></span></div><div class="line"><span class="symbol">journal:</span></div><div class="line">  <span class="symbol">enabled:</span> <span class="literal">true</span></div><div class="line">...</div><div class="line"><span class="symbol">systemLog:</span></div><div class="line"><span class="symbol">destination:</span> file</div><div class="line"><span class="symbol">logAppend:</span> <span class="literal">true</span></div><div class="line"><span class="symbol">path:</span> /var/log/mongodb/mongod.log</div></pre></td></tr></table></figure></li></ul><p>  修改对应路径:<br>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="string">storage:</span></div><div class="line"><span class="string">dbPath:</span> <span class="regexp">/data/</span>db/mongodb</div><div class="line"><span class="string">journal:</span></div><div class="line"><span class="symbol">  enabled:</span> <span class="literal">true</span></div><div class="line">...</div><div class="line"><span class="string">systemLog:</span></div><div class="line"><span class="string">destination:</span> file</div><div class="line"><span class="string">logAppend:</span> <span class="literal">true</span></div><div class="line"><span class="string">path:</span> <span class="regexp">/data/</span>db<span class="regexp">/log/</span>mongod.log</div></pre></td></tr></table></figure></p><p>  本例中前人通过指定logpath dbpath的方式启动服务</p><h3 id="3-压缩备份-拷贝到新目录"><a href="#3-压缩备份-拷贝到新目录" class="headerlink" title="3.压缩备份, 拷贝到新目录"></a>3.压缩备份, 拷贝到新目录</h3><p>  知道了原来的数据和日志位置, 那么可以压缩备份原来的数据了, 本例以/data/db/mongodb为新的数据目录<br>  /data/db/log为新的日志目录</p>  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd /var/<span class="class"><span class="keyword">lib</span></span></div><div class="line">$ tar -zcvf mongodb_backup_xxxxxx.tar.gz /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span></span></div><div class="line">$ cp -ra /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span> /<span class="title">data</span>/<span class="title">db</span>/<span class="title">mongodb</span></span></div><div class="line">$ rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">mongodb</span></span></div></pre></td></tr></table></figure><h3 id="4-重启mongod服务"><a href="#4-重启mongod服务" class="headerlink" title="4.重启mongod服务"></a>4.重启mongod服务</h3>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo<span class="built_in"> service </span>mongod start</div></pre></td></tr></table></figure><p>  or<br>  <figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mongod --dbpath /<span class="keyword">data</span>/db/mongodb --logpath /<span class="keyword">data</span>/db/<span class="built_in">log</span>/mongod.<span class="built_in">log</span></div></pre></td></tr></table></figure></p><h3 id="问题-启动失败"><a href="#问题-启动失败" class="headerlink" title="问题: 启动失败"></a>问题: 启动失败</h3><ul><li><p>查看新数据目录权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /data/db</span></div><div class="line"><span class="meta">$</span><span class="bash"> ll</span></div></pre></td></tr></table></figure><p>直接拷贝 已经是mongodb:mongodb 用户组了</p></li><li><p>查看日志 访问mongodb-27017.sock 无权限</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="params">...</span></div><div class="line">Failed <span class="keyword">to</span> unlink socket file /tmp/mongodb<span class="number">-27017.</span>sock errno:<span class="number">1</span> Operation <span class="literal">not</span> permitted</div><div class="line"><span class="params">...</span></div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></div><div class="line"><span class="meta">$</span><span class="bash"> ll</span></div><div class="line"><span class="meta">$</span><span class="bash"> rm -rf mongodb-27017.sock</span></div></pre></td></tr></table></figure><p>重新启动<br>重新查看 mongodb-27017.sock 文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">ls</span> - lat <span class="string">/tmp/mongodb-27017.sock</span></div><div class="line">&gt;</div><div class="line">srwx<span class="params">------</span> 1 mongodb mongodb 0 Dec 14 21<span class="function">:12</span> <span class="string">/tmp/mongodb-27017.sock</span></div></pre></td></tr></table></figure></li></ul><p>  注: 启动相关日志  还是在/var/log/mongodb</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这不是数据迁移, 迁移的话通常用mongodump, 另说.&lt;br&gt;本篇是因为服务器主分区只有20G, 数据库文件数据量大了, 主分区不够了需要迁移到新挂载的数据盘.挂载的知识请看().&lt;br&gt;下面是思路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看MongoDB的状态, 终止数据库运
      
    
    </summary>
    
      <category term="数据库" scheme="https://bummingboy.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="https://bummingboy.top/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>npm私有仓库搭建及使用 (verdaccio)</title>
    <link href="https://bummingboy.top/2017/12/19/npm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%20(verdaccio)/"/>
    <id>https://bummingboy.top/2017/12/19/npm私有仓库搭建及使用 (verdaccio)/</id>
    <published>2017-12-19T10:10:56.000Z</published>
    <updated>2018-07-03T10:26:34.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载及搭建"><a href="#下载及搭建" class="headerlink" title="下载及搭建"></a>下载及搭建</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">$</span> <span class="string">npm</span> <span class="string">install</span> <span class="bullet">-g</span> <span class="string">verdaccio</span></div><div class="line"><span class="string">$</span> <span class="string">verdaccio</span></div><div class="line">  <span class="string">warn</span> <span class="meta">---</span> <span class="string">config</span> <span class="string">file</span>  <span class="bullet">-</span> <span class="string">/home/ubuntu/.config/verdaccio/config.yaml</span></div><div class="line">  <span class="string">warn</span> <span class="meta">---</span> <span class="string">http</span> <span class="string">address</span> <span class="bullet">-</span> <span class="attr">http://localhost:4873/</span> <span class="bullet">-</span> <span class="string">verdaccio/2.3.2</span></div></pre></td></tr></table></figure><p>终端显示默认配置文件和verdaccio工作端口, 浏览器打开<a href="http://localhost:4873/" target="_blank" rel="external">http://localhost:4873/</a> ，页面如下<br><img src="/images/A66C4A708AB44ED80A1D2650F6217313.jpg" alt=""></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>  default config:<br>    <figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="attr">storage:</span> <span class="string">./storage</span>      <span class="comment"># 设置托管或缓存包的存放目录</span></div><div class="line"><span class="attr">auth:</span>                   <span class="comment"># 权限控制</span></div><div class="line"><span class="attr">  htpasswd:</span>             <span class="comment"># 启用 htpasswd 插件管理权限</span></div><div class="line"><span class="attr">    file:</span> <span class="string">./htpasswd</span>    <span class="comment"># 制定 htpasswd 文件路径，htpasswd 中存储者用户名和加密过的秘钥</span></div><div class="line"><span class="attr">    max_users:</span> <span class="number">1000</span>     <span class="comment"># 最多允许注册用户数</span></div><div class="line"><span class="attr">uplinks:</span>                <span class="comment"># 设置外部仓储，如果 verdaccio 找不到请求的包（非 verdaccio 托管），就会查找外部仓储</span></div><div class="line"><span class="attr">  npmjs:</span></div><div class="line"><span class="attr">    url:</span> <span class="attr">https://registry.npmjs.org/</span></div><div class="line"><span class="attr">packages:</span></div><div class="line">  <span class="string">'@*/*'</span><span class="string">:</span></div><div class="line"><span class="attr">    access:</span> <span class="string">$all</span></div><div class="line"><span class="attr">    publish:</span> <span class="string">$authenticated</span></div><div class="line"><span class="attr">    proxy:</span> <span class="string">npmjs</span></div><div class="line">  <span class="string">'**'</span><span class="string">:</span></div><div class="line"><span class="attr">    proxy:</span> <span class="string">npmjs</span></div><div class="line"><span class="attr">logs:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">&#123;type:</span> <span class="string">stdout,</span> <span class="attr">format:</span> <span class="string">pretty,</span> <span class="attr">level:</span> <span class="string">http&#125;</span></div><div class="line"><span class="attr">web:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  title:</span> <span class="string">Verdaccio</span></div><div class="line"><span class="attr">  logo:</span> <span class="string">logo.png</span></div><div class="line"><span class="attr">publish:</span></div><div class="line"><span class="attr">  allow_offline:</span> <span class="literal">false</span>    <span class="comment"># 是否支持离线发布 默认false</span></div><div class="line"><span class="attr">url_prefix:</span> <span class="attr">https://dev.company.local/verdaccio/</span> </div><div class="line"><span class="comment"># 设置资源文件路径前缀。默认不需要设置，但如果使用 nginx 代理并改写了请求路径，就需要指定了。</span></div><div class="line"><span class="attr">max_body_size:</span> <span class="number">1</span><span class="string">mb</span>        <span class="comment"># 默认JSON document size 1mb</span></div><div class="line"><span class="attr">listen:</span>                   <span class="comment"># 设置服务运行地址端口</span></div><div class="line"><span class="comment"># - localhost:4873            # default value</span></div><div class="line"><span class="comment"># - http://localhost:4873     # same thing</span></div><div class="line"><span class="comment"># - 0.0.0.0:4873              # listen on all addresses (INADDR_ANY)</span></div><div class="line"><span class="comment"># - https://example.org:4873  # if you want to use https</span></div><div class="line"><span class="comment"># - [::1]:4873                # ipv6</span></div><div class="line"><span class="comment"># - unix:/tmp/verdaccio.sock    # unix socket</span></div></pre></td></tr></table></figure></p><ul><li>uplinks常用仓储有<pre><code><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">npmjs:</span></div><div class="line"><span class="string">url:</span> <span class="string">https:</span><span class="comment">//registry.npmjs.org</span></div><div class="line"><span class="string">yarnjs:</span></div><div class="line"><span class="string">url:</span> <span class="string">https:</span><span class="comment">//registry.yarnpkg.com</span></div><div class="line"><span class="string">cnpmjs:</span></div><div class="line"><span class="string">url:</span> <span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></div></pre></td></tr></table></figure></code></pre></li></ul><ul><li><p>packages: 包访问或发布控制</p><ul><li><p>{regexp}: 包名匹配正则。<br>access: 访问控制，可选值有$all（用户不限制）, $anonymous（用户不限制）, $authenticated（所有登录用户）, username( 用户名，需指定具体用户，可指定多个用户，用户间空格隔开，如 secret super-secret-area ultra-secret-area)。尽管@all, @anonymous, all, undefined,<br>publish: 发布控制，配置请参考 access<br>proxy: 代理控制，设置的值必选现在 uplinks 中定义。</p></li><li><p>常用的包名正则有：</p>   <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">*</span><span class="symbol">*</span>         <span class="comment"># 匹配任意包</span></div><div class="line"><span class="meta">@*/*</span>       <span class="comment"># 匹配任意 scope 包</span></div><div class="line"><span class="meta">@npmuser/*</span> <span class="comment"># 匹配 scope 为 npmuser 的包</span></div><div class="line">npmuser-<span class="symbol">*</span>  <span class="comment"># 匹配包名有 npmuser- 前缀的包</span></div></pre></td></tr></table></figure></li></ul></li></ul><pre><code>包名正则规范通 gitignore 一致，verdaccio 内部使用minimatch实现的，如果需要书写更复杂的正则，可以参考 minimatch 文档。</code></pre><p>详情(<a href="https://github.com/verdaccio/verdaccio/blob/master/wiki/config.md" target="_blank" rel="external">https://github.com/verdaccio/verdaccio/blob/master/wiki/config.md</a>)</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> yarn/npm init</span></div><div class="line">... input some info</div></pre></td></tr></table></figure><h4 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h4><h4 id="注册仓库并添加用户"><a href="#注册仓库并添加用户" class="headerlink" title="注册仓库并添加用户"></a>注册仓库并添加用户</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">set</span> registry <span class="comment">ip</span>/hostname</div><div class="line">npm adduser --registry ip/<span class="comment">hostname</span></div><div class="line">input: username/password/email</div></pre></td></tr></table></figure><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> yarn/npm pulish</span></div><div class="line">... input some info</div></pre></td></tr></table></figure><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ yarn add package-name / npm <span class="keyword">install</span> <span class="keyword">package</span>-<span class="keyword">name</span></div><div class="line"><span class="keyword">or</span></div><div class="line">$ yarn / npm logout</div><div class="line">$ (yarn <span class="keyword">add</span> <span class="keyword">package</span>-<span class="keyword">name</span> / npm <span class="keyword">install</span> <span class="keyword">package</span>-<span class="keyword">name</span>) <span class="comment">--registry http://localhost:4873</span></div></pre></td></tr></table></figure><h3 id="私有包"><a href="#私有包" class="headerlink" title="私有包"></a>私有包</h3><p>现在配置org-前缀的包全部私有</p><p>只需在配置文件 config.yml 中 package 段添加配置</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'org-*'</span>:</div><div class="line">  access: $authenticated</div><div class="line">  publish: $authenticated</div><div class="line">  proxy: npmjs</div></pre></td></tr></table></figure><p>这里我们配置了所有org-前缀的包只有注册用户才能访问和发布。</p><p>你也可以对 publish 做进一步限制，只有 npmuser 用户才能发布<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'org-*'</span><span class="string">:</span></div><div class="line"><span class="attr">  access:</span> <span class="string">$authenticated</span></div><div class="line"><span class="attr">  publish:</span> <span class="string">npmuser</span></div><div class="line"><span class="attr">  proxy:</span> <span class="string">npmjs</span></div></pre></td></tr></table></figure></p><p>注意修改配置后要重启 verdaccio</p><h3 id="scope-包"><a href="#scope-包" class="headerlink" title="scope 包"></a>scope 包</h3><p>其实加前缀并不是一种很好组织包的方式，npm 提供了更好的名称空间策略 scope</p><p>scope 包包名格式：@scope-name/pkg-name</p><p>初始化包时指定 scope<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init <span class="comment">--scope org</span></div></pre></td></tr></table></figure></p><p>我们可以为 scope 绑定一个仓储<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm login --registry=http://<span class="keyword">reg</span>.example.<span class="keyword">com</span> --scope=@org</div><div class="line">npm config <span class="keyword">set</span> @or<span class="variable">g:registry</span> http://<span class="keyword">reg</span>.example.<span class="keyword">com</span></div></pre></td></tr></table></figure></p><p>这样凡是碰到 scope 为 @org 的包，npm 将自动切换作业仓储到 scope 绑定的仓储，这提供了一种多仓储策略。</p><p>scope 私有包配置<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'@org/*'</span>:</div><div class="line">  access: $authenticated</div><div class="line">  publish: $authenticated</div><div class="line">  proxy: npmjs</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载及搭建&quot;&gt;&lt;a href=&quot;#下载及搭建&quot; class=&quot;headerlink&quot; title=&quot;下载及搭建&quot;&gt;&lt;/a&gt;下载及搭建&lt;/h3&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="Node" scheme="https://bummingboy.top/categories/node/"/>
    
    
      <category term="npm" scheme="https://bummingboy.top/tags/npm/"/>
    
      <category term="私有仓库" scheme="https://bummingboy.top/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>firewall 使用</title>
    <link href="https://bummingboy.top/2017/12/19/firewall%20%E4%BD%BF%E7%94%A8/"/>
    <id>https://bummingboy.top/2017/12/19/firewall 使用/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T10:25:13.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h3><h4 id="运行、停止、禁用firewalld-状态"><a href="#运行、停止、禁用firewalld-状态" class="headerlink" title="运行、停止、禁用firewalld 状态"></a>运行、停止、禁用firewalld 状态</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">启动：<span class="keyword"> system</span>ctl start firewalld</div><div class="line">查看状态：<span class="keyword"> system</span>ctl status firewalld </div><div class="line">停止：<span class="keyword"> system</span>ctl disable firewalld</div><div class="line">禁用：<span class="keyword"> system</span>ctl stop firewalld</div></pre></td></tr></table></figure><h4 id="查看firewall是否运行"><a href="#查看firewall是否运行" class="headerlink" title="查看firewall是否运行"></a>查看firewall是否运行</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">下面两个命令都可以</div><div class="line">systemctl status firewalld.service</div><div class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --state</span></div></pre></td></tr></table></figure><h3 id="2-服务管理"><a href="#2-服务管理" class="headerlink" title="2. 服务管理"></a>2. 服务管理</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">启动一个服务：<span class="string">systemctl </span><span class="string">start </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">关</span>闭一个服务：<span class="string">systemctl </span><span class="string">stop </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">重</span>启一个服务：<span class="string">systemctl </span><span class="string">restart </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">显</span>示一个服务的状态：<span class="string">systemctl </span><span class="string">status </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">在</span>开机时启用一个服务：<span class="string">systemctl </span><span class="string">enable </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">在</span>开机时禁用一个服务：<span class="string">systemctl </span><span class="string">disable </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">查</span>看服务是否开机启动：<span class="string">systemctl </span><span class="string">is-enabled </span><span class="string">firewalld.</span><span class="string">service</span></div><div class="line"><span class="string">查</span>看已启动的服务列表：<span class="string">systemctl </span><span class="built_in">list-unit-files|grep</span> <span class="string">enabled</span></div><div class="line"><span class="string">查</span>看启动失败的服务列表：<span class="string">systemctl </span><span class="built_in">--failed</span></div></pre></td></tr></table></figure><h4 id="添加一个服务到firewalld"><a href="#添加一个服务到firewalld" class="headerlink" title="添加一个服务到firewalld"></a>添加一个服务到firewalld</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --add-service=http //http换成想要开放的service</span></div><div class="line"><span class="bash">这样添加的service当前立刻生效，但系统下次启动就失效，可以测试使用。要永久开发一个service，加上 --permanent</span></div><div class="line"><span class="bash"></span></div><div class="line"><span class="bash">firewall-cmd --permanent --add-service=http</span></div></pre></td></tr></table></figure><p>如果要添加的端口并没有服务对应<br>就要新建一个服务，在/usr/lib/firewalld/services，随便拷贝一个xml文件到一个新名字，比如myservice.xml,把里面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span><span class="meta">?&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">short</span>&gt;</span>Transmission-client<span class="tag">&lt;/<span class="name">short</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Transmission is a lightweight GTK+ BitTorrent client.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">"tcp"</span> <span class="attr">port</span>=<span class="string">"51413"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure><p>short改为想要名字（这个名字只是为了人来阅读，没有实际影响。重要的是修改 protocol和port。修改完保存。我的经验是这是要重启firewalld服务，systemctl restart firewalld.service，否则可能提示找不到刚才新建的service。然后把新建的service添加到<br>firewalld<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --permanent --add-service=myservice</span></div><div class="line"><span class="bash">重启firewalld 生效</span></div></pre></td></tr></table></figure></p><h3 id="3-配置firewalld-cmd"><a href="#3-配置firewalld-cmd" class="headerlink" title="3. 配置firewalld-cmd"></a>3. 配置firewalld-cmd</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">查看版本： firewall-<span class="keyword">cmd</span><span class="bash"> --version</span></div><div class="line"><span class="bash">查看帮助： firewall-cmd --<span class="built_in">help</span></span></div><div class="line"><span class="bash">显示状态： firewall-cmd --state</span></div><div class="line"><span class="bash">查看所有打开的端口： firewall-cmd --zone=public --list-ports</span></div><div class="line"><span class="bash">更新防火墙规则： firewall-cmd --reload</span></div><div class="line"><span class="bash">查看区域信息:  firewall-cmd --get-active-zones</span></div><div class="line"><span class="bash">查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0</span></div><div class="line"><span class="bash">拒绝所有包：firewall-cmd --panic-on</span></div><div class="line"><span class="bash">取消拒绝状态： firewall-cmd --panic-off</span></div><div class="line"><span class="bash">查看是否拒绝： firewall-cmd --query-panic</span></div><div class="line"><span class="bash"> </span></div><div class="line"><span class="bash">那怎么开启一个端口呢</span></div><div class="line"><span class="bash">添加</span></div><div class="line"><span class="bash">firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）</span></div><div class="line"><span class="bash">重新载入</span></div><div class="line"><span class="bash">firewall-cmd --reload</span></div><div class="line"><span class="bash">查看</span></div><div class="line"><span class="bash">firewall-cmd --zone= public --query-port=80/tcp</span></div><div class="line"><span class="bash">删除</span></div><div class="line"><span class="bash">firewall-cmd --zone= public --remove-port=80/tcp --permanent</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-基础使用&quot;&gt;&lt;a href=&quot;#1-基础使用&quot; class=&quot;headerlink&quot; title=&quot;1. 基础使用&quot;&gt;&lt;/a&gt;1. 基础使用&lt;/h3&gt;&lt;h4 id=&quot;运行、停止、禁用firewalld-状态&quot;&gt;&lt;a href=&quot;#运行、停止、禁用firewal
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="firewall" scheme="https://bummingboy.top/tags/firewall/"/>
    
  </entry>
  
  <entry>
    <title>Linux 修改系统时间的三种方法</title>
    <link href="https://bummingboy.top/2017/12/19/Linux%20%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://bummingboy.top/2017/12/19/Linux 修改系统时间的三种方法/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T10:26:11.609Z</updated>
    
    <content type="html"><![CDATA[<p>三种方法:</p><p>一、修改时区<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cp /etc/localtime /etc/localtime.bak</span></div><div class="line"><span class="comment"># ln -svf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></div><div class="line">修改为中国的东八区</div><div class="line"></div><div class="line"><span class="comment"># cat /etc/sysconfig/clock</span></div><div class="line">ZONE=<span class="string">"Asia/Shanghai"</span></div><div class="line">UTC=false</div><div class="line">ARC=false</div><div class="line"></div><div class="line"><span class="comment"># 与时间服务器同步</span></div><div class="line">ntpdate 0.centos.pool.ntp.org</div></pre></td></tr></table></figure></p><p>二、配置新的时间<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">日期设定：</div><div class="line"><span class="meta">#</span><span class="bash"> date -s 2013/09/26</span></div><div class="line"></div><div class="line">时间设定：</div><div class="line"><span class="meta">#</span><span class="bash"> date -s 11:47:06</span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"12:00:00 2013-12-06"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"12:00:00 20131206"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"2013-12-06 12:00:00"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> date -s <span class="string">"20131206 12:00:00"</span></span></div><div class="line"></div><div class="line">date 是显示的系统OS时间</div><div class="line">clock 是显示Bios的时间</div><div class="line">查看硬件时间（BIOS的）：</div><div class="line">hwclock [-rw]   </div><div class="line">  -r   查看现有BIOS时间，默认为－r参数</div><div class="line">  -w   将现在的linux系统时间写入BIOS中</div><div class="line">  -s   (systohc)将硬件时间调整为和目前的系统时间一样</div><div class="line"><span class="meta">#</span><span class="bash"> hwclock -s </span></div><div class="line"><span class="meta">#</span><span class="bash"> hwclock -w</span></div><div class="line"> 当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> hwclock</span></div><div class="line">2013年09月26日 星期四 11时49分10秒 -1.002805 seconds</div><div class="line">修改系统时间（date）后，要同步BIOS时钟，强制把系统时间写入CMOS：</div><div class="line"><span class="meta">#</span><span class="bash"> clock -w </span></div><div class="line">或者</div><div class="line"><span class="meta">#</span><span class="bash"> hwclock -w</span></div></pre></td></tr></table></figure></p><p>三、实现Internet时间同步（这里可以忽略上面两步）<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">方法<span class="number">1.</span> 开机的时候自动网络校时(首先有自己的时间服务器)： </div><div class="line"># cat /etc/rc.d/rc.local </div><div class="line">/usr/sbin/ntpdate -u <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span>;/sbin/hwclock -w</div><div class="line">后面的ip对应的是局域网内需要时间相同同步的主机。</div><div class="line"></div><div class="line">方法<span class="number">2.</span> 设定计划任务</div><div class="line"># yum -y install ntpdate # 安装时间同步命令</div><div class="line"># crontab -l(以下方法任选其一)</div><div class="line">*/<span class="number">5</span> * * * * root ntpdate <span class="number">210.72</span><span class="number">.145</span><span class="number">.44</span>;hwclock -w #每隔半个小时与中国国家授时中心服务器同步一次时间</div><div class="line">*/<span class="number">5</span> * * * * root ntpdate asia.pool.ntp.org;hwclock -w</div><div class="line">*/<span class="number">5</span> * * * * root ntpdate <span class="number">0.</span>centos.pool.ntp.org;hwclock -w</div><div class="line"></div><div class="line">手动和时间服务器校准时间：</div><div class="line"><span class="number">1.</span>首先关闭ntpd服务：</div><div class="line"># service ntpd stop</div><div class="line"></div><div class="line"><span class="number">2.</span>然后和时间服务器校准：</div><div class="line"># ntpdate asia.pool.ntp.org</div><div class="line"></div><div class="line"><span class="number">3.</span>同步BIOS时间：</div><div class="line"># hwclock -w</div><div class="line"></div><div class="line"><span class="number">4.</span>校准后然后开启ntpd服务</div><div class="line"># service ntpd start</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三种方法:&lt;/p&gt;
&lt;p&gt;一、修改时区&lt;br&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://bummingboy.top/tags/linux/"/>
    
      <category term="系统时间" scheme="https://bummingboy.top/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置</title>
    <link href="https://bummingboy.top/2017/12/19/Nginx%20%E9%85%8D%E7%BD%AE/"/>
    <id>https://bummingboy.top/2017/12/19/Nginx 配置/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T10:26:26.784Z</updated>
    
    <content type="html"><![CDATA[<p>如果是使用apt-get安装的nginx,配置文件目录在:<br>  /etc/nginx/<br>cd到这个目录之后,ls查看所有文件:</p><ul><li><p>nginx.conf<br>  这个是nginx的主配置文件,里面包含了当前目录的所有配置文件,<br>只不过有的是注释状态,需要的时候自行开启(后面几个常用的)</p></li><li><p>conf.d<br>这是一个目录,里面可以写我们自己自定义的配置文件,文件结尾一<br>定是.conf才可以生效(当然也可以通过修改nginx.conf来取消这个限制)</p></li><li><p>sites-enabled<br>这里面的配置文件其实就是sites-available里面的配置文件的软<br>连接,但是由于nginx.conf默认包含的是这个文件夹,所以我们在<br>sites-available里面建立了新的站点之后,还要建立个软连接到sites-enabled里面才行</p></li><li><p>sites-available<br>这里是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机</p></li></ul><h3 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h3><p>Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.<br>为什么要配置多站点:</p><p>当我们有了一个服务器之后,为了不浪费服务器的资源,我们可以在一个服务器上放置多个网站项目,它们共同使用80端口,通过不同的servername来区分不同的网站项目,在实际上线的项目中,这个servername就是我们的域名啦<br>具体配置(我们只举例一个,多个重复操作就行):</p><p>默认已经有一个站点了,就是defalt,在sites-available里面有一个default文件,就是默认站点的配置,servername是localhost不建议直接修改这个默认站点,我们可以复制一个:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> airobot &#123;</div><div class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:3001</span>;</div><div class="line">    <span class="attribute">keepalive</span> <span class="number">64</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="comment">#listen 80;</span></div><div class="line">    <span class="attribute">listen</span> <span class="number">443</span>;</div><div class="line">    <span class="attribute">server_name</span> <span class="regexp">*.ai-robotics.cn</span>;</div><div class="line">    <span class="comment">#ai-robotics.cn www.ai-robotics.cn;</span></div><div class="line">    <span class="comment">#access_log /usr/local/log/test.log;</span></div><div class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/1_www.ai-robotics.cn_bundle.crt;</div><div class="line">    <span class="attribute">ssl_certificate_key</span> /etc/nginx/2_www.ai-robotics.cn.key;</div><div class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</div><div class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</div><div class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</div><div class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;    </div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="number">443</span>;</div><div class="line">          <span class="attribute">proxy_set_header</span> Host  <span class="variable">$http_host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> X-Nginx-Proxy <span class="literal">true</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</div><div class="line">        <span class="attribute">proxy_pass</span>      https://airobot;</div><div class="line">          <span class="attribute">client_max_body_size</span> <span class="number">128M</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ln -s <span class="regexp">/etc/</span>ngix<span class="regexp">/sites-available/</span>web1.com <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>web1.com</div><div class="line">$ nginx -s reload</div></pre></td></tr></table></figure><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li>正向代理:</li></ul><p>正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。<br>主要为了越过局域网内的防火墙实现访问网站</p><ul><li>反向代理:</li></ul><p>反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。为了将防火墙后面的服务器提供给Internet用户访问也可以实现负载均衡,动静分离,url策略</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>前期准备:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nginx服务器 <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></div><div class="line">web服务器<span class="number">1</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></div><div class="line">web服务器<span class="number">2</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span></div></pre></td></tr></table></figure></p><p>修改配置文件:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span><span class="keyword">default</span></div></pre></td></tr></table></figure></p><p>这样配置:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">upstream a.com &#123;</div><div class="line">  server  <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>:<span class="number">80</span>;  <span class="comment">#有多少个服务器就添加多少个ip</span></div><div class="line">  server  <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span>:<span class="number">80</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server&#123;</div><div class="line">    listen <span class="number">80</span>;</div><div class="line">    server_name a.com;</div><div class="line">    location / &#123;</div><div class="line">        proxy_pass         http:<span class="comment">//a.com;   #这个地址一定是上面定义的负载均衡的名字</span></div><div class="line">        proxy_set_header   Host             $host;</div><div class="line">        proxy_set_header   X-Real-IP        $remote_addr;</div><div class="line">        proxy_set_header   X-Forwarded-<span class="keyword">For</span>  $proxy_add_x_forwarded_for;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>ps:nginx主服务器也可以当做一个负载均衡服务器,但是由于80端口已经给负载均衡食用了,所有如果我们还使用80端口的话,就会造成一个死循环,我们可以再给主服务器添加一个服务器,并使用不同的8080端口,这样,主服务器也可以当做一个负载均衡的子服务器了,不会造成资源的浪费:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">    listen 8080;</div><div class="line">    server_name a.com;</div><div class="line">    index index.html;</div><div class="line">    root /data0/htdocs/www;</div><div class="line">&#125;</div><div class="line"></div><div class="line">upstream a.com &#123;</div><div class="line"> <span class="built_in"> server </span> 192.168.5.126:80;</div><div class="line"> <span class="built_in"> server </span> 192.168.5.27:80;</div><div class="line"> <span class="built_in"> server </span> 127.0.0.1:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">重启nginx服务器就可以查看效果了<span class="symbol">:</span></div><div class="line">/etc/init.d/nginx restart</div><div class="line"><span class="keyword">or</span> </div><div class="line">nginx -s reload</div></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展:"></a>扩展:</h3><ul><li><p>轮询(默认方式)</p><p>每个请求按时间顺序逐一分配到后端服务器,如果后端服务器down掉,能自动剔除</p></li><li><p>weight</p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream bakend &#123;</div><div class="line">   <span class="built_in"> server </span>192.168.159.10 <span class="attribute">weight</span>=10;</div><div class="line">   <span class="built_in"> server </span>192.168.159.11 <span class="attribute">weight</span>=10;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>ip_hash</p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">    ip_hash;</div><div class="line">   <span class="built_in"> server </span>192.168.159.10:8080;</div><div class="line">   <span class="built_in"> server </span>192.168.159.11:8080;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>fair(第三方)</p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">   <span class="built_in"> server </span>server1;</div><div class="line">   <span class="built_in"> server </span>server2;</div><div class="line">    fair;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>url_hash（第三方)</p><p>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">   <span class="built_in"> server </span>squid1:3128;</div><div class="line">   <span class="built_in"> server </span>squid2:3128;</div><div class="line">    hash <span class="variable">$request_uri</span>;</div><div class="line">    hash_method crc32;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p> 注意:<br> 定义负载均衡设备的Ip及设备状态<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">upstream resinserver&#123;</div><div class="line">    ip_hash;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:8000 down;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:8080 <span class="attribute">weight</span>=2;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:6801;</div><div class="line">   <span class="built_in"> server </span>127.0.0.1:6802 backup;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在需要使用负载均衡的server中增加<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxy_pass <span class="string">http:</span><span class="comment">//resinserver/;</span></div></pre></td></tr></table></figure></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">每个设备的状态设置为:</div><div class="line">  <span class="number">1</span><span class="selector-class">.down</span>   表示单前的server暂时不参与负载</div><div class="line">  <span class="number">2</span><span class="selector-class">.weight</span> 默认为<span class="number">1</span>.weight越大，负载的权重就越大。</div><div class="line">  <span class="number">3</span><span class="selector-class">.max_fails</span> 允许请求失败的次数默认为<span class="number">1</span>.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</div><div class="line">  <span class="number">4</span><span class="selector-class">.fail_timeout</span>:max_fails次失败后，暂停的时间。</div><div class="line">  <span class="number">5</span><span class="selector-class">.backup</span> 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</div><div class="line"></div><div class="line">nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</div><div class="line">  client_body_in_file_only 设置为On 可以讲client post过来的数据记录到文件中用来做debug</div><div class="line">  client_body_temp_path 设置记录文件的目录 可以设置最多<span class="number">3</span>层目录</div><div class="line">  location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</div></pre></td></tr></table></figure><ul><li><p>动静分离</p><pre><code>动静分离也是利用负载均衡的原理来实现的,为了便于管理,我们把ip分配的配置写在conf.d这个文件夹里面:</code></pre>  <figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> <span class="keyword">conf</span>.<span class="built_in">d</span></div><div class="line">vim upstream.<span class="keyword">conf</span></div></pre></td></tr></table></figure><pre><code>里面写上动静分离的分配(以PHP和静态文件为例子):</code></pre>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">upstream</span> php &#123;</div><div class="line">    <span class="attribute">server</span> <span class="number">192.168.10.10:80</span>  <span class="comment">#php给这个服务器处理</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">upstream static &#123;</div><div class="line">    <span class="attribute">server</span> <span class="number">192.168.10.11:80</span> <span class="comment">#html给这个服务器处理</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">server&#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span> a.com;</div><div class="line">    <span class="attribute">location</span> / &#123; <span class="comment">#匹配所有静态资源文件用这个代理</span></div><div class="line">        <span class="attribute">proxy_pass</span>         http://static;   <span class="comment">#这个地址一定是上面定义的负载均衡的名字</span></div><div class="line">        <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123; <span class="comment">#匹配php文件用这个代理</span></div><div class="line">        <span class="attribute">proxy_pass</span>         http://php;   <span class="comment">#这个地址一定是上面定义的负载均衡的名字</span></div><div class="line">        <span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</div><div class="line">        <span class="attribute">proxy_set_header</span>   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果是使用apt-get安装的nginx,配置文件目录在:&lt;br&gt;  /etc/nginx/&lt;br&gt;cd到这个目录之后,ls查看所有文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;nginx.conf&lt;br&gt;  这个是nginx的主配置文件,里面包含了当前目录的所有配置文件,&lt;br
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="Nginx" scheme="https://bummingboy.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux du 命令</title>
    <link href="https://bummingboy.top/2017/12/19/du/"/>
    <id>https://bummingboy.top/2017/12/19/du/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-03T12:02:34.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看当前目录下的所有目录以及子目录的大小"><a href="#查看当前目录下的所有目录以及子目录的大小" class="headerlink" title="查看当前目录下的所有目录以及子目录的大小"></a>查看当前目录下的所有目录以及子目录的大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> du -h</span></div><div class="line"><span class="meta">$</span><span class="bash"> du -ah</span></div><div class="line"><span class="meta">#</span><span class="bash">-h:用K、M、G的人性化形式显示</span></div><div class="line"><span class="meta">#</span><span class="bash">-a:显示目录和文件</span></div></pre></td></tr></table></figure><a id="more"></a><h3 id="只查看当前目录下的tmp目录-包含子目录-的大小"><a href="#只查看当前目录下的tmp目录-包含子目录-的大小" class="headerlink" title="只查看当前目录下的tmp目录(包含子目录)的大小"></a>只查看当前目录下的tmp目录(包含子目录)的大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> du -h tmp</span></div><div class="line"><span class="meta">$</span><span class="bash"> du -ah tmp</span></div></pre></td></tr></table></figure><h3 id="查看当前目录及其指定深度目录的大小"><a href="#查看当前目录及其指定深度目录的大小" class="headerlink" title="查看当前目录及其指定深度目录的大小"></a>查看当前目录及其指定深度目录的大小</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">du -h –-<span class="built_in">max</span>-depth=<span class="number">0</span></div><div class="line">#-–<span class="built_in">max</span>-depth＝<span class="symbol">n:</span>只深入到第<span class="built_in">n</span>层目录，此处设置为<span class="number">0</span>，即表示不深入到子目录</div></pre></td></tr></table></figure><h3 id="du命令的一些常用参数"><a href="#du命令的一些常用参数" class="headerlink" title="du命令的一些常用参数:"></a>du命令的一些常用参数:</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">a或-all 显示目录中个别文件的大小</span></div><div class="line"><span class="ruby">-b或-bytes 显示目录或文件大小时，以byte为单位</span></div><div class="line"><span class="ruby">-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span></div><div class="line"><span class="ruby">-D或--dereference-args 显示指定符号连接的源文件大小</span></div><div class="line"><span class="ruby">-h或--human-readable 以K，M，G为单位，提高信息的可读性</span></div><div class="line"><span class="ruby">-k或--kilobytes 以<span class="number">1024</span> bytes为单位</span></div><div class="line"><span class="ruby">-l或--count-links 重复计算硬件连接的文件</span></div><div class="line"><span class="ruby">-L或--dereference 显示选项中所指定符号连接的源文件大小</span></div><div class="line"><span class="ruby">-m或--megabytes 以<span class="number">1</span>MB为单位</span></div><div class="line"><span class="ruby">-s或--summarize 仅显示总计</span></div><div class="line"><span class="ruby">-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小</span></div><div class="line"><span class="ruby">-X&lt;文件&gt;或--exclude-from=&lt;文件&gt;</span></div><div class="line"><span class="ruby">--exclude=&lt;目录或文件&gt; 略过指定的目录或文件</span></div><div class="line"><span class="ruby">--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略</span></div></pre></td></tr></table></figure><h3 id="查看设备使用率"><a href="#查看设备使用率" class="headerlink" title="查看设备使用率"></a>查看设备使用率</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df 用于查看设备的空间使用率</div><div class="line"><span class="meta">$</span><span class="bash"> df -lh</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;查看当前目录下的所有目录以及子目录的大小&quot;&gt;&lt;a href=&quot;#查看当前目录下的所有目录以及子目录的大小&quot; class=&quot;headerlink&quot; title=&quot;查看当前目录下的所有目录以及子目录的大小&quot;&gt;&lt;/a&gt;查看当前目录下的所有目录以及子目录的大小&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; du -h&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; du -ah&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;-h:用K、M、G的人性化形式显示&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;-a:显示目录和文件&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="du" scheme="https://bummingboy.top/tags/du/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 Gitlab Nginx 权限问题</title>
    <link href="https://bummingboy.top/2017/12/19/Centos%207%20Gitlab%20Nginx%20%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
    <id>https://bummingboy.top/2017/12/19/Centos 7 Gitlab Nginx 权限问题/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-06T08:09:47.852Z</updated>
    
    <content type="html"><![CDATA[<p>安装完GitLab之后, 正常配置可以使用, 此时使用Gitlab自带的Nginx服务器.<br>Gitlab比较消耗资源, 一般使用单独的服务器配置使用, 由于一些众所周知的原因, 有时需要使用服务器已安装的Nginx服务器, 不使用Gitlab自带的, 需要另做一下配置.</p><a id="more"></a><h3 id="修改gitlab配置文件"><a href="#修改gitlab配置文件" class="headerlink" title="修改gitlab配置文件"></a>修改gitlab配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/gitlab/gitlab.rb</span></div><div class="line"></div><div class="line">  搜索 /# nginx</div><div class="line"><span class="meta">  #</span><span class="bash"> nginx[<span class="string">'enable'</span>] = <span class="literal">true</span></span></div><div class="line"><span class="meta">  #</span><span class="bash"> nginx[<span class="string">'client_max_body_size'</span>] = <span class="string">'250m'</span></span></div><div class="line"><span class="meta">  #</span><span class="bash"> nginx[<span class="string">'redirect_http_to_https'</span>] = <span class="literal">false</span></span></div><div class="line">  </div><div class="line">  修改</div><div class="line">  nginx['enable'] = false</div></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><ol><li><p>直接将gitlab自动生成的nginx配置复制到Nginx虚拟主机配置文件夹下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp <span class="regexp">/var/</span>opt<span class="regexp">/gitlab/</span>nginx<span class="regexp">/conf/gi</span>tlab-http.conf <span class="regexp">/etc/</span>nginx<span class="regexp">/conf.d/</span></div></pre></td></tr></table></figure><p>或者 </p></li><li>自己手动生成配置文件, 放置 /etc/nginx/sites-avalible, 并生成相应软链</li></ol><h3 id="检测配置"><a href="#检测配置" class="headerlink" title="检测配置"></a>检测配置</h3>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nginx -t</span></div><div class="line"><span class="meta">$</span><span class="bash"> nginx -s reload</span></div></pre></td></tr></table></figure><h2 id="502问题"><a href="#502问题" class="headerlink" title="502问题"></a>502问题</h2><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ more /etc/gitlab/nginx/gitlab_error.<span class="built_in">log</span></div><div class="line"></div><div class="line"><span class="number">2017</span>/<span class="number">10</span>/<span class="number">10</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">58</span> [crit] <span class="number">8555</span>#<span class="number">0</span>: *<span class="number">13</span> connect() <span class="keyword">to</span> unix:/var/<span class="keyword">opt</span>/gitlab/gitlab-rails/sockets/gitlab.socket failed (<span class="number">13</span>: Permission denied) <span class="keyword">wh</span></div><div class="line">ile connecting <span class="keyword">to</span> upstream, clien<span class="variable">t:</span> <span class="number">59.108</span>.<span class="number">125.198</span>, server: gitlab.wei.<span class="keyword">com</span>, reques<span class="variable">t:</span> <span class="string">"GET / HTTP/1.1"</span>, upstream: <span class="comment">"http://unix:/var/opt/gitlab</span></div><div class="line">/gitlab-rails/sockets/gitlab.socke<span class="variable">t:</span>/<span class="string">", host: "</span>xxxxxxxxxx<span class="comment">"</span></div></pre></td></tr></table></figure><h3 id="Nginx没有访问gitlab的socket权限-nginx-用户无法执行sockets-gitlab-socket-文件"><a href="#Nginx没有访问gitlab的socket权限-nginx-用户无法执行sockets-gitlab-socket-文件" class="headerlink" title="Nginx没有访问gitlab的socket权限, nginx 用户无法执行sockets/gitlab.socket 文件"></a>Nginx没有访问gitlab的socket权限, nginx 用户无法执行sockets/gitlab.socket 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> drwxr-x--- 2 git  gitlab-www 4096 11月  3 15:57 sockets</span></div><div class="line"></div><div class="line">法1: chmod -R o+x /var/opt/gitlab/gitlab-rails/sockets</div><div class="line">法2: chmod 755 /var/opt/gitlab/gitlab-rails/sockets</div><div class="line">法3: 将Nginx用户加入gitlab-www组</div><div class="line"><span class="meta">$</span><span class="bash"> usermod -a -G gitlab-www nginx</span></div><div class="line"></div><div class="line">修改gitlab.rb</div><div class="line">搜索/# web_server</div><div class="line">web_server['external_users'] = ['nginx'] #这里与nginx进程执行用户一致 可通过ps -ef | grep nginx 查看</div><div class="line"><span class="meta">#</span><span class="bash"> web_server[<span class="string">'username'</span>] = <span class="string">'gitlab-www'</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> web_server[<span class="string">'group'</span>] = <span class="string">'gitlab-www'</span></span></div></pre></td></tr></table></figure><h2 id="111-Connection-refused"><a href="#111-Connection-refused" class="headerlink" title="( 111: Connection refused )"></a>( 111: Connection refused )</h2><p>系统内存不足. 服务启动失败</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装完GitLab之后, 正常配置可以使用, 此时使用Gitlab自带的Nginx服务器.&lt;br&gt;Gitlab比较消耗资源, 一般使用单独的服务器配置使用, 由于一些众所周知的原因, 有时需要使用服务器已安装的Nginx服务器, 不使用Gitlab自带的, 需要另做一下配置.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
      <category term="Centos 7" scheme="https://bummingboy.top/categories/linux/centos-7/"/>
    
    
      <category term="Centos7" scheme="https://bummingboy.top/tags/centos7/"/>
    
      <category term="Gitlab" scheme="https://bummingboy.top/tags/gitlab/"/>
    
      <category term="Nginx" scheme="https://bummingboy.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 安装shadowsocks</title>
    <link href="https://bummingboy.top/2017/12/19/Centos%207%20shadowsocks/"/>
    <id>https://bummingboy.top/2017/12/19/Centos 7 shadowsocks/</id>
    <published>2017-12-19T10:08:24.000Z</published>
    <updated>2018-07-06T08:09:47.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="install-shadowsocks"><a href="#install-shadowsocks" class="headerlink" title="install shadowsocks"></a>install shadowsocks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip install shadowsocks</span></div></pre></td></tr></table></figure><h3 id="config-shadowsocks"><a href="#config-shadowsocks" class="headerlink" title="config shadowsocks"></a>config shadowsocks</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd /etc</div><div class="line"><span class="variable">$ </span>mkdir shadowsocks</div><div class="line"><span class="variable">$ </span>cd shadowsocks</div><div class="line"><span class="variable">$ </span>vi config.json</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="string">"server"</span><span class="symbol">:<span class="string">"你的 ShadowSocks 服务器IP"</span></span>,</div><div class="line">    <span class="string">"server_port"</span><span class="symbol">:</span>服务器端口,</div><div class="line">    <span class="string">"local_port"</span><span class="symbol">:</span>本地端口,</div><div class="line">    <span class="string">"password"</span><span class="symbol">:<span class="string">"ShadowSocks 密码"</span></span>,</div><div class="line">    <span class="string">"timeout"</span><span class="symbol">:</span><span class="number">600</span>,</div><div class="line">    <span class="string">"method"</span><span class="symbol">:<span class="string">"aes-256-cfb"</span></span></div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2 id="run-shadowsocks"><a href="#run-shadowsocks" class="headerlink" title="run shadowsocks"></a>run shadowsocks</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sslocal -c /etc/shadowsocks/config.json</span></div><div class="line"><span class="meta">#</span><span class="bash"> 如果已经在config.json 所在路径下, 可直接执行 sslocal</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 如果想在后台一直运行shadowsocks </span></div><div class="line"><span class="meta">$</span><span class="bash"> nohup sslocal -c /etc/shadowsocks/config.json /dev/null 2&gt;&amp;1 &amp;</span></div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 关闭shadowsocks </span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -9 pid</span></div></pre></td></tr></table></figure><h3 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h3><p>Shadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。</p><h3 id="install-privoxy"><a href="#install-privoxy" class="headerlink" title="install privoxy"></a>install privoxy</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz</span></div><div class="line"><span class="meta">$</span><span class="bash"> tar -zxvf privoxy-3.0.26-stable-src.tar.gz</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> privoxy-3.0.26-stable</span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> autuheader &amp;&amp; autoconf <span class="comment"># 如果没有安装autoconf $ yum install -y autoconf</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> ./configure</span></div><div class="line"><span class="meta">$</span><span class="bash"> make &amp;&amp; make install</span></div></pre></td></tr></table></figure><h3 id="configure-privoxy"><a href="#configure-privoxy" class="headerlink" title="configure privoxy"></a>configure privoxy</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /usr/local/etc/privoxy/config</div><div class="line">$ listen-address 127.0.0.1:8118 #8118 是默认端口, 不用更改, 下面会用到</div><div class="line">$ forward-socks5t / 127.0.0.1:localport # localport 是shadowsocks/config.json 中的本地端口</div></pre></td></tr></table></figure><h3 id="run-privoxy"><a href="#run-privoxy" class="headerlink" title="run privoxy"></a>run privoxy</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> useradd privoxy</span></div><div class="line"><span class="meta">$</span><span class="bash"> privoxy --user privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config</span></div></pre></td></tr></table></figure><h3 id="configure-profile"><a href="#configure-profile" class="headerlink" title="configure profile"></a>configure profile</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo vim /etc/profile</div><div class="line">  </div><div class="line">  <span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=http://127.0.0.1:8118</div><div class="line">  <span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=http://127.0.0.1:8118</div><div class="line">  </div><div class="line">$ source /etc/profile</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      shadowsocks config
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
      <category term="Centos 7" scheme="https://bummingboy.top/categories/linux/centos-7/"/>
    
    
      <category term="Centos7" scheme="https://bummingboy.top/tags/centos7/"/>
    
      <category term="Linux" scheme="https://bummingboy.top/tags/linux/"/>
    
      <category term="shadowsocks" scheme="https://bummingboy.top/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>shell - 变量引用, 用户输入, 超时, 文本读写</title>
    <link href="https://bummingboy.top/2017/12/19/shell%20-%20%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8,%20%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5,%20%E8%B6%85%E6%97%B6,%20%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99/"/>
    <id>https://bummingboy.top/2017/12/19/shell - 变量引用, 用户输入, 超时, 文本读写/</id>
    <published>2017-12-19T09:44:47.000Z</published>
    <updated>2018-07-03T10:26:47.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量和变量的引用方式"><a href="#变量和变量的引用方式" class="headerlink" title="变量和变量的引用方式"></a>变量和变量的引用方式</h3><p>Shell 的变量以 var=<value> 的方式定义，以 $var 或者 ${var} 的方式使用。Shell 的变量没有类型的分别，实际就是一个字符串。因此 Shell 变量的使用和字符串密不可分。这一节先介绍一下变量的一些特殊的引用方法。</value></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$<span class="keyword">var</span>/$&#123;<span class="keyword">var</span>&#125; - 最基本的用法，返回变量 <span class="keyword">var</span> 的值——一个字符串。</div><div class="line">$&#123;<span class="keyword">var</span>-<span class="string">"something"</span>&#125;   - 当 <span class="keyword">var</span> 没有被预先定义时，返回 <span class="string">"something"</span>。</div><div class="line">$&#123;<span class="keyword">var</span>：-<span class="string">"something"</span>&#125; - 当 <span class="keyword">var</span> 没有被预先定义，或者被定义为空时，返回 <span class="string">"something"</span>。</div><div class="line">$&#123;<span class="keyword">var</span>=<span class="string">"something"</span>&#125;   - 当 <span class="keyword">var</span> 没有被预先定义时，返回 <span class="string">"something"</span>，同时设置 <span class="keyword">var</span>=<span class="string">"something"</span>。</div><div class="line">$&#123;<span class="keyword">var</span>:=<span class="string">"something"</span>&#125;  - 当 <span class="keyword">var</span> 没有被预先定义，或者被定义为空时，返回 <span class="string">"something"</span>，同时设置 <span class="keyword">var</span>=<span class="string">"something"</span>。</div><div class="line">$&#123;<span class="keyword">var</span>?<span class="string">"something"</span>&#125;   - 当 <span class="keyword">var</span> 没有被预先定义时，返回 <span class="string">"something"</span>，而后终止脚本。</div><div class="line">$&#123;<span class="keyword">var</span>:?<span class="string">"something"</span>&#125;  - 当 <span class="keyword">var</span> 没有被预先定义，或者被定义为空时，返回 <span class="string">"something"</span>，而后终止脚本。</div><div class="line">$&#123;<span class="keyword">var</span>+<span class="string">"something"</span>&#125;   - 当 <span class="keyword">var</span> 已经被定义时，返回 <span class="string">"something"</span>。</div><div class="line">$&#123;<span class="keyword">var</span>:+<span class="string">"something"</span>&#125;  - 当 <span class="keyword">var</span> 已经被定义并且不为空时，返回 <span class="string">"something"</span>。</div></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">示例</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span>  <span class="comment"># return the length of $&#123;var&#125;</span></span></div><div class="line">0</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var-"hello"&#125;</span></span></div><div class="line">hello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> var=<span class="string">""</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var-"hello"&#125;</span></span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var:-"hello"&#125;</span></span></div><div class="line">hello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span></div><div class="line">0</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> var</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var="hello"&#125;</span></span></div><div class="line">hello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line">hello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> var; var=<span class="string">""</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var:="hello"&#125;</span></span></div><div class="line">hello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span></div><div class="line">5</div></pre></td></tr></table></figure><h3 id="圆括号的使用"><a href="#圆括号的使用" class="headerlink" title="圆括号的使用"></a>圆括号的使用</h3><p>除了花括号之外，$ 符号还可以搭配圆括号使用。基本有两种用法：</p><ul><li>$(command) - 返回 command 执行完毕的输出结果，相当于 <code>command</code> 。</li><li>$((expression)) - 执行算术运算 expression 并返回运算结果，例如 $((2 + 3 * 2)) 返回 8。</li></ul><h3 id="按长度截取字符串"><a href="#按长度截取字符串" class="headerlink" title="按长度截取字符串"></a>按长度截取字符串</h3><p>当 Shell 变量中保存着内容时，我们就可以按索引和长度截取字符串中的内容。Shell 变量的索引从 0 开始。主要有两种方式：</p><ul><li>${var:pos} - 返回从 pos 开始一直到末尾的字符串。</li><li>${var:pos:len} - 返回从 pos 开始长度为 len 的字符串。<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">示例</div><div class="line"><span class="meta">$</span><span class="bash"> var=<span class="string">"hello"</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line">hello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span></div><div class="line">5</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var:3&#125;</span></span></div><div class="line">lo</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var:6&#125;</span></span></div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var:0:3&#125;</span></span></div><div class="line">hel</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var:0:6&#125;</span></span></div><div class="line">hello</div></pre></td></tr></table></figure></li></ul><h3 id="按匹配截取字符串"><a href="#按匹配截取字符串" class="headerlink" title="按匹配截取字符串"></a>按匹配截取字符串</h3><p>Shell 的变量支持从左或者从右删除包含通配符的子串：</p><ul><li>使用 # 或者 ## 从左删除子串；</li><li>使用 % 或者 %% 从右删除子串。</li><li>单符号的版本（#/%）尽可能短地匹配子串；双符号的版本（##/%%）尽可能长地匹配子串。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">示例</div><div class="line"><span class="meta">$</span><span class="bash"> var=<span class="string">"hellohello"</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line">hellohello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var#*ll&#125;</span></span></div><div class="line">ohello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var##*ll&#125;</span></span></div><div class="line">o</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var%ll*&#125;</span></span></div><div class="line">hellohe</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var%%ll*&#125;</span></span></div><div class="line">he</div></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>Shell 的变量也支持字符串替换。</p><ul><li>${var/FROM/TO} - 将 $var 中的第一个 FROM 匹配的子串替换成 TO，然后返回。</li><li>${var//FROM/TO} - 将 $var 中所有的 FROM 匹配的子串替换成 TO，然后返回。</li><li>${var/#FROM/TO} - 若 $var 从第一个字符开始能够匹配 FROM，则替换成 TO 然后返回；否则直接返回 ${var}。</li><li>${var/%FROM/TO} - 若 $var 从最后一个字符开始能够匹配 FROM，则替换成 TO 然后返回；否则直接返回 ${var}。<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">示例</div><div class="line"><span class="meta">$</span><span class="bash"> var=<span class="string">"hellohello"</span></span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line">hellohello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var/ll/xx&#125;</span></span></div><div class="line">hexxohello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var//ll/xx&#125;</span></span></div><div class="line">hexxohexxo</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var/#*ll/xx&#125;</span></span></div><div class="line">xxo</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var/#*lx/xx&#125;</span></span></div><div class="line">hellohello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var/%ll*/xx&#125;</span></span></div><div class="line">hexx</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var/%lx*/xx&#125;</span></span></div><div class="line">hellohello</div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span></div><div class="line">hellohello</div></pre></td></tr></table></figure></li></ul><h3 id="获得用户输入read"><a href="#获得用户输入read" class="headerlink" title="获得用户输入read"></a>获得用户输入read</h3><h4 id="1-基本读入"><a href="#1-基本读入" class="headerlink" title="1.基本读入"></a>1.基本读入</h4><p>read接受用户从键盘的输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">echo</span> -n <span class="string">"Enter your name:"</span>       <span class="comment">#-n选项移调末尾换行符，不换行</span></div><div class="line"><span class="built_in">read</span> name</div><div class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$name</span>"</span></div></pre></td></tr></table></figure></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输出结果</div><div class="line">Enter your <span class="built_in">name</span>: caishu</div><div class="line">Hello caishu</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">read</span>的-p选项，直接置顶参数：</div><div class="line"></div><div class="line"><span class="built_in">read</span> -p <span class="string">"Enter your name:"</span> name </div><div class="line"><span class="built_in">echo</span> <span class="string">"Hello <span class="variable">$name</span>"</span></div><div class="line"><span class="built_in">read</span>命令会为每个提示符分配变量，若提示符用完了，则将剩下的所有变量，分配给最后一个提示符。</div></pre></td></tr></table></figure><p>若在read命中不指定变量，read命令会将它收到的任何数据都放进特殊环境变量REPLY中，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"><span class="built_in">read</span> -p <span class="string">"Enter your para:"</span> para1 para2 para3; <span class="built_in">echo</span> <span class="string">"your parameter is <span class="variable">$para1</span>,<span class="variable">$para2</span>,<span class="variable">$para3</span>..."</span></span></div><div class="line">Enter your para:1 2 3 4 5 6 7</div><div class="line">your parameter is 1,2,34567...</div><div class="line"></div><div class="line"><span class="meta">$</span><span class="bash"><span class="built_in">read</span> -p <span class="string">"Enter your para:"</span> ; <span class="built_in">echo</span> <span class="string">"your parameter is <span class="variable">$REPLY</span>"</span></span></div><div class="line">Enter your para:caishu</div><div class="line">your parameter is caishu</div></pre></td></tr></table></figure></p><h4 id="2-超时-和-计数"><a href="#2-超时-和-计数" class="headerlink" title="2.超时 和 计数"></a>2.超时 和 计数</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-t：使用<span class="built_in">read</span>命令时，会一直等用户输入，可以用-t选项来制定计时器，当计时器过期后，<span class="built_in">read</span>命令会返回一个非零退出状态码。</div><div class="line"><span class="built_in">read</span> -t <span class="number">5</span> -p <span class="string">"Please enter your name: "</span> <span class="built_in">name</span>   <span class="comment">#会等5s，可以改变数字以改变等的时间</span></div><div class="line"></div><div class="line">-n和数字：对输入的字符计数，当输入的字符达到预设的字符数时，它会自动退出，将输入的数据赋给变量。</div><div class="line"></div><div class="line"><span class="built_in">read</span> -n1 -p <span class="string">"Please enter your name: "</span> <span class="built_in">name</span>       <span class="comment">#只接受一个字符，空格也是字符。</span></div></pre></td></tr></table></figure><h4 id="3-隐藏方式读取"><a href="#3-隐藏方式读取" class="headerlink" title="3.隐藏方式读取"></a>3.隐藏方式读取</h4><p>-s 阻止用户的输入显示在显示器上，（实际上，数据会被显示，只是read命令将文本颜色设置成跟背景颜色一样）</p><h4 id="4-从文件中读取"><a href="#4-从文件中读取" class="headerlink" title="4.从文件中读取"></a>4.从文件中读取</h4><p>read line 会从文本中读取一行，用cat命令的输出通过管道传给含有read的while命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#read data from a file</span></div><div class="line"></div><div class="line">count=1</div><div class="line">cat filename | <span class="keyword">while</span> <span class="built_in">read</span> line</div><div class="line"><span class="keyword">do</span> </div><div class="line">  <span class="built_in">echo</span> <span class="string">"Line <span class="variable">$count</span>: <span class="variable">$line</span></span></div><div class="line"><span class="string">  count=$[ <span class="variable">$count</span> + 1 ]</span></div><div class="line"><span class="string">done</span></div><div class="line"><span class="string">echo "</span>Finished processing the file<span class="string">"</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量和变量的引用方式&quot;&gt;&lt;a href=&quot;#变量和变量的引用方式&quot; class=&quot;headerlink&quot; title=&quot;变量和变量的引用方式&quot;&gt;&lt;/a&gt;变量和变量的引用方式&lt;/h3&gt;&lt;p&gt;Shell 的变量以 var=&lt;value&gt; 的方式定义，以 $var 或者
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell - 参数解析三种方式(手工, getopts, getopt)</title>
    <link href="https://bummingboy.top/2017/12/19/shell%20-%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E6%89%8B%E5%B7%A5,%20getopts,%20getopt)/"/>
    <id>https://bummingboy.top/2017/12/19/shell - 参数解析三种方式(手工, getopts, getopt)/</id>
    <published>2017-12-19T09:44:47.000Z</published>
    <updated>2018-07-03T10:26:42.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选项和参数"><a href="#选项和参数" class="headerlink" title="选项和参数:"></a>选项和参数:</h3><ul><li>Argument, Option: 中文对应「选项」，形如 -a, –save 的都是选项；选项可以接收参数（Parameter），也可以不接受参数。其中-a 为短选项, –save 为长选项</li><li>Flag: 中文对应「标签」，形如 -v(verbose)；标签是布尔值，不接受参数。</li></ul><p>bash shell 汇总有三种解析参数的方式:</p><ul><li>手工处理:   大多数简单的命令</li><li>getopts:  大多数复杂命令, 不支持长选项</li><li>getopt:  支持长选项, getopts和getopt功能相似但又不完全相同，其中getopt是独立的可执行文件，而getopts是由Bash内置的</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./<span class="keyword">test</span>.<span class="keyword">sh</span> -v -f -<span class="keyword">out</span> /<span class="keyword">test</span>.<span class="keyword">log</span> --prefix=/home</div></pre></td></tr></table></figure><p>  <strong>如果执行是permission denied: test.sh, 运行 chmod +x test.sh 赋予其可执行权限 或是 通过sh/bash 命令运行</strong></p><h3 id="手工处理"><a href="#手工处理" class="headerlink" title="手工处理"></a>手工处理</h3><ul><li>$0 : 在用sh 或者 ./执行脚本时，指的是脚本名，用source或.执行时，永运是bash，这也反应了sh 或者 ./执行脚本的原理和source的方式是不同的.</li><li>$1 : -v,第一个参数.</li><li>$2 : -f</li><li>$3 : -out</li><li>$4 : /test.log </li><li>依次类推 $5 $6 …</li><li>$# : 参数的个数，不包括命令本身，上例中\$#为5.</li><li>$@ : 参数本身的列表，也不包括命令本身，如上例为 -v -f -out /test.log –prefix=/home</li><li>$* : 参数本身的列表，也不包括命令本身，但”$*” 和”\$@”(加引号)并不同，”$*“将所有的参数解释成一个字符串，而”$@”是一个参数数组。如下例所示：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">v -f -out /test.log --prefix=<span class="regexp">/home</span></span></div><div class="line"><span class="ruby">-v</span></div><div class="line"><span class="ruby">-f</span></div><div class="line"><span class="ruby">-out</span></div><div class="line"><span class="ruby">/test.log</span></div><div class="line"><span class="ruby">--prefix=<span class="regexp">/home</span></span></div></pre></td></tr></table></figure><p><strong>也就是说手工处理方式高度依赖命令行中参数的位置, 只适合简单的参数较少的命令, 手工处理方式能满足大多数的简单需求，配合shift使用也能构造出强大的功能</strong></p><h3 id="getopts"><a href="#getopts" class="headerlink" title="getopts"></a>getopts</h3><p>先来看看参数传递的典型用法:</p><ul><li>./test.sh -a -b -c  ： 短选项，各选项不需参数</li><li>./test.sh -abc   ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。</li><li>./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。</li><li>./test.sh –a-long=args –b-long ：长选项</li></ul><h4 id="getopts-用法"><a href="#getopts-用法" class="headerlink" title="getopts 用法"></a>getopts 用法</h4><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><strong>OPTIND</strong>: getopts 在解析传入 Shell 脚本的参数时（也就是 $@），并不会执行 shift 操作，而是通过变量 OPTIND 来记住接下来要解析的参数的位置。</li><li><p><strong>OPTARG</strong>: getopts 在解析到选项的参数时，就会将参数保存在 OPTARG 变量当中；如果 getopts 遇到不合法的选项，择把选项本身保存在 OPTARG 当中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getopts OPTSTRING VARNAME <span class="string">[ARGS...]</span></div></pre></td></tr></table></figure></li><li><p><strong>OPTSTRING</strong> 记录合法的选项列表（以及参数情况)</p></li><li><strong>VARNAME</strong> 则传入一个 Shell 变量的名字，用于保存 getopts 解析到的选项的名字（而不是参数值，参数值保存在 OPTARG 里）</li><li><strong>ATGS…</strong> 是可选的，默认是 $@，即传入 Shell 脚本的全部参数</li></ul><p>通常来说，我们会将 getopts 放在 while 循环的条件判断式中。getopts 在顺利解析到参数的时候，会返回 TRUE；否则返回 FALSE，用以结束循环.<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> ...; <span class="keyword">do</span></div><div class="line">    ...</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p><p>getopts 在两种情况下会停止解析并返回 FALSE：</p><ul><li>getopts 读入不以 - 开始的字符串；比如: sh test.sh flag</li><li>getopts 读入连续的两个 - (i.e. –)</li></ul><h4 id="OPTSTRING"><a href="#OPTSTRING" class="headerlink" title="OPTSTRING"></a>OPTSTRING</h4><p>通过 <strong>OPTSTRING</strong> getopts 知道哪些参数是合法的，哪些参数又是需要接受参数的。<br>OPTSTRING 的格式很简单，就是一个简单的字符串。字符串里，每一个字母（大小写均可，但区分大小写）都是一个选项的名字。</p><p><strong>值得一提的是冒号 (:)</strong><br>在 OPTSTRING 中，冒号有两种含义：</p><ul><li>首位的 : 表示「不打印错误信息」；</li><li><p>紧邻字母（选项名字）的 : 表示该选项接收一个参数。</p><p>例如: </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getopts aBcD VARNAME <span class="comment">// 该脚本接受四个标签-a, -B, -c, -D, 均不接受参数</span></div><div class="line"><span class="string">getopts :</span><span class="string">aB:</span>Cd VARNAME <span class="comment">// 该脚本接受两个标签-a, -B, 两个短选项-C, -d</span></div></pre></td></tr></table></figure></li></ul><p>下面是实例:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span></div><div class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">":a:bc:"</span> opt; <span class="keyword">do</span> <span class="comment">#不打印错误信息, -a -c需要参数 -b 不需要传参  </span></div><div class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></div><div class="line">    a)</div><div class="line">      <span class="built_in">echo</span> <span class="string">"-a arg:<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span> <span class="comment">#$OPTIND指的下一个选项的index</span></div><div class="line">      ;;</div><div class="line">    b)</div><div class="line">      <span class="built_in">echo</span> <span class="string">"-b arg:<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span></div><div class="line">      ;;</div><div class="line">    c) </div><div class="line">      <span class="built_in">echo</span> <span class="string">"-c arg:<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span></div><div class="line">      ;;</div><div class="line">    :)</div><div class="line">      <span class="built_in">echo</span> <span class="string">"Option -<span class="variable">$OPTARG</span> requires an argument."</span> </div><div class="line">      <span class="built_in">exit</span> 1</div><div class="line">      ;;</div><div class="line">    ?) <span class="comment">#当有不认识的选项的时候arg为?</span></div><div class="line">      <span class="built_in">echo</span> <span class="string">"Invalid option: -<span class="variable">$OPTARG</span> index:<span class="variable">$OPTIND</span>"</span></div><div class="line">      ;;</div><div class="line">    </div><div class="line">  <span class="keyword">esac</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ ./test<span class="selector-class">.sh</span> -<span class="selector-tag">a</span> ssss -<span class="selector-tag">b</span> ssss -c</div><div class="line">  &gt;&gt;</div><div class="line">  -<span class="selector-tag">a</span> ssss -<span class="selector-tag">b</span> ssss -c</div><div class="line">  -<span class="selector-tag">a</span> arg:ssss index:<span class="number">3</span></div><div class="line">  -<span class="selector-tag">b</span> arg: index:<span class="number">4</span> #-b并不接受参数, 解析到ssss时直接停止解析</div><div class="line"></div><div class="line">$ ./test<span class="selector-class">.sh</span>  -c xxx -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss</div><div class="line">  &gt;&gt;</div><div class="line">  -c xxx -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss</div><div class="line">  -c arg:xxx index:<span class="number">3</span></div><div class="line">  -<span class="selector-tag">b</span> arg: index:<span class="number">4</span></div><div class="line">  -<span class="selector-tag">a</span> arg:ssssss index:<span class="number">6</span></div><div class="line"></div><div class="line">$ ./test<span class="selector-class">.sh</span>  -c -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss  <span class="comment">// -c 后面没有参数 -b会解析成-c参数</span></div><div class="line">  &gt;&gt;</div><div class="line">  -c -<span class="selector-tag">b</span> -<span class="selector-tag">a</span> ssssss</div><div class="line">  -c arg:-b</div><div class="line">  -<span class="selector-tag">a</span> arg:ssssss</div><div class="line">  </div><div class="line">$ ./test<span class="selector-class">.sh</span> -a</div><div class="line">  &gt;&gt; </div><div class="line">  a</div><div class="line">  Option -<span class="selector-tag">a</span> requires an argument.</div></pre></td></tr></table></figure><h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>  getopt较bash内置的getopts更强大，其不仅支持短参-s，还支持–longopt的长参数，甚至支持-longopt的简化参数。相较于getopts ，getopts 不但支持长短选项，其还支持选项和参数放在一起写。</p><h4 id="getopt-用法"><a href="#getopt-用法" class="headerlink" title="getopt 用法"></a>getopt 用法</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getopt [<span class="keyword">options</span>] -o|--<span class="keyword">options</span> optstring [<span class="keyword">options</span>] [--] <span class="keyword">parameters</span></div></pre></td></tr></table></figure><p>  选项说明：<br>      -a：使getopt长参数支持”-“符号打头，必须与-l同时使用<br>      -l：后面接getopt支持长参数列表<br>      -n program：如果getopt处理参数返回错误，会指出是谁处理的这个错误，这个在调用多个脚本时，很有用<br>      -o：后面接短参数列表，这种用法与getopts类似<br>      -u：不给参数列表加引号，默认是加引号的（不使用-u选项），例如在加引号的时候 –longoption “arg1 arg2” ，只会取到”arg1”，而不是完整的”arg1 arg2”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># A small example program for using the new getopt(1) program.</span></div><div class="line"><span class="comment"># This program will only work with bash(1)</span></div><div class="line"><span class="comment"># Note that we use `"$@"' to let each command-line parameter expand to a</span></div><div class="line"><span class="comment"># separate word. The quotes around `$@' are essential!</span></div><div class="line"><span class="comment"># We need TEMP as the `eval set --' would nuke the return value of getopt.</span></div><div class="line">TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: -n <span class="string">'example.bash'</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</div><div class="line"><span class="keyword">if</span> [ $? != 0 ] ; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"Terminating..."</span> &gt;&amp;2 ; <span class="built_in">exit</span> 1 ; <span class="keyword">fi</span></div><div class="line"><span class="comment"># Note the quotes around `$TEMP': they are essential!</span></div><div class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$TEMP</span>"</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span> ; <span class="keyword">do</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">                -a|--a-long) <span class="built_in">echo</span> <span class="string">"Option a"</span> ; <span class="built_in">shift</span> ;;</div><div class="line">                -b|--b-long) <span class="built_in">echo</span> <span class="string">"Option b, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</div><div class="line">                -c|--c-long)</div><div class="line">                        <span class="comment"># c has an optional argument. As we are in quoted mode,</span></div><div class="line">                        <span class="comment"># an empty parameter will be generated if its optional</span></div><div class="line">                        <span class="comment"># argument is not found.</span></div><div class="line">                        <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></div><div class="line">                                <span class="string">""</span>) <span class="built_in">echo</span> <span class="string">"Option c, no argument"</span>; <span class="built_in">shift</span> 2 ;;</div><div class="line">                                *)  <span class="built_in">echo</span> <span class="string">"Option c, argument \`<span class="variable">$2</span>'"</span> ; <span class="built_in">shift</span> 2 ;;</div><div class="line">                        <span class="keyword">esac</span> ;;</div><div class="line">                --) <span class="built_in">shift</span> ; <span class="built_in">break</span> ;;</div><div class="line">                *) <span class="built_in">echo</span> <span class="string">"Internal error!"</span> ; <span class="built_in">exit</span> 1 ;;</div><div class="line">        <span class="keyword">esac</span></div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Remaining arguments:"</span></div><div class="line"><span class="keyword">for</span> arg <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">'--&gt; '</span><span class="string">"\`<span class="variable">$arg</span>'"</span> ; <span class="keyword">done</span></div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">ARGS=`getopt -a -o I:D:T:e:k:LMSsth -l instence:,database:,table:,excute:,key:,list,master,slave,status,tableview,<span class="built_in">help</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</div><div class="line">    <span class="built_in">echo</span>  <span class="string">'help'</span></div><div class="line">&#125;</div><div class="line">[ $? -ne 0 ] &amp;&amp; usage</div><div class="line"><span class="comment">#set -- "$&#123;ARGS&#125;"</span></div><div class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">"<span class="variable">$&#123;ARGS&#125;</span>"</span></div><div class="line"><span class="keyword">while</span> <span class="literal">true</span></div><div class="line"><span class="keyword">do</span></div><div class="line">      <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">      -I|--instence)</div><div class="line">              instence=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -D|--database)</div><div class="line">              database=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -T|--table)</div><div class="line">              table=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -e|--excute)</div><div class="line">              excute=<span class="string">"yes"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -k|--key)</div><div class="line">              key=<span class="string">"<span class="variable">$2</span>"</span></div><div class="line">              <span class="built_in">shift</span></div><div class="line">              ;;</div><div class="line">      -L|--list)</div><div class="line">              LIST=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -M|--master)</div><div class="line">              MASTER=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -S|--slave)</div><div class="line">              SLAVE=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -A|--alldb)</div><div class="line">              ALLDB=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -s|--status)</div><div class="line">              STATUS=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -t|--tableview)</div><div class="line">              TABLEVIEW=<span class="string">"yes"</span></div><div class="line">              ;;</div><div class="line">      -h|--<span class="built_in">help</span>)</div><div class="line">              usage</div><div class="line">              ;;</div><div class="line">      --)</div><div class="line">              <span class="built_in">shift</span></div><div class="line">              <span class="built_in">break</span></div><div class="line">              ;;</div><div class="line">      <span class="keyword">esac</span></div><div class="line"><span class="built_in">shift</span></div><div class="line"><span class="keyword">done</span> </div><div class="line"><span class="built_in">echo</span> instence:<span class="variable">$instence</span> database:<span class="variable">$database</span> table:<span class="variable">$table</span> excute:<span class="variable">$excute</span> key:<span class="variable">$key</span></div></pre></td></tr></table></figure><h3 id="选项标准化"><a href="#选项标准化" class="headerlink" title="选项标准化"></a>选项标准化</h3><p>在创建shell脚本时，尽量保持选项与Linux通用的选项含义相同，Linux通用选项有：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby">a 显示所有对象</span></div><div class="line"><span class="ruby">-c 生产一个计数</span></div><div class="line"><span class="ruby">-d 指定一个目录</span></div><div class="line"><span class="ruby">-e 扩展一个对象</span></div><div class="line"><span class="ruby">-f 指定读入数据的文件</span></div><div class="line"><span class="ruby">-h 显示命令的帮助信息</span></div><div class="line"><span class="ruby">-i 忽略文本大小写</span></div><div class="line"><span class="ruby">-l 产生输出得长格式文本</span></div><div class="line"><span class="ruby">-n 使用非交互模式</span></div><div class="line"><span class="ruby">-o 指定将所有输出重定向到输出文件</span></div><div class="line"><span class="ruby">-q 以安静模式运行    </span></div><div class="line"><span class="ruby">-r 递归的处理目录和文件</span></div><div class="line"><span class="ruby">-s 以安静模式运行    </span></div><div class="line"><span class="ruby">-v 生成详细输出  </span></div><div class="line"><span class="ruby">-x 排除某个对象 </span></div><div class="line"><span class="ruby">-y 对所有问题回答yes</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;选项和参数&quot;&gt;&lt;a href=&quot;#选项和参数&quot; class=&quot;headerlink&quot; title=&quot;选项和参数:&quot;&gt;&lt;/a&gt;选项和参数:&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Argument, Option: 中文对应「选项」，形如 -a, –save 的都是选项；选项可以
      
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
    
      <category term="shell" scheme="https://bummingboy.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 - 贪婪模式 回溯</title>
    <link href="https://bummingboy.top/2017/12/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20-%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%20%E5%9B%9E%E6%BA%AF/"/>
    <id>https://bummingboy.top/2017/12/04/正则表达式 - 贪婪模式 回溯/</id>
    <published>2017-12-04T09:59:49.000Z</published>
    <updated>2018-07-03T10:27:07.115Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为转载:<br>作者：撒网要见鱼<br>链接：<a href="http://www.jianshu.com/p/a641aab7ee97" target="_blank" rel="external">http://www.jianshu.com/p/a641aab7ee97</a></p><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><h3 id="贪婪匹配模式"><a href="#贪婪匹配模式" class="headerlink" title="贪婪匹配模式"></a>贪婪匹配模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>正则表达式去匹配时，会尽量多的匹配符合条件的内容</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>+，?，*，{n}，{n,}，{n,m}</p><p>匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str='aacbacbc';</div><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/a.*b/;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// aacbacb index为0</span></div><div class="line">console.<span class="built_in">log</span>(res);</div></pre></td></tr></table></figure><p>上例中，匹配到第一个a后，开始匹配.*，由于是贪婪模式，它会一直往后匹配，直到最后一个满足条件的b为止，因此匹配结果是aacbacb</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str='aacbacbc';</div><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/<span class="keyword">ac</span>.*b/;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// acbacb index为1</span></div><div class="line">console.<span class="built_in">log</span>(res);</div></pre></td></tr></table></figure><p>第一个匹配的是a，然后再匹配下一个字符a时，和正则不匹配，因此匹配失败，index挪到1，接下来匹配成功了ac，继续往下匹配，由于是贪婪模式，尽可能多的去匹配结果，直到最后一个符合要求的b为止，因此匹配结果是acbacb</p><h3 id="非贪婪匹配模式"><a href="#非贪婪匹配模式" class="headerlink" title="非贪婪匹配模式"></a>非贪婪匹配模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>正则表达式去匹配时，会尽量少的匹配符合条件的内容<br>也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)</p><h4 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h4><p>+?，??，*?，{n}?，{n,}?，{n,m}?</p><p>可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个?</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str='aacbacbc';</div><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/a.*?b/;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// aacb index为0</span></div><div class="line">console.<span class="built_in">log</span>(res);</div></pre></td></tr></table></figure><p>上例中，匹配到第一个a后，开始匹配.*?，由于是非贪婪模式，它在匹配到了第一个b后，就匹配成功了，因此匹配结果是aacb</p><p>为什么是aacb而不是acb呢？<br>因为前面有提到过一个正在匹配的优先规则: 最先开始的匹配拥有最高的优先权<br>第一个a匹配到了，只要之后没有发生匹配失败的情况，它就会一直匹配下去，直到匹配成功</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str='aacbacbc';</div><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/<span class="keyword">ac</span>.*?b/;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// acb index为1</span></div><div class="line">console.<span class="built_in">log</span>(res);</div></pre></td></tr></table></figure><p>先匹配的a，接下来匹配第二个a时，匹配失败了index变为1，继续匹配ac成功，继续匹配b，由于是非贪婪模式，此时acb已经满足了正则的最低要求了，因此匹配成功，结果为acb</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str='aacbacbc';</div><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/a.*?/;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// a index为0</span></div><div class="line">console.<span class="built_in">log</span>(res);</div><div class="line"></div><div class="line"><span class="keyword">var</span> reg2=/a.*/;</div><div class="line"><span class="keyword">var</span> res2=str.<span class="built_in">match</span>(reg2);</div><div class="line"></div><div class="line"><span class="comment">// aacbacbc index为0</span></div><div class="line">console.<span class="built_in">log</span>(res2);</div></pre></td></tr></table></figure><p>这一个例子则是对示例1的补充，可以发现，当后面没有b时，由于是非贪婪模式，匹配到第一个a就直接匹配成功了<br>而后面一个贪婪模式的匹配则是会匹配所有</p><h3 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h3><p>在初步理解了贪婪模式与非贪婪模式后，可以通过练习加深理解</p><ul><li>提取HTML中的Div标签</li></ul><p>给出一个HTML字符串，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>用户:<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>张三<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>123456<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>需求: 提取出div包裹的内容(包括div标签本身)，并将各个结果存入数组</p><p>代码: 通过非贪婪模式的全局匹配来完成，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var reg=/<span class="tag">&lt;<span class="name">div</span>&gt;</span>.*?<span class="tag">&lt;<span class="name">\</span>/<span class="attr">div</span>&gt;</span>/g;</div><div class="line">var res=str.match(reg);</div><div class="line"></div><div class="line">// ["<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>用户:<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>张三<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>", "<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>123456<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>"]</div><div class="line">console.log(res);</div></pre></td></tr></table></figure><p>详解: 用到了两个知识点，<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.\*?的非贪婪模式匹配以及g全局匹配</div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>.\*?<span class="tag">&lt;<span class="name">\</span>/<span class="attr">div</span>&gt;</span>代表每次只会匹配一次div，这样可以确保每一个div不会越界</div><div class="line"></div><div class="line">最后的g代表全局匹配，即第一次匹配成功后，会将匹配结果放入数组，然后从下一个index重新开始匹配新的结果</div><div class="line"></div><div class="line">另外: 假设使用了/<span class="tag">&lt;<span class="name">div</span>&gt;</span>.\*<span class="tag">&lt;<span class="name">\</span>/<span class="attr">div</span>&gt;</span>/g进行贪婪模式的匹配，结果则是</div><div class="line"></div><div class="line">\["<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>用户:<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>张三<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>123456<span class="tag">&lt;<span class="name">span</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>"]</div><div class="line">因为贪婪模式匹配了第一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>后会无限贪婪的匹配接下来的字符，直到最后一个符合条件的<span class="tag">&lt;/<span class="name">div</span>&gt;</span>为止，导致了将中间所有的div标签都一起匹配上了</div></pre></td></tr></table></figure></p><ul><li>提取两个””中的子串，其中不能再包含””<br>示例引用自: 正则表达式之 贪婪与非贪婪模式详解(<a href="http://www.jb51.net/article/31491.htm" target="_blank" rel="external">http://www.jb51.net/article/31491.htm</a>)<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"The phrase <span class="subst">\"</span>regular expression<span class="subst">\"</span> is called <span class="subst">\"</span>Regex<span class="subst">\"</span> for short"</span></div></pre></td></tr></table></figure></li></ul><p>需求: 提取两个引号之间的子串，其中不能再包括引号，例如上述的提取结果应该是: “regular expression” 与 “Regex”(每一个结束的”后面都接空格)<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">错误解法: 通过如下的非贪婪匹配(请注意空格)</div><div class="line"></div><div class="line"><span class="keyword">var</span> str='<span class="string">"The phrase \"</span>regular expression\<span class="string">" is called \"</span>Regex\<span class="string">" for short"</span>';</div><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/<span class="string">".\*?"</span> /<span class="keyword">g</span>;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// \['"The phrase "regular expression"  ', '"Regex"  ']</span></div><div class="line">console.<span class="built_in">log</span>(res);</div></pre></td></tr></table></figure></p><p>可以看到，上述的匹配完全就是匹配错误了，这个正则匹配到第一个符合条件的”+空格后就自动停下来了</p><p>正确解法: 使用贪婪模式进行匹配<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">reg</span>=/<span class="string">"\[^"</span>]\*" /<span class="keyword">g</span>;</div><div class="line"><span class="keyword">var</span> res=str.<span class="built_in">match</span>(<span class="keyword">reg</span>);</div><div class="line"></div><div class="line"><span class="comment">// \['"regular expression" ', '"Regex" ']</span></div><div class="line">console.<span class="built_in">log</span>(res);</div></pre></td></tr></table></figure></p><p>这个匹配中</p><p>从第一个”开始匹配，接下来到12位时(“r的”)，不满足{FNXX==XXFN}，也不满足之后的”+空格，因此匹配失败了，index挪到下一个，开始下一次匹配</p><p>第二个匹配从”r的”开始，一直匹配到n”空格的空格，这一组刚刚好匹配成功(因为最后符合了正则的”空格)，匹配好了”regular expression”空格</p><p>第三个匹配匹配到了”Regex”空格(过程不再复述)</p><p>到最后时，仅剩一个”直接匹配失败(因为首先得符合”才能开始挣扎匹配)</p><p>至此，正则匹配结束，匹配成功，并且符合预期</p><p>最后: 这个例子相对来说复杂一点，如要更好的理解，可以参考引用来源中的文章，里面有就原理进行介绍<br>另外，参考文章中还有对非贪婪模式的匹配失败，回溯影响性能等特性进行原理分析与讲解</p><h2 id="回溯现象与匹配失败"><a href="#回溯现象与匹配失败" class="headerlink" title="回溯现象与匹配失败"></a>回溯现象与匹配失败</h2><p>你真的已经理解了贪婪模式和非贪婪模式么？</p><h3 id="回溯现象"><a href="#回溯现象" class="headerlink" title="回溯现象"></a>回溯现象</h3><p>不知道对上面最后例子中提到的回溯这词有没有概念？<br>这里仍然以上例引用来源中的示例来分析</p><p>原字符串</p><p>“Regex”</p><h4 id="贪婪匹配过程分析"><a href="#贪婪匹配过程分析" class="headerlink" title="贪婪匹配过程分析"></a>贪婪匹配过程分析</h4><p>“.*“<br>第一个”取得控制权，匹配正则中的”，匹配成功，控制权交给.*</p><p>.<em>取得控制权后，匹配接下来的字符，.代表匹配任何字符，</em>代表可匹配可不匹配，这属于贪婪模式的标识符，会优先尝试匹配，于是接下来从1位置处的R开始匹配，依次成功匹配了R，e，g，e，x，接着继续匹配最后一个字符”，匹配成功，这时候已经匹配到了字符串的结尾，所以.*匹配结束，将控制符交给正则式中最后的”</p><p>“取得控制权后，由于已经是到了字符串的结尾，因此匹配失败，向前查找可供回溯的状态，控制权交给.<em>，.</em>让出一个字符”，再把控制权交给”，此时刚好匹配成功</p><p>至此，整个正则表达式匹配完毕，匹配结果为”Regex”，匹配过程中回溯了1次</p><h4 id="非贪婪匹配表达式"><a href="#非贪婪匹配表达式" class="headerlink" title="非贪婪匹配表达式"></a>非贪婪匹配表达式</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">".\*?"</span></div></pre></td></tr></table></figure><p>第一个”取得控制权，匹配正则中的”，匹配成功，控制权交给.*?</p><p>.*?取得控制权后，由于这是非贪婪模式下的标识符，因此在可匹配可不匹配的情况下会优先不匹配，因此尝试不匹配任何内容，将控制权交给”，此时index在1处(R字符处)</p><p>“取得控制权后，开始匹配1处的R，匹配失败，向前查找可供回溯的状态，控制权交给.<em>?，.</em>?吃进一个字符，index到了2处，再把控制权交给”</p><p>“取得控制权后，开始匹配2处的e，匹配失败，重复上述的回溯过程，直到.*?吃进了x字符，再将控制权交给”</p><p>“取得控制权后，开始匹配6处的”，匹配成功</p><p>至此，整个正则表达式匹配完毕，匹配结果为”Regex”，匹配过程中回溯了5次</p><p>优化去除回溯</p><p>上述的贪婪匹配中，出现了一次回溯现象，其实也可以通过优化表达式来防止回溯的，比如<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"\[^"</span>]\*<span class="string">"</span></div></pre></td></tr></table></figure></p><p>这个表达式中构建了一个子表达式-<a href=""></a>中的^”，它的作用是排除”匹配，这样*的贪婪匹配就不会主动吃进”，这样最后就直接是”匹配”，匹配成功，不会进行回溯</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述的分析中可以看出，在匹配成功的情况下，贪婪模式进行了更少的回溯(可以自行通过更多的实验进行验证)，因此在应用中，在对正则掌握不是很精通的情况下，可以优先考虑贪婪模式的匹配，这样可以避免很多性能上的问题</p><p>匹配失败的情况</p><p>上述的回溯分析都是基于匹配成功的情况，那如果是匹配失败呢？<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> str = <span class="string">'"Regex'</span></div><div class="line"><span class="selector-tag">var</span> reg = /<span class="string">"\[^"</span>]\*<span class="string">"/g;</span></div></pre></td></tr></table></figure></p><p>这个原字符中，没有最后的”，因此匹配是会失败的，它的过程大致如下</p><p>“匹配”，接着<a href=""></a>的^”与*匹配R，e，g，e，x</p><p>接着到了最后，”获取控制权，由于到了最后，开始回溯</p><p>依次回溯的结果是<em>让出x，e，g，e，R，直到</em>已经无法再让出字符，第一轮匹配失败</p><p>接着index开始往下挪，依次用”匹配R，e，g，e，x都失败了，一直到最后也没有再匹配到结果，因此此次正则表达式的匹配失败，没有匹配到结果(或者返回null)</p><p>那非贪婪模式呢？<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/<span class="string">"\[^"</span>]\*?<span class="string">"/g</span></div></pre></td></tr></table></figure></p><p>“匹配”，接着<em>尝试不匹配，”匹配R，失败，然后回溯，</em>吃进R</p><p>接下来类似于上一步，<em>依次回溯吃进e，g，e，x，一直到最后，</em>再次回溯想吃进时，已经到了字符串结尾了，无法继续，因此第一轮匹配失败</p><p>接着index开始往下挪，依次用”匹配R，e，g，e，x都失败了，返回null</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过匹配失败的例子可以看出贪婪和非贪婪的模式区别。贪婪是先吃进，回溯再让出，非贪婪是先忽略，回溯再吃进</p><p>而且，在匹配失败的情况下，贪婪模式也会进行不少的回溯(非贪婪当然一直都很多回溯)</p><p>但是，实际情况中是可以通过子表达式优化的，比如构建^xxx，可以当匹配到不符合条件的时候提前匹配失败，这样就会少很多回溯<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> str = <span class="string">'"cccccc'</span></div><div class="line"><span class="selector-tag">var</span> reg = /<span class="string">"\[^"</span>c]\*<span class="string">"/g;</span></div></pre></td></tr></table></figure></p><p>这个由于直接排除了c，因此*不会吃进它，直接就匹配失败了，减少了很多回溯(当然，上述只是最简单的例子，实际情况要更复杂)</p><h3 id="非贪婪匹配的效率"><a href="#非贪婪匹配的效率" class="headerlink" title="非贪婪匹配的效率"></a>非贪婪匹配的效率</h3><figure class="highlight bnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">可能有不少的人和我一样，有过这样的经历：当我们要匹配类似 "<span class="attribute">&lt;td&gt;</span>内容<span class="attribute">&lt;/td&gt;</span>" 或者 "[b]加粗[/b]" 这样的文本时，我们根据正向预搜索功能写出这样的表达式："<span class="attribute">&lt;td&gt;</span>([^<span class="attribute">&lt;]|&lt;(?!/td&gt;</span>))*<span class="attribute">&lt;/td&gt;</span>" 或者 "<span class="attribute">&lt;td&gt;</span>((?!<span class="attribute">&lt;/td&gt;</span>).)*<span class="attribute">&lt;/td&gt;</span>"。</div><div class="line"></div><div class="line">当发现非贪婪匹配之时，恍然大悟，同样功能的表达式可以写得如此简单："<span class="attribute">&lt;td&gt;</span>.*?<span class="attribute">&lt;/td&gt;</span>"。 顿时间如获至宝，凡是按边界匹配的地方，尽量使用简捷的非贪婪匹配 ".*?"。特别是对于复杂的表达式来说，采用非贪婪匹配 ".*?" 写出来的表达式的确是简练了许多。</div><div class="line"></div><div class="line">然而，当一个表达式中，有多个非贪婪匹配时，或者多个未知匹配次数的表达式时，这个表达式将可能存在效率上的陷阱。有时候，匹配速度慢得莫名奇妙，甚至开始怀疑正则表达式是否实用。</div></pre></td></tr></table></figure><h4 id="效率陷阱的产生："><a href="#效率陷阱的产生：" class="headerlink" title="效率陷阱的产生："></a>效率陷阱的产生：</h4><p>  在本站基础文章里，对非贪婪匹配的描述中说到：“如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。”</p><p>  具体的匹配过程是这样的：</p><p>  “非贪婪部分” 先匹配最少次数，然后尝试匹配 “右侧的表达式”。<br>  如果右侧的表达式匹配成功，则整个表达式匹配结束。如果右侧表达式匹配失败，则 “非贪婪部分” 将增加匹配一次，然后再尝试匹配 “右侧的表达式”。<br>  如果右侧的表达式又匹配失败，则 “非贪婪部分” 将再增加匹配一次。再尝试匹配 “右侧的表达式”。<br>  依此类推，最后得到的结果是 “非贪婪部分” 以尽可能少的匹配次数，使整个表达式匹配成功。或者最终仍然匹配失败。<br>  当一个表达式中有多个非贪婪匹配，以表达式 “d(\w+?)d(\w+?)z” 为例，对于第一个括号中的 “\w+?” 来说，右边的 “d(\w+?)z” 属于它的 “右侧的表达式”，对于第二个括号中的 “\w+?” 来说，右边的 “z” 属于它的 “右侧的表达式”。</p><p>  当 “z” 匹配失败时，第二个 “\w+?” 会 “增加匹配一次”，再尝试匹配 “z”。如果第二个 “\w+?” 无论怎样 “增加匹配次数”，直至整篇文本结束，”z” 都不能匹配，那么表示 “d(\w+?)z” 匹配失败，也就是说第一个 “\w+?” 的 “右侧” 匹配失败。此时，第一个 “\w+?” 会增加匹配一次，然后再进行 “d(\w+?)z” 的匹配。循环前面所讲的过程，直至第一个 “\w+?” 无论怎么 “增加匹配次数”，后边的 “d(\w+?)z” 都不能匹配时，整个表达式才宣告匹配失败。</p><p>  其实，为了使整个表达式匹配成功，贪婪匹配也会适当的“让出”已经匹配的字符。因此贪婪匹配也有类似的情况。当一个表达式中有较多的未知匹配次数的表达式时，为了让整个表达式匹配成功，各个贪婪或非贪婪的表达式都要进行尝试减少或增加匹配次数，由此容易形成一个大循环的尝试，造成了很长的匹配时间。本文之所以称之为“陷阱”，因为这种效率问题往往不易察觉。</p><p>  举例：”d(\w+?)d(\w+?)d(\w+?)z” 匹配 “ddddddddddd…” 时，将花费较长一段时间才能判断出匹配失败 。</p><h4 id="效率陷阱的避免："><a href="#效率陷阱的避免：" class="headerlink" title="效率陷阱的避免："></a>效率陷阱的避免：</h4><p>  避免效率陷阱的原则是：避免“多重循环”的“尝试匹配”。并不是说非贪婪匹配就是不好的，只是在运用非贪婪匹配的时候，需要注意避免过多“循环尝试”的问题。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="xml">情况一：对于只有一个非贪婪或者贪婪匹配的表达式来说，不存在效率陷阱。也就是说，要匹配类似 "<span class="tag">&lt;<span class="name">td</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">td</span>&gt;</span>" 这样的文本，表达式 "<span class="tag">&lt;<span class="name">td</span>&gt;</span>([^<span class="tag">&lt;<span class="name">]|</span>&lt;(?!/<span class="attr">td</span>&gt;</span>))*<span class="tag">&lt;/<span class="name">td</span>&gt;</span>" 和 "<span class="tag">&lt;<span class="name">td</span>&gt;</span>((?!<span class="tag">&lt;/<span class="name">td</span>&gt;</span>).)*<span class="tag">&lt;/<span class="name">td</span>&gt;</span>" 和 "<span class="tag">&lt;<span class="name">td</span>&gt;</span>.*?<span class="tag">&lt;/<span class="name">td</span>&gt;</span>" 的效率是完全相同的。</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">情况二：如果一个表达式中有多个未知匹配次数的表达式，应防止进行不必要的尝试匹配。</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">比如，对表达式 "<span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">'(.*?)'</span>&gt;</span><span class="undefined">(.*?)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>" 来说， 如果前面部分表达式在遇到 "<span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">'vbscript'</span>&gt;</span><span class="actionscript"><span class="string">" 时匹配成功后，而后边的 "</span>(.*?)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>" 却匹配失败，将导致第一个 ".*?" 增加匹配次数再尝试。而对于表达式真正目的，让第一个 ".*?" 增加匹配成“vbscript'&gt;”是不对的，因此这种尝试是不必要的尝试。</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">因此，对依靠边界来识别的表达式，不要让未知匹配次数的部分跨过它的边界。前面的表达式中，第一个 ".*?" 应该改写成 "[^']*"。后边那个 ".*?" 的右边再没有未知匹配次数的表达式，因此这个非贪婪匹配没有效率陷阱。于是，这个匹配脚本块的表达式，应该写成："<span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">'([^'</span>]*)'&gt;</span><span class="undefined">(.*?)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>" 更好。</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇为转载:&lt;br&gt;作者：撒网要见鱼&lt;br&gt;链接：&lt;a href=&quot;http://www.jianshu.com/p/a641aab7ee97&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/a641aab7
      
    
    </summary>
    
      <category term="tech" scheme="https://bummingboy.top/categories/tech/"/>
    
    
      <category term="RegEx" scheme="https://bummingboy.top/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>Centos 7 安装 Docker Private Registry 和 Web UI</title>
    <link href="https://bummingboy.top/2017/12/04/Centos7%20%E5%AE%89%E8%A3%85%20Docker%20Private%20Registry%20%E5%92%8C%20Web%20UI/"/>
    <id>https://bummingboy.top/2017/12/04/Centos7 安装 Docker Private Registry 和 Web UI/</id>
    <published>2017-12-04T08:58:54.000Z</published>
    <updated>2018-07-06T08:11:02.261Z</updated>
    
    <content type="html"><![CDATA[<p>首先正确安装docker, 以下说明建立在此之上.<br>注: 此示例并没有使用nginx服务器和SSL加密.</p><h3 id="use-iptables"><a href="#use-iptables" class="headerlink" title="use iptables"></a>use iptables</h3><p>Centos 7 默认使用firewalld 而不是iptables管理防火墙, 如已使用iptables管理防火墙, 请跳过此步骤.</p><h3 id="install-docker-compose"><a href="#install-docker-compose" class="headerlink" title="install docker-compose"></a>install docker-compose</h3><p><a href="https://docs.docker.com/compose/reference/up/" target="_blank" rel="external">https://docs.docker.com/compose/reference/up/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> pip2 install docker-compose</span></div></pre></td></tr></table></figure><h3 id="docker-run-registry-and-registry-web"><a href="#docker-run-registry-and-registry-web" class="headerlink" title="docker run registry and registry-web"></a>docker run registry and registry-web</h3><p><a href="https://github.com/mkuchin/docker-registry-web/tree/master/examples/auth-enabled" target="_blank" rel="external">https://github.com/mkuchin/docker-registry-web/tree/master/examples/auth-enabled</a></p><h4 id="1-download-examples-files"><a href="#1-download-examples-files" class="headerlink" title="1. download examples files"></a>1. download examples files</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ curl -Ls https:<span class="regexp">//gi</span>thub.com<span class="regexp">/mkuchin/</span>docker-registry-web<span class="regexp">/releases/</span>download<span class="regexp">/v0.1.2/</span>examples.tar.gz | tar -xzv</div><div class="line">$ cd examples<span class="regexp">/auth-enabled/</span></div></pre></td></tr></table></figure><h4 id="2-exec-generate-keys-sh"><a href="#2-exec-generate-keys-sh" class="headerlink" title="2. exec generate-keys.sh"></a>2. exec generate-keys.sh</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./<span class="keyword">generate</span>-keys<span class="variable">.sh</span></div></pre></td></tr></table></figure><h4 id="3-modify-config-file"><a href="#3-modify-config-file" class="headerlink" title="3. modify config file"></a>3. modify config file</h4><ul><li>docker-compose.yml<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> vim docker-compose.yml</span></div></pre></td></tr></table></figure></li></ul><p><img src="/images/D3EDD5CB14782037A60E607A9E23D1F3.jpg" alt=""><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">registry:</span><span class="number">2.4</span><span class="number">.1</span> =&gt; <span class="string">registry:</span>latest <span class="comment">// latest 将image版本切换到最新版</span></div></pre></td></tr></table></figure></p><ul><li>修改 auth.token.realm<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> vim conf/registry/config.yml</span></div></pre></td></tr></table></figure></li></ul><p><img src="/images/9817727A727C25C2CFFA502DC331C2FE.jpg" alt=""><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">realm: http:<span class="regexp">//</span>localhost:<span class="number">8080</span><span class="regexp">/api/</span>auth  =&gt; realm: http:<span class="regexp">//</span>(ip<span class="regexp">/hostname):8080/</span>api<span class="regexp">/auth</span></div></pre></td></tr></table></figure></p><h4 id="4-Start-containers-with-docker-compose"><a href="#4-Start-containers-with-docker-compose" class="headerlink" title="4. Start containers with docker-compose"></a>4. Start containers with docker-compose</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d</span></div></pre></td></tr></table></figure><p>注: -d 后台运行, examples 默认采用-it 交互式运行方式, 关掉终端后, 进程将关闭</p><p>It will run docker registry (ip/hostname):5000 and web ui on <a href="http://(ip/hostname):8080/" target="_blank" rel="external">http://(ip/hostname):8080/</a></p><p>可以通过配置docker-compose.yml 文件设置一些启动参数如: restart: always(docker重启后自动运行)<br><img src="/images/C57AF4BCC176F0586B9CD5C2AD9EEFA1.jpg" alt=""></p><h3 id="check-if-it-working"><a href="#check-if-it-working" class="headerlink" title="check if it working:"></a>check if it working:</h3><p>Login into <a href="http://(ip/hostname):8080/" target="_blank" rel="external">http://(ip/hostname):8080/</a> with admin/admin username/password</p><p>Create test user and grant ‘write-all’ role to that user.</p><ul><li><p>local check:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker login <span class="string">localhost:</span><span class="number">5000</span></div><div class="line">docker pull hello-world</div><div class="line">docker tag hello-world <span class="string">localhost:</span><span class="number">5000</span>/hello-<span class="string">world:</span>latest</div><div class="line">docker push <span class="string">localhost:</span><span class="number">5000</span>/hello-<span class="string">world:</span>latest</div><div class="line">docker rmi <span class="string">localhost:</span><span class="number">5000</span>/hello-<span class="string">world:</span>latest</div><div class="line">docker run <span class="string">localhost:</span><span class="number">5000</span>/hello-<span class="string">world:</span>latest</div></pre></td></tr></table></figure></li><li><p>remote check:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">login</span> (ip/hostname)<span class="selector-pseudo">:5000</span></div><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">hello-world</span></div><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">tag</span> <span class="selector-tag">hello-world</span> (ip/hostname)<span class="selector-pseudo">:5000</span>/<span class="selector-tag">hello-world</span><span class="selector-pseudo">:latest</span></div><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">push</span> (ip/hostname)<span class="selector-pseudo">:5000</span>/<span class="selector-tag">hello-world</span><span class="selector-pseudo">:latest</span></div><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">rmi</span> (ip/hostname)<span class="selector-pseudo">:5000</span>/<span class="selector-tag">hello-world</span><span class="selector-pseudo">:latest</span></div><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> (ip/hostname)<span class="selector-pseudo">:5000</span>/<span class="selector-tag">hello-world</span><span class="selector-pseudo">:latest</span></div></pre></td></tr></table></figure></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-iptables-报-No-chain-target-match-by-that-name"><a href="#1-iptables-报-No-chain-target-match-by-that-name" class="headerlink" title="1. iptables 报 No chain/target/match by that name"></a>1. iptables 报 No chain/target/match by that name</h4><p>参见: <a href="http://blog.jobbole.com/98869/" target="_blank" rel="external">http://blog.jobbole.com/98869/</a><br>关闭docker, 重启iptables, 再启动docker, 简单说就是docker应该在iptables之后启动</p><h4 id="2-登录远程私有仓库时-http-server-gave-HTTP-response-to-HTTPS-client"><a href="#2-登录远程私有仓库时-http-server-gave-HTTP-response-to-HTTPS-client" class="headerlink" title="2. 登录远程私有仓库时 http: server gave HTTP response to HTTPS client"></a>2. 登录远程私有仓库时 http: server gave HTTP response to HTTPS client</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Error </span>response from daemon: Get https://(ip/hostname)rs/: http: server gave HTTP response to HTTPS client</div></pre></td></tr></table></figure><p>本地设置 DOCKER_OPTS=”–insecure-registry myregistrydomain.com:5000” in docker config.</p><p>本人 Mac使用的是 Docker<br><img src="/images/F1435DBD999EF31D9A10C5B4B3A26C6D.jpg" alt=""><br>添加 insecure registry 然后重启docker服务</p><h4 id="3-getsockopt-connection-refused"><a href="#3-getsockopt-connection-refused" class="headerlink" title="3. getsockopt: connection refused"></a>3. getsockopt: connection refused</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Error </span>while pulling image: Get http://localhost:5000/v1/repositories/apiserver/images: dial tcp [::1]:5000: getsockopt: connection refused</div></pre></td></tr></table></figure><p>参见: <a href="https://github.com/mkuchin/docker-registry-web/issues/48" target="_blank" rel="external">https://github.com/mkuchin/docker-registry-web/issues/48</a><br>替换realm.token.auth 的ip或是域名, 上面已经操作过了.</p><h4 id="4-自行修改防火墙端口访问-5000-8080"><a href="#4-自行修改防火墙端口访问-5000-8080" class="headerlink" title="4. 自行修改防火墙端口访问(5000, 8080)"></a>4. 自行修改防火墙端口访问(5000, 8080)</h4><h4 id="5-mac-docker-添加国内源"><a href="#5-mac-docker-添加国内源" class="headerlink" title="5. mac docker 添加国内源"></a>5. mac docker 添加国内源</h4><p><img src="/images/5CA8B9A072952A634E8101F476061318.jpg" alt=""><br>apply and restart</p>]]></content>
    
    <summary type="html">
    
      Centos 7 安装 Docker Private Registry 和 Web UI
    
    </summary>
    
      <category term="Linux" scheme="https://bummingboy.top/categories/linux/"/>
    
      <category term="Centos 7" scheme="https://bummingboy.top/categories/linux/centos-7/"/>
    
    
      <category term="Centos 7" scheme="https://bummingboy.top/tags/centos-7/"/>
    
      <category term="Docker" scheme="https://bummingboy.top/tags/docker/"/>
    
      <category term="private registry" scheme="https://bummingboy.top/tags/private-registry/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门指令</title>
    <link href="https://bummingboy.top/2017/12/04/Docker%20%E5%85%A5%E9%97%A8/"/>
    <id>https://bummingboy.top/2017/12/04/Docker 入门/</id>
    <published>2017-12-04T08:58:54.000Z</published>
    <updated>2018-07-03T12:01:33.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>1.获取镜像<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pull <span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>:<span class="number">5000</span>/ubuntu:<span class="number">14.04</span></div><div class="line">(<span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>为注册服务器，<span class="number">5000</span>为端口号，ubuntu为仓库名称，<span class="number">14.04</span>是镜像也是版本号)</div></pre></td></tr></table></figure></p><a id="more"></a><p>2.查看镜像信息<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images<span class="comment">(列出本地主机已有的所有镜像)</span></div></pre></td></tr></table></figure></p><p>更改变迁信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker tag <span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>:<span class="number">5000</span>/ubuntu:latest ubuntu:latest</div><div class="line">docker inspect <span class="number">000</span>（<span class="number">000</span>为镜像ID，显示这个镜像的详细信息）</div></pre></td></tr></table></figure></p><p>3.搜寻镜像<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">search</span> mysql （输出信息包括镜像名字、描述、星级、是否为官方创建、是否自动创建）</div></pre></td></tr></table></figure></p><p>4.删除镜像<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi <span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>:<span class="number">5000</span>/ubuntu:latest</div></pre></td></tr></table></figure></p><p>注：当有该镜像创建的容器存在时，镜像文件默认是无法删除的，所以删除镜像前最好是删除所有依赖该镜像的容器，请不要用强制删除。</p><p>5.创建镜像<br> 有三种方法：<br> a. 基于已有镜像的容器创建<br>    <figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">commit</span> -m “<span class="keyword">add</span> <span class="keyword">new</span> image”-a <span class="string">""</span> <span class="number">000</span>(容器<span class="keyword">ID</span>) <span class="keyword">test</span>（新建image <span class="keyword">name</span>）</div></pre></td></tr></table></figure></p><p> b. 基于本地模板导入<br>    <figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">cat</span> ubuntu<span class="number">-14.04</span>-x86_64-minimal.tar.gz | docker <span class="keyword">import</span> - ubuntu:14.04</div></pre></td></tr></table></figure></p><p> c. 基于dockerfile创建</p><p>6.存出镜像<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">save</span> <span class="selector-tag">-o</span> <span class="selector-tag">ubuntu_14</span><span class="selector-class">.04</span><span class="selector-class">.tar</span> <span class="selector-tag">ubuntu</span><span class="selector-pseudo">:14.04</span></div></pre></td></tr></table></figure></p><p>7.载入镜像<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">load</span> <span class="selector-tag">--input</span> <span class="selector-tag">ubuntu_14</span><span class="selector-class">.04</span><span class="selector-class">.tar</span> 或者</div><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">load</span> &lt; <span class="selector-tag">ubuntu_14</span><span class="selector-class">.04</span><span class="selector-class">.tar</span></div></pre></td></tr></table></figure></p><p>8.上传镜像<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker push <span class="keyword">user</span>/test:latest(<span class="keyword">user</span>用户需要在dockerHub网站注册)</div></pre></td></tr></table></figure></p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像的一个运行实例，但它带有额外的可写层<br>1.创建容器<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">create</span> -<span class="keyword">it</span> ubuntu:<span class="number">12.04</span></div></pre></td></tr></table></figure></p><p>2.创建并启动容器<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> ubuntu:<span class="number">12.04</span> /bin/bash</div></pre></td></tr></table></figure></p><p>3.守护态运行<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">run</span><span class="bash"> -d ubuntu:12.04</span></div></pre></td></tr></table></figure></p><p>4.查看容器信息<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps [-<span class="selector-tag">a</span> -<span class="selector-tag">q</span> 查看终止状态]</div></pre></td></tr></table></figure></p><p>5.获取容器的输出信息<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs cet(<span class="name">cet</span>是容器ID前三个字符)</div></pre></td></tr></table></figure></p><p>6.终止容器<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">stop</span> cet</div></pre></td></tr></table></figure></p><p>7.启动容器<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="literal">start</span> cet</div></pre></td></tr></table></figure></p><p>8.重启容器<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker restart cet</span></div></pre></td></tr></table></figure></p><p>9.进入容器<br> 1) attach命令<br> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker attach nostalgic(<span class="name">nostalgic</span>是docker的name)</div></pre></td></tr></table></figure></p><p> 缺点：所有窗口同步显示<br> 2) exec命令<br> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> exec -<span class="keyword">it </span><span class="number">243</span>... /<span class="keyword">bin/bash </span>(<span class="number">243</span>...为docker ID)</div></pre></td></tr></table></figure></p><p> 3) nsenter命令<br> a）找PID<br> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PID=<span class="variable">$(docker-pid 243..)</span></div></pre></td></tr></table></figure></p><p> b）通过PID链接容器<br> <figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">nsenter</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">target</span> <span class="comment">$PID</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mount</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">uts</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">ipc</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">net</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pid</span></div></pre></td></tr></table></figure></p><p>10.删除容器<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker rm [-f -l -v] cet</div><div class="line">-<span class="ruby">f 强行终止并删除</span></div><div class="line"><span class="ruby">-l 删除容器的链接，保留容器</span></div><div class="line"><span class="ruby">-v 删除挂载的数据卷</span></div></pre></td></tr></table></figure></p><p>11.导出容器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="builtin-name">export</span> cet &gt;test.tar</div></pre></td></tr></table></figure></p><p>12.导入容器（将容器快照导入到本地镜像库）<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">cat</span> test.tar | docker <span class="keyword">import</span> - test/ubuntu:v1.0</div><div class="line">（重新指定标签为ubuntu的镜像名称，v1<span class="number">.0</span>的版本号</div><div class="line"></div><div class="line"><span class="title">docker</span> load </div><div class="line">也可以导入镜像存储文件到本地镜像库，他比<span class="keyword">import</span>方式的好处是：<span class="keyword">import</span>导入镜像快照文件将丢失所有的历史记录和元数据信息。</div><div class="line">**注：**通过导出容器和导入容器可以实现容器迁移（拷贝文件）</div></pre></td></tr></table></figure></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库是集中存放镜像的地方，一个注册服务器上有很多仓库，一个仓库中有很多镜像。</p><ol><li><p>登录</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">docker login</span></div></pre></td></tr></table></figure></li><li><p>基本操作<br>查找、上传、下载</p></li><li>自动创建</li><li><p>查看镜像</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">http:</span><span class="comment">//www.dockerpool.com/downloads</span></div></pre></td></tr></table></figure></li><li><p>更新镜像标签</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag <span class="selector-tag">dl</span><span class="selector-class">.dockerpool</span><span class="selector-class">.com</span>:<span class="number">5000</span>/ubuntu:<span class="number">12.04</span> ubuntu:<span class="number">12.04</span>(将前面的镜像更改为ubuntu:<span class="number">12.04</span>)</div></pre></td></tr></table></figure></li><li><p>创建私有仓库</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">docker</span> run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /<span class="meta">opt</span>/<span class="meta">data</span>/registry:/tmp/registry</div></pre></td></tr></table></figure></li></ol><p>registry(自动下载并启动registry容器，创建本地的私有仓库服务,默认仓库船舰的容器在/tmp/registry，可以通过-v参数来存放到指定路径上)<br>7.管理私有仓库镜像<br> 假设私有仓库地址为10.0.2.2，端口为5000，<br> <code></code>docker tag ubuntu:14.04 10.0.2.2:5000/test(更改标签名)<br>docker push 10.0.2.2:5000/test(push镜像，会自动push到10.0.2.2地址的机器上)<br>curl <a href="http://10.0.2.2:5000/v2/search(查看仓库10.0.2.2:5000中是否含有test镜像" target="_blank" rel="external">http://10.0.2.2:5000/v2/search(查看仓库10.0.2.2:5000中是否含有test镜像</a>)<br>docker pull 10.0.2.2:5000/test(在任何一台能访问到10.0.2.2地址的机器上下载镜像)<br>``</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h3&gt;&lt;p&gt;1.获取镜像&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker pull &lt;span class=&quot;selector-tag&quot;&gt;dl&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.dockerpool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.com&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;/ubuntu:&lt;span class=&quot;number&quot;&gt;14.04&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;selector-tag&quot;&gt;dl&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.dockerpool&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.com&lt;/span&gt;为注册服务器，&lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;为端口号，ubuntu为仓库名称，&lt;span class=&quot;number&quot;&gt;14.04&lt;/span&gt;是镜像也是版本号)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://bummingboy.top/categories/docker/"/>
    
    
      <category term="Docker" scheme="https://bummingboy.top/tags/docker/"/>
    
  </entry>
  
</feed>
