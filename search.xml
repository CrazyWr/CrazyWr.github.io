<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Network - HTTP 长连接 短连接]]></title>
    <url>%2F2018%2F05%2F11%2FHTTP%20-%20%E9%95%BF%E8%BF%9E%E6%8E%A5%20%E7%9F%AD%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[1. HTTP协议与TCP/IP协议的关系 HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 2. 如何理解HTTP协议是无状态的 HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 3. 什么是长连接、短连接？ 在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。 但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 3.1 TCP连接 当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的 经典的三次握手四次挥手示意图： 3.2 TCP短连接 我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作 短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段 3.3 TCP长连接 接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务 器端检测到这种半开放的连接。 如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一： 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。 3.4 长连接短连接操作过程短连接的操作步骤是：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接 4. 长连接和短连接的优点和缺点 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。 5. 什么时候用长连接，短连接？ 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，每次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。 原文链接: http://www.cnblogs.com/0201zcr/p/4694945.html 补充: HTTP keep alive 和 websocket可以把 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁，它和HTTP有一些共性，是为了解决 HTTP 本身无法解决的某些问题而做出的一个改良设计。在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header；所谓的 polling 是指从客户端（一般就是浏览器）不断主动的向服务器发 HTTP 请求查询是否有新数据。这两种模式有一个共同的缺点，就是除了真正的数据部分外，服务器和客户端还要大量交换 HTTP header，信息交换效率很低。它们建立的“长连接”都是伪.长连接，只不过好处是不需要对现有的 HTTP server 和浏览器架构做修改就能实现。 WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。但是不需要发送 HTTP header就能交换数据显然和原有的 HTTP 协议是有区别的，所以它需要对服务器和客户端都进行升级才能实现。在此基础上 WebSocket 还是一个双通道的连接，在同一个 TCP 连接上既可以发也可以收信息。此外还有 multiplexing 功能，几个不同的 URI 可以复用同一个 WebSocket 连接。这些都是原来的 HTTP 不能做到的。]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>长连接</tag>
        <tag>短连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node - pm2 cluster 模式无法使用babel-node启动]]></title>
    <url>%2F2018%2F04%2F26%2FNode%20-%20pm2%20cluster%20%E6%A8%A1%E5%BC%8F%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8babel-node%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[为了使用 ES6/7 的新功能, 而且不进行转码, 项目一直使用 babel-node 启动脚本, 同时使用 pm2 进行项目管理, 开发环境下 babel-node 可以正常工作, 生产环境下 pm2 并不支持使用 babel-node, Because the cluster mode has an hardcoded interpreter which is node 也就是说 cluster 模式下 interpreter 是写死的使用的node, “exec_interpreter” 参数会被忽略. 通过以下方式通过 pm2 cluster 模式使用 ES6/7 新功能 http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2#require-hook 安装 babel-register, babel-polyfill 新建入口文件index.js, 假设原来的入口文件为app.js 123require('babel-register');require('babel-polyfill');require('app.js'); // 设置对应位置 在对应的 pm2.json 文件中设置, 入口文件为 index.js.]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>pm2</tag>
        <tag>cluster</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 服务器内部无法正常解析域名]]></title>
    <url>%2F2018%2F04%2F25%2FLinux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E9%83%A8%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[问题现象 Linux 服务器内部无法正常解析域名, IP访问正常 curl xxx.xxx Could not resolve host: xxx.xxx 可能原因可能的原因包括： DNS 设置问题 防火墙策略问题 NSCD 服务问题 处理办法1、通过如下指令，检查系统是否正确设置了 dns 服务器。123456789101112cat /etc/resolv.conf# Generated by NetworkManager# No nameservers found; try putting DNS servers into your# ifcfg files in /etc/sysconfig/network-scripts like so:## DNS1=xxx.xxx.xxx.xxx# DNS2=xxx.xxx.xxx.xxx# DOMAIN=lab.foo.com bar.foo.comnameserver 10.242.197.247nameserver 10.242.197.248 如果没有 DNS 的配置则需要添加设置，公网服务器可以设置为阿里云如下公共 DNS：12nameserver 223.5.5.5nameserver 223.6.6.6 2、检查防火墙 iptables，查看是否有拦截 53 端口的相关规则。 可以先使用命令 service iptables stop 关闭防火墙对比测试。如果存在 iptables 规则，尝试删除 deny 策略或修改规则为 ACCEPT 策略。 3、检查是否开启 dns 缓存服务 nscd： 通过 service nscd status 命令查看服务状态。如果已经开启，尝试使用命令 service nscd stop 关闭服务后再对比测试。12service nscd statusservice nscd stop]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 阻止自动http 跳转 https]]></title>
    <url>%2F2018%2F04%2F25%2FChrome%20%E9%98%BB%E6%AD%A2%E8%87%AA%E5%8A%A8http%20%E8%B7%B3%E8%BD%AC%20https%2F</url>
    <content type="text"><![CDATA[配置一个服务使用SSL出错, 当前使用的是二级域名, 根域名有别的SSL证书, 然后切换回http时, 一直自动跳转到https, 使用的是根域名的SSL证书, 跟当前二级域名不相符, 一直提示不安全的连接, 很长时间无法直接访问http. 解决办法: 在chrome的地址栏输入：1chrome://net-internals/#hsts 在打开的页面中，Delete domain栏的输入框中输入：xxxx.xxxxx(要访问的域名)，然后点击“delete”按钮，即可完成配置。 然后你可以在Query domain栏中搜索刚才输入的域名，点击“query”按钮后如果提示“Not found”，那么你现在就可以使用http来访问那个网站了！ 至于 chrome hsts 的作用看这里 HSTS 简介国际互联网工程组织IETE正在推行一种新的Web安全协议HTTP Strict Transport Security（HSTS）采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的就是该网站的安全版本。 原理在第一次访问https网站时，网站的回复表头带有「Strict-Transport-Security」，该表头会让浏览器记得，该网站(正确说法是域名)有提供HTTPS安全连线，并于下次连线中强制使用HTTPS，注意是强制喔，不论是点进不带有https的连接，或是你故意在网址里打入网址时使用 http:// 为开头，浏览器都会先强制转换成https再送出请求]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell - 判断文件夹是否存在]]></title>
    <url>%2F2018%2F04%2F25%2Fshell%20-%20%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[#shell判断文件夹是否存在 #如果文件夹不存在，创建文件夹if [ ! -d “/myfolder” ]; then mkdir /myfolderfi #shell判断文件,目录是否存在或者具有权限 folder=”/var/www/“file=”/var/www/log” -x 参数判断 $folder 是否存在并且是否具有可执行权限if [ ! -x “$folder”]; then mkdir “$folder”fi -d 参数判断 $folder 是否存在if [ ! -d “$folder”]; then mkdir “$folder”fi -f 参数判断 $file 是否存在if [ ! -f “$file” ]; then touch “$file”fi -n 判断一个变量是否有值if [ ! -n “$var” ]; then echo “$var is empty” exit 0fi 判断两个变量是否相等if [ “$var1” = “$var2” ]; then echo ‘$var1 eq $var2’else echo ‘$var1 not eq $var2’fi]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell - 条件判断 if 中 -a 到 -z 的意思]]></title>
    <url>%2F2018%2F04%2F25%2Fshell%20-%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif%E4%B8%AD%E7%9A%84-a%E5%88%B0-z%E7%9A%84%E6%84%8F%E6%80%9D%2F</url>
    <content type="text"><![CDATA[[ -a FILE ] 如果 FILE 存在则为真。 [ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。 [ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。 [ -d FILE ] 如果 FILE 存在且是一个目录则为真。 [ -e FILE ] 如果 FILE 存在则为真。 [ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。 [ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。 [ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。 [ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。 [ -r FILE ] 如果 FILE 存在且是可读的则为真。 [ -s FILE ] 如果 FILE 存在且大小不为0则为真。 [ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。 [ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。 [ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。 [ -x FILE ] 如果 FILE 存在且是可执行的则为真。 [ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。 [ -G FILE ] 如果 FILE 存在且属有效用户组则为真。 [ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。 [ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。 [ -S FILE ] 如果 FILE 存在且是一个套接字则为真。 [ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。 [ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。 [ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。 [ -o OPTIONNAME ] 如果 shell选项 “OPTIONNAME” 开启则为真。 [ -z STRING ] “STRING” 的长度为零则为真。 [ -n STRING ] or [ STRING ] “STRING” 的长度为非零 non-zero则为真。 [ STRING1 == STRING2 ] 如果2个字符串相同。 “=” may be used instead of “==” for strict POSIX compliance则为真。 [ STRING1 != STRING2 ] 如果字符串不相等则为真。 [ STRING1 &lt; STRING2 ] 如果 “STRING1” sorts before “STRING2” lexicographically in the current locale则为真。 [ STRING1 &gt; STRING2 ] 如果 “STRING1” sorts after “STRING2” lexicographically in the current locale则为真。 [ ARG1 OP ARG2 ] “OP” is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators return true if “ARG1” is equal to, not equal to, less than, less than or equal to, greater than, or greater than or equal to “ARG2”, respectively. “ARG1” and “ARG2” are integers.]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>if</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS vs ES6 import/export]]></title>
    <url>%2F2018%2F01%2F05%2Fcommonjs%20vs%20ES6%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[js 几种流行的模块机制中, node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD, seajs 不了解不过多解释.首先明确一下 import/export 对应ES6的模块机制 用法(https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export)或(http://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82) require/module.exports()对应CommonJS的模块机制 用法(http://javascript.ruanyifeng.com/nodejs/module.html) 原理 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 (因为CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。) CommonJS 模块的加载原理CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。CommonJS 的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 123456&#123; id: '...', exports: &#123; ... &#125;, loaded: true, ...&#125; 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 delete require.cache[‘path/to/config’] config = require(‘path/to/config’)) ES6加载原理JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 循环加载CommonJS 模块的循环加载CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。让我们来看，Node 官方文档里面的例子。脚本文件a.js代码如下。 12345exports.done = false;var b = require('./b.js');console.log('在 a.js 之中，b.done = %j', b.done);exports.done = true;console.log('a.js 执行完毕'); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。再看b.js的代码。 12345exports.done = false;var a = require('./a.js');console.log('在 b.js 之中，a.done = %j', a.done);exports.done = true;console.log('b.js 执行完毕'); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。a.js已经执行的部分，只有一行。 1exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。 123var a = require('./a.js');var b = require('./b.js');console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行main.js，运行结果如下。 1234567$ node main.js在 b.js 之中，a.done = falseb.js 执行完毕在 a.js 之中，b.done = truea.js 执行完毕在 main.js 之中, a.done=true, b.done=true 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。 1exports.done = true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 12345678910var a = require('a'); // 安全的写法var foo = require('a').foo; // 危险的写法exports.good = function (arg) &#123; return a.foo('good', arg); // 使用的是 a.foo 的最新值&#125;;exports.bad = function (arg) &#123; return foo('bad', arg); // 使用的是一个部分加载时的值&#125;; 上面代码中，如果发生循环加载，require(‘a’).foo的值很可能后面会被改写，改用require(‘a’)会更保险一点。 ES6 模块的循环加载ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。请看下面这个例子。 1234567891011// a.mjsimport &#123;bar&#125; from './b';console.log('a.mjs');console.log(bar);export let foo = 'foo';// b.mjsimport &#123;foo&#125; from './a';console.log('b.mjs');console.log(foo);export let bar = 'bar'; 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。 123$ node --experimental-modules a.mjsb.mjsReferenceError: foo is not defined 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？ 让我们一行行来看，ES6循环加载是怎么处理的。首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.js。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。 12345678910111213// a.mjsimport &#123;bar&#125; from './b';console.log('a.mjs');console.log(bar());function foo() &#123; return 'foo' &#125;export &#123;foo&#125;;// b.mjsimport &#123;foo&#125; from './a';console.log('b.mjs');console.log(foo());function bar() &#123; return 'bar' &#125;export &#123;bar&#125;; 这时再执行a.mjs就可以得到预期结果。 12345$ node --experimental-modules a.mjsb.mjsfooa.mjsbar 这是因为函数具有提升作用，在执行import {bar} from’./b’时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。这也意味着，如果把函数foo改写成函数表达式，也会报错。 123456// a.mjsimport &#123;bar&#125; from './b';console.log('a.mjs');console.log(bar());const foo = () =&gt; 'foo';export &#123;foo&#125;; 上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。我们再来看 ES6 模块加载器SystemJS给出的一个例子。 12345678910111213// even.jsimport &#123; odd &#125; from './odd'export var counter = 0;export function even(n) &#123; counter++; return n === 0 || odd(n - 1);&#125;// odd.jsimport &#123; even &#125; from './even';export function odd(n) &#123; return n !== 0 &amp;&amp; even(n - 1);&#125; 上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。 运行上面这段代码，结果如下。 12345678910$ babel-node&gt; import * as m from './even.js';&gt; m.even(10);true&gt; m.counter6&gt; m.even(20)true&gt; m.counter17 上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。 这个例子要是改写成 CommonJS，就根本无法执行，会报错。 1234567891011121314// even.jsvar odd = require('./odd');var counter = 0;exports.counter = counter;exports.even = function (n) &#123; counter++; return n == 0 || odd(n - 1);&#125;// odd.jsvar even = require('./even').even;module.exports = function (n) &#123; return n != 0 &amp;&amp; even(n - 1);&#125; 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。 1234$ node&gt; var m = require('./even');&gt; m.even(10)TypeError: even is not a function import vs require()遵循规范- require 是 AMD规范引入方式 - import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法 调用时间- require是运行时调用，所以require理论上可以运用在代码的任何地方 - import是编译时调用，所以必须放在文件开头 本质- require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 - import是解构过程，node v8引擎还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>CommonJS</tag>
        <tag>ES6</tag>
        <tag>import/export</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongodb 更换数据目录]]></title>
    <url>%2F2017%2F12%2F19%2FMongodb%20%E6%9B%B4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这不是数据迁移, 迁移的话通常用mongodump, 另说.本篇是因为服务器主分区只有20G, 数据库文件数据量大了, 主分区不够了需要迁移到新挂载的数据盘.挂载的知识请看().下面是思路: 查看MongoDB的状态, 终止数据库运行 查看数据库数据, 日志路径 压缩备份, 拷贝到新目录 重启 1.查看MongoDB状态123$ mongo...&gt; 连接成功则表示mongod已经运行 12345678910111213$ service mongod status &gt; stop/waiting 表示不是通过service运行的&gt; start/running 表示通过service运行的$ service mongod stop 停止$ service mongod start/restart 重启or$ ps -aux | grep mongo&gt;root 7695 0.3 13.5 29712004 1109256 ? Sl Dec14 2:37 mongod --fork --logpath /var/log/mongodb/mongodb.log --dbpath /var/lib/mongodb ubuntu 24526 0.0 0.0 10468 2232 pts/1 R+ 10:43 0:00 grep --color=auto mongo表示mongod服务是通过--fork 形式手动启动的$ kill PID(7695) 终止服务 2.查看数据库数据, 日志路径 service 启动的mongod服务此时通过/etc/init.d/mongodb启动服务, 默认使用/etc/mongod.conf配置文件 mongod –fork 启动mongod服务默认也会使用/etc/mongod.conf配置文件, 但是当指定dbpath logpath后以指定为准 mongod.conf文件 12345678910...storage:dbPath: /var/lib/mongodbjournal: enabled: true...systemLog:destination: filelogAppend: truepath: /var/log/mongodb/mongod.log 修改对应路径: 12345678910...storage:dbPath: /data/db/mongodbjournal: enabled: true...systemLog:destination: filelogAppend: truepath: /data/db/log/mongod.log 本例中前人通过指定logpath dbpath的方式启动服务 3.压缩备份, 拷贝到新目录 知道了原来的数据和日志位置, 那么可以压缩备份原来的数据了, 本例以/data/db/mongodb为新的数据目录 /data/db/log为新的日志目录 1234$ cd /var/lib$ tar -zcvf mongodb_backup_xxxxxx.tar.gz /var/lib/mongodb$ cp -ra /var/lib/mongodb /data/db/mongodb$ rm -rf /var/lib/mongodb 4.重启mongod服务 1$ sudo service mongod start or 1$ sudo mongod --dbpath /data/db/mongodb --logpath /data/db/log/mongod.log 问题: 启动失败 查看新数据目录权限 12$ cd /data/db$ ll 直接拷贝 已经是mongodb:mongodb 用户组了 查看日志 访问mongodb-27017.sock 无权限 123...Failed to unlink socket file /tmp/mongodb-27017.sock errno:1 Operation not permitted... 123$ cd /tmp$ ll$ rm -rf mongodb-27017.sock 重新启动重新查看 mongodb-27017.sock 文件 123$ ls - lat /tmp/mongodb-27017.sock&gt;srwx------ 1 mongodb mongodb 0 Dec 14 21:12 /tmp/mongodb-27017.sock 注: 启动相关日志 还是在/var/log/mongodb]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm私有仓库搭建及使用 (verdaccio)]]></title>
    <url>%2F2017%2F12%2F19%2Fnpm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%20(verdaccio)%2F</url>
    <content type="text"><![CDATA[下载及搭建1234$ npm install -g verdaccio$ verdaccio warn --- config file - /home/ubuntu/.config/verdaccio/config.yaml warn --- http address - http://localhost:4873/ - verdaccio/2.3.2 终端显示默认配置文件和verdaccio工作端口, 浏览器打开http://localhost:4873/ ，页面如下 配置 default config: 123456789101112131415161718192021222324252627282930313233storage: ./storage # 设置托管或缓存包的存放目录auth: # 权限控制 htpasswd: # 启用 htpasswd 插件管理权限 file: ./htpasswd # 制定 htpasswd 文件路径，htpasswd 中存储者用户名和加密过的秘钥 max_users: 1000 # 最多允许注册用户数uplinks: # 设置外部仓储，如果 verdaccio 找不到请求的包（非 verdaccio 托管），就会查找外部仓储 npmjs: url: https://registry.npmjs.org/packages: '@*/*': access: $all publish: $authenticated proxy: npmjs '**': proxy: npmjslogs: - &#123;type: stdout, format: pretty, level: http&#125;web: enable: true title: Verdaccio logo: logo.pngpublish: allow_offline: false # 是否支持离线发布 默认falseurl_prefix: https://dev.company.local/verdaccio/ # 设置资源文件路径前缀。默认不需要设置，但如果使用 nginx 代理并改写了请求路径，就需要指定了。max_body_size: 1mb # 默认JSON document size 1mblisten: # 设置服务运行地址端口# - localhost:4873 # default value# - http://localhost:4873 # same thing# - 0.0.0.0:4873 # listen on all addresses (INADDR_ANY)# - https://example.org:4873 # if you want to use https# - [::1]:4873 # ipv6# - unix:/tmp/verdaccio.sock # unix socket uplinks常用仓储有123456npmjs:url: https://registry.npmjs.orgyarnjs:url: https://registry.yarnpkg.comcnpmjs:url: https://registry.npm.taobao.org packages: 包访问或发布控制 {regexp}: 包名匹配正则。access: 访问控制，可选值有$all（用户不限制）, $anonymous（用户不限制）, $authenticated（所有登录用户）, username( 用户名，需指定具体用户，可指定多个用户，用户间空格隔开，如 secret super-secret-area ultra-secret-area)。尽管@all, @anonymous, all, undefined,publish: 发布控制，配置请参考 accessproxy: 代理控制，设置的值必选现在 uplinks 中定义。 常用的包名正则有： 1234** # 匹配任意包@*/* # 匹配任意 scope 包@npmuser/* # 匹配 scope 为 npmuser 的包npmuser-* # 匹配包名有 npmuser- 前缀的包 包名正则规范通 gitignore 一致，verdaccio 内部使用minimatch实现的，如果需要书写更复杂的正则，可以参考 minimatch 文档。 详情(https://github.com/verdaccio/verdaccio/blob/master/wiki/config.md) 使用项目初始化12$ yarn/npm init... input some info coding注册仓库并添加用户123npm set registry ip/hostnamenpm adduser --registry ip/hostnameinput: username/password/email publish12$ yarn/npm pulish... input some info install1234$ yarn add package-name / npm install package-nameor$ yarn / npm logout$ (yarn add package-name / npm install package-name) --registry http://localhost:4873 私有包现在配置org-前缀的包全部私有 只需在配置文件 config.yml 中 package 段添加配置 1234'org-*': access: $authenticated publish: $authenticated proxy: npmjs 这里我们配置了所有org-前缀的包只有注册用户才能访问和发布。 你也可以对 publish 做进一步限制，只有 npmuser 用户才能发布1234'org-*': access: $authenticated publish: npmuser proxy: npmjs 注意修改配置后要重启 verdaccio scope 包其实加前缀并不是一种很好组织包的方式，npm 提供了更好的名称空间策略 scope scope 包包名格式：@scope-name/pkg-name 初始化包时指定 scope1npm init --scope org 我们可以为 scope 绑定一个仓储12npm login --registry=http://reg.example.com --scope=@orgnpm config set @org:registry http://reg.example.com 这样凡是碰到 scope 为 @org 的包，npm 将自动切换作业仓储到 scope 绑定的仓储，这提供了一种多仓储策略。 scope 私有包配置1234'@org/*': access: $authenticated publish: $authenticated proxy: npmjs]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>私有仓库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firewall 使用]]></title>
    <url>%2F2017%2F12%2F19%2Ffirewall%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 基础使用运行、停止、禁用firewalld 状态1234启动： systemctl start firewalld查看状态： systemctl status firewalld 停止： systemctl disable firewalld禁用： systemctl stop firewalld 查看firewall是否运行123下面两个命令都可以systemctl status firewalld.servicefirewall-cmd --state 2. 服务管理123456789启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed 添加一个服务到firewalld1234firewall-cmd --add-service=http //http换成想要开放的service这样添加的service当前立刻生效，但系统下次启动就失效，可以测试使用。要永久开发一个service，加上 --permanentfirewall-cmd --permanent --add-service=http 如果要添加的端口并没有服务对应就要新建一个服务，在/usr/lib/firewalld/services，随便拷贝一个xml文件到一个新名字，比如myservice.xml,把里面的 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;service&gt;&lt;short&gt;Transmission-client&lt;/short&gt;&lt;description&gt;Transmission is a lightweight GTK+ BitTorrent client.&lt;/description&gt;&lt;port protocol="tcp" port="51413"/&gt;&lt;/service&gt; short改为想要名字（这个名字只是为了人来阅读，没有实际影响。重要的是修改 protocol和port。修改完保存。我的经验是这是要重启firewalld服务，systemctl restart firewalld.service，否则可能提示找不到刚才新建的service。然后把新建的service添加到firewalld12firewall-cmd --permanent --add-service=myservice重启firewalld 生效 3. 配置firewalld-cmd1234567891011121314151617181920查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 那怎么开启一个端口呢添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd --reload查看firewall-cmd --zone= public --query-port=80/tcp删除firewall-cmd --zone= public --remove-port=80/tcp --permanent]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 修改系统时间的三种方法]]></title>
    <url>%2F2017%2F12%2F19%2FLinux%20%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[三种方法: 一、修改时区1234567891011# cp /etc/localtime /etc/localtime.bak# ln -svf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime修改为中国的东八区# cat /etc/sysconfig/clockZONE="Asia/Shanghai"UTC=falseARC=false# 与时间服务器同步ntpdate 0.centos.pool.ntp.org 二、配置新的时间123456789101112131415161718192021222324252627日期设定：# date -s 2013/09/26时间设定：# date -s 11:47:06# date -s "12:00:00 2013-12-06"# date -s "12:00:00 20131206"# date -s "2013-12-06 12:00:00"# date -s "20131206 12:00:00"date 是显示的系统OS时间clock 是显示Bios的时间查看硬件时间（BIOS的）：hwclock [-rw] -r 查看现有BIOS时间，默认为－r参数 -w 将现在的linux系统时间写入BIOS中 -s (systohc)将硬件时间调整为和目前的系统时间一样# hwclock -s # hwclock -w 当我们进行完 Linux 时间的校时后，还需要以 hwclock -w 来更新 BIOS 的时间，因为每次开机的时候，系统会重新由 BIOS 将时间读出来，所以， BIOS 才是重要的时间依据。# hwclock2013年09月26日 星期四 11时49分10秒 -1.002805 seconds修改系统时间（date）后，要同步BIOS时钟，强制把系统时间写入CMOS：# clock -w 或者# hwclock -w 三、实现Internet时间同步（这里可以忽略上面两步）123456789101112131415161718192021222324方法1. 开机的时候自动网络校时(首先有自己的时间服务器)： # cat /etc/rc.d/rc.local /usr/sbin/ntpdate -u 192.168.0.2 192.168.0.3 192.168.0.4;/sbin/hwclock -w后面的ip对应的是局域网内需要时间相同同步的主机。方法2. 设定计划任务# yum -y install ntpdate # 安装时间同步命令# crontab -l(以下方法任选其一)*/5 * * * * root ntpdate 210.72.145.44;hwclock -w #每隔半个小时与中国国家授时中心服务器同步一次时间*/5 * * * * root ntpdate asia.pool.ntp.org;hwclock -w*/5 * * * * root ntpdate 0.centos.pool.ntp.org;hwclock -w手动和时间服务器校准时间：1.首先关闭ntpd服务：# service ntpd stop2.然后和时间服务器校准：# ntpdate asia.pool.ntp.org3.同步BIOS时间：# hwclock -w4.校准后然后开启ntpd服务# service ntpd start]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置]]></title>
    <url>%2F2017%2F12%2F19%2FNginx%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如果是使用apt-get安装的nginx,配置文件目录在: /etc/nginx/cd到这个目录之后,ls查看所有文件: nginx.conf 这个是nginx的主配置文件,里面包含了当前目录的所有配置文件,只不过有的是注释状态,需要的时候自行开启(后面几个常用的) conf.d这是一个目录,里面可以写我们自己自定义的配置文件,文件结尾一定是.conf才可以生效(当然也可以通过修改nginx.conf来取消这个限制) sites-enabled这里面的配置文件其实就是sites-available里面的配置文件的软连接,但是由于nginx.conf默认包含的是这个文件夹,所以我们在sites-available里面建立了新的站点之后,还要建立个软连接到sites-enabled里面才行 sites-available这里是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机 多站点配置Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.为什么要配置多站点: 当我们有了一个服务器之后,为了不浪费服务器的资源,我们可以在一个服务器上放置多个网站项目,它们共同使用80端口,通过不同的servername来区分不同的网站项目,在实际上线的项目中,这个servername就是我们的域名啦具体配置(我们只举例一个,多个重复操作就行): 默认已经有一个站点了,就是defalt,在sites-available里面有一个default文件,就是默认站点的配置,servername是localhost不建议直接修改这个默认站点,我们可以复制一个: 1234567891011121314151617181920212223242526272829upstream airobot &#123; server 127.0.0.1:3001; keepalive 64;&#125;server &#123; #listen 80; listen 443; server_name *.ai-robotics.cn; #ai-robotics.cn www.ai-robotics.cn; #access_log /usr/local/log/test.log; ssl on; ssl_certificate /etc/nginx/1_www.ai-robotics.cn_bundle.crt; ssl_certificate_key /etc/nginx/2_www.ai-robotics.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host:443; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection ""; proxy_pass https://airobot; client_max_body_size 128M; &#125;&#125; 12$ ln -s /etc/ngix/sites-available/web1.com /etc/nginx/sites-enabled/web1.com$ nginx -s reload 反向代理 正向代理: 正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。主要为了越过局域网内的防火墙实现访问网站 反向代理: 反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。为了将防火墙后面的服务器提供给Internet用户访问也可以实现负载均衡,动静分离,url策略 负载均衡前期准备:123nginx服务器 192.168.1.100web服务器1 192.168.1.101web服务器2 192.168.1.102 修改配置文件:1vim /etc/nginx/sites-available/default 这样配置:123456789101112131415upstream a.com &#123; server 192.168.1.101:80; #有多少个服务器就添加多少个ip server 192.168.1.102:80;&#125;server&#123; listen 80; server_name a.com; location / &#123; proxy_pass http://a.com; #这个地址一定是上面定义的负载均衡的名字 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; ps:nginx主服务器也可以当做一个负载均衡服务器,但是由于80端口已经给负载均衡食用了,所有如果我们还使用80端口的话,就会造成一个死循环,我们可以再给主服务器添加一个服务器,并使用不同的8080端口,这样,主服务器也可以当做一个负载均衡的子服务器了,不会造成资源的浪费:123456789101112server&#123; listen 8080; server_name a.com; index index.html; root /data0/htdocs/www;&#125;upstream a.com &#123; server 192.168.5.126:80; server 192.168.5.27:80; server 127.0.0.1:8080;&#125; 1234重启nginx服务器就可以查看效果了:/etc/init.d/nginx restartor nginx -s reload 扩展: 轮询(默认方式) 每个请求按时间顺序逐一分配到后端服务器,如果后端服务器down掉,能自动剔除 weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 1234upstream bakend &#123; server 192.168.159.10 weight=10; server 192.168.159.11 weight=10;&#125; ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream resinserver&#123; ip_hash; server 192.168.159.10:8080; server 192.168.159.11:8080;&#125; fair(第三方) 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream resinserver&#123; server server1; server server2; fair;&#125; url_hash（第三方) 例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 123456upstream resinserver&#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32;&#125; 注意: 定义负载均衡设备的Ip及设备状态1234567upstream resinserver&#123; ip_hash; server 127.0.0.1:8000 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6801; server 127.0.0.1:6802 backup;&#125; 在需要使用负载均衡的server中增加1proxy_pass http://resinserver/; 1234567891011每个设备的状态设置为: 1.down 表示单前的server暂时不参与负载 2.weight 默认为1.weight越大，负载的权重就越大。 3.max_fails 允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误 4.fail_timeout:max_fails次失败后，暂停的时间。 5.backup 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 client_body_in_file_only 设置为On 可以讲client post过来的数据记录到文件中用来做debug client_body_temp_path 设置记录文件的目录 可以设置最多3层目录 location 对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 动静分离 动静分离也是利用负载均衡的原理来实现的,为了便于管理,我们把ip分配的配置写在conf.d这个文件夹里面: 12cd conf.dvim upstream.conf 里面写上动静分离的分配(以PHP和静态文件为例子): 12345678910111213141516171819202122232425upstream php &#123; server 192.168.10.10:80 #php给这个服务器处理&#125; upstream static &#123; server 192.168.10.11:80 #html给这个服务器处理&#125; server&#123; listen 80; server_name a.com; location / &#123; #匹配所有静态资源文件用这个代理 proxy_pass http://static; #这个地址一定是上面定义的负载均衡的名字 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location ~ \.php$ &#123; #匹配php文件用这个代理 proxy_pass http://php; #这个地址一定是上面定义的负载均衡的名字 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux du 命令]]></title>
    <url>%2F2017%2F12%2F19%2Fdu%2F</url>
    <content type="text"><![CDATA[查看当前目录下的所有目录以及子目录的大小1234$ du -h$ du -ah#-h:用K、M、G的人性化形式显示#-a:显示目录和文件 只查看当前目录下的tmp目录(包含子目录)的大小12$ du -h tmp$ du -ah tmp 查看当前目录及其指定深度目录的大小12du -h –-max-depth=0#-–max-depth＝n:只深入到第n层目录，此处设置为0，即表示不深入到子目录 du命令的一些常用参数:1234567891011121314-a或-all 显示目录中个别文件的大小-b或-bytes 显示目录或文件大小时，以byte为单位-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和-D或--dereference-args 显示指定符号连接的源文件大小-h或--human-readable 以K，M，G为单位，提高信息的可读性-k或--kilobytes 以1024 bytes为单位-l或--count-links 重复计算硬件连接的文件-L或--dereference 显示选项中所指定符号连接的源文件大小-m或--megabytes 以1MB为单位-s或--summarize 仅显示总计-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小-X&lt;文件&gt;或--exclude-from=&lt;文件&gt;--exclude=&lt;目录或文件&gt; 略过指定的目录或文件--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略 查看设备使用率12df 用于查看设备的空间使用率$ df -lh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>du</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Gitlab Nginx 权限问题]]></title>
    <url>%2F2017%2F12%2F19%2FCentos%207%20Gitlab%20Nginx%20%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装完GitLab之后, 正常配置可以使用, 此时使用Gitlab自带的Nginx服务器.Gitlab比较消耗资源, 一般使用单独的服务器配置使用, 由于一些众所周知的原因, 有时需要使用服务器已安装的Nginx服务器, 不使用Gitlab自带的, 需要另做一下配置. 修改gitlab配置文件123456789$ sudo vim /etc/gitlab/gitlab.rb 搜索 /# nginx # nginx['enable'] = true # nginx['client_max_body_size'] = '250m' # nginx['redirect_http_to_https'] = false 修改 nginx['enable'] = false 配置Nginx 直接将gitlab自动生成的nginx配置复制到Nginx虚拟主机配置文件夹下 1cp /var/opt/gitlab/nginx/conf/gitlab-http.conf /etc/nginx/conf.d/ 或者 自己手动生成配置文件, 放置 /etc/nginx/sites-avalible, 并生成相应软链 检测配置 12$ nginx -t$ nginx -s reload 502问题查看日志12345$ more /etc/gitlab/nginx/gitlab_error.log2017/10/10 14:33:58 [crit] 8555#0: *13 connect() to unix:/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket failed (13: Permission denied) while connecting to upstream, client: 59.108.125.198, server: gitlab.wei.com, request: "GET / HTTP/1.1", upstream: "http://unix:/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket:/", host: "xxxxxxxxxx" Nginx没有访问gitlab的socket权限, nginx 用户无法执行sockets/gitlab.socket 文件123456789101112$ drwxr-x--- 2 git gitlab-www 4096 11月 3 15:57 sockets法1: chmod -R o+x /var/opt/gitlab/gitlab-rails/sockets法2: chmod 755 /var/opt/gitlab/gitlab-rails/sockets法3: 将Nginx用户加入gitlab-www组$ usermod -a -G gitlab-www nginx修改gitlab.rb搜索/# web_serverweb_server['external_users'] = ['nginx'] #这里与nginx进程执行用户一致 可通过ps -ef | grep nginx 查看# web_server['username'] = 'gitlab-www'# web_server['group'] = 'gitlab-www' ( 111: Connection refused )系统内存不足. 服务启动失败]]></content>
      <categories>
        <category>Linux</category>
        <category>Centos 7</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Gitlab</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 安装shadowsocks]]></title>
    <url>%2F2017%2F12%2F19%2FCentos%207%20shadowsocks%2F</url>
    <content type="text"><![CDATA[install shadowsocks1$ pip install shadowsocks config shadowsocks12345678910111213$ cd /etc$ mkdir shadowsocks$ cd shadowsocks$ vi config.json &#123; "server":"你的 ShadowSocks 服务器IP", "server_port":服务器端口, "local_port":本地端口, "password":"ShadowSocks 密码", "timeout":600, "method":"aes-256-cfb" &#125; run shadowsocks12345678$ sslocal -c /etc/shadowsocks/config.json# 如果已经在config.json 所在路径下, 可直接执行 sslocal# 如果想在后台一直运行shadowsocks $ nohup sslocal -c /etc/shadowsocks/config.json /dev/null 2&gt;&amp;1 &amp;# 关闭shadowsocks $ kill -9 pid privoxyShadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。 install privoxy1234567$ wget http://www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz$ tar -zxvf privoxy-3.0.26-stable-src.tar.gz$ cd privoxy-3.0.26-stable$ autuheader &amp;&amp; autoconf # 如果没有安装autoconf $ yum install -y autoconf$ ./configure$ make &amp;&amp; make install configure privoxy123$ sudo vim /usr/local/etc/privoxy/config$ listen-address 127.0.0.1:8118 #8118 是默认端口, 不用更改, 下面会用到$ forward-socks5t / 127.0.0.1:localport # localport 是shadowsocks/config.json 中的本地端口 run privoxy12$ useradd privoxy$ privoxy --user privoxy /usr/local/etc/privoxy/config configure profile123456$ sudo vim /etc/profile export http_proxy=http://127.0.0.1:8118 export https_proxy=http://127.0.0.1:8118 $ source /etc/profile]]></content>
      <categories>
        <category>Linux</category>
        <category>Centos 7</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Linux</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell - 变量引用, 用户输入, 超时, 文本读写]]></title>
    <url>%2F2017%2F12%2F19%2Fshell%20-%20%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%2C%20%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%2C%20%E8%B6%85%E6%97%B6%2C%20%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[变量和变量的引用方式Shell 的变量以 var= 的方式定义，以 $var 或者 ${var} 的方式使用。Shell 的变量没有类型的分别，实际就是一个字符串。因此 Shell 变量的使用和字符串密不可分。这一节先介绍一下变量的一些特殊的引用方法。 123456789$var/$&#123;var&#125; - 最基本的用法，返回变量 var 的值——一个字符串。$&#123;var-"something"&#125; - 当 var 没有被预先定义时，返回 "something"。$&#123;var：-"something"&#125; - 当 var 没有被预先定义，或者被定义为空时，返回 "something"。$&#123;var="something"&#125; - 当 var 没有被预先定义时，返回 "something"，同时设置 var="something"。$&#123;var:="something"&#125; - 当 var 没有被预先定义，或者被定义为空时，返回 "something"，同时设置 var="something"。$&#123;var?"something"&#125; - 当 var 没有被预先定义时，返回 "something"，而后终止脚本。$&#123;var:?"something"&#125; - 当 var 没有被预先定义，或者被定义为空时，返回 "something"，而后终止脚本。$&#123;var+"something"&#125; - 当 var 已经被定义时，返回 "something"。$&#123;var:+"something"&#125; - 当 var 已经被定义并且不为空时，返回 "something"。 12345678910111213141516171819202122232425262728示例$ echo $&#123;var&#125;$ echo $&#123;#var&#125; # return the length of $&#123;var&#125;0$ echo $&#123;var-"hello"&#125;hello$ echo $&#123;var&#125;$ var=""$ echo $&#123;var-"hello"&#125;$ echo $&#123;var:-"hello"&#125;hello$ echo $&#123;var&#125;$ echo $&#123;#var&#125;0$ unset var$ echo $&#123;var="hello"&#125;hello$ echo $&#123;var&#125;hello$ unset var; var=""$ echo $&#123;var:="hello"&#125;hello$ echo $&#123;#var&#125;5 圆括号的使用除了花括号之外，$ 符号还可以搭配圆括号使用。基本有两种用法： $(command) - 返回 command 执行完毕的输出结果，相当于 command 。 $((expression)) - 执行算术运算 expression 并返回运算结果，例如 $((2 + 3 * 2)) 返回 8。 按长度截取字符串当 Shell 变量中保存着内容时，我们就可以按索引和长度截取字符串中的内容。Shell 变量的索引从 0 开始。主要有两种方式： ${var:pos} - 返回从 pos 开始一直到末尾的字符串。 ${var:pos:len} - 返回从 pos 开始长度为 len 的字符串。1234567891011121314示例$ var="hello"$ echo $&#123;var&#125;hello$ echo $&#123;#var&#125;5$ echo $&#123;var:3&#125;lo$ echo $&#123;var:6&#125;$ echo $&#123;var:0:3&#125;hel$ echo $&#123;var:0:6&#125;hello 按匹配截取字符串Shell 的变量支持从左或者从右删除包含通配符的子串： 使用 # 或者 ## 从左删除子串； 使用 % 或者 %% 从右删除子串。 单符号的版本（#/%）尽可能短地匹配子串；双符号的版本（##/%%）尽可能长地匹配子串。 123456789101112示例$ var="hellohello"$ echo $&#123;var&#125;hellohello$ echo $&#123;var#*ll&#125;ohello$ echo $&#123;var##*ll&#125;o$ echo $&#123;var%ll*&#125;hellohe$ echo $&#123;var%%ll*&#125;he 字符串替换Shell 的变量也支持字符串替换。 ${var/FROM/TO} - 将 $var 中的第一个 FROM 匹配的子串替换成 TO，然后返回。 ${var//FROM/TO} - 将 $var 中所有的 FROM 匹配的子串替换成 TO，然后返回。 ${var/#FROM/TO} - 若 $var 从第一个字符开始能够匹配 FROM，则替换成 TO 然后返回；否则直接返回 ${var}。 ${var/%FROM/TO} - 若 $var 从最后一个字符开始能够匹配 FROM，则替换成 TO 然后返回；否则直接返回 ${var}。123456789101112131415161718示例$ var="hellohello"$ echo $&#123;var&#125;hellohello$ echo $&#123;var/ll/xx&#125;hexxohello$ echo $&#123;var//ll/xx&#125;hexxohexxo$ echo $&#123;var/#*ll/xx&#125;xxo$ echo $&#123;var/#*lx/xx&#125;hellohello$ echo $&#123;var/%ll*/xx&#125;hexx$ echo $&#123;var/%lx*/xx&#125;hellohello$ echo $&#123;var&#125;hellohello 获得用户输入read1.基本读入read接受用户从键盘的输入：1234#!/bin/bashecho -n "Enter your name:" #-n选项移调末尾换行符，不换行read nameecho "Hello $name" 123输出结果Enter your name: caishuHello caishu 12345read的-p选项，直接置顶参数：read -p "Enter your name:" name echo "Hello $name"read命令会为每个提示符分配变量，若提示符用完了，则将剩下的所有变量，分配给最后一个提示符。 若在read命中不指定变量，read命令会将它收到的任何数据都放进特殊环境变量REPLY中，1234567$read -p "Enter your para:" para1 para2 para3; echo "your parameter is $para1,$para2,$para3..."Enter your para:1 2 3 4 5 6 7your parameter is 1,2,34567...$read -p "Enter your para:" ; echo "your parameter is $REPLY"Enter your para:caishuyour parameter is caishu 2.超时 和 计数123456-t：使用read命令时，会一直等用户输入，可以用-t选项来制定计时器，当计时器过期后，read命令会返回一个非零退出状态码。read -t 5 -p "Please enter your name: " name #会等5s，可以改变数字以改变等的时间-n和数字：对输入的字符计数，当输入的字符达到预设的字符数时，它会自动退出，将输入的数据赋给变量。read -n1 -p "Please enter your name: " name #只接受一个字符，空格也是字符。 3.隐藏方式读取-s 阻止用户的输入显示在显示器上，（实际上，数据会被显示，只是read命令将文本颜色设置成跟背景颜色一样） 4.从文件中读取read line 会从文本中读取一行，用cat命令的输出通过管道传给含有read的while命令12345678910#!/bin/bash#read data from a filecount=1cat filename | while read linedo echo "Line $count: $line count=$[ $count + 1 ]doneecho "Finished processing the file"]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell - 参数解析三种方式(手工, getopts, getopt)]]></title>
    <url>%2F2017%2F12%2F19%2Fshell%20-%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E6%89%8B%E5%B7%A5%2C%20getopts%2C%20getopt)%2F</url>
    <content type="text"><![CDATA[选项和参数: Argument, Option: 中文对应「选项」，形如 -a, –save 的都是选项；选项可以接收参数（Parameter），也可以不接受参数。其中-a 为短选项, –save 为长选项 Flag: 中文对应「标签」，形如 -v(verbose)；标签是布尔值，不接受参数。 bash shell 汇总有三种解析参数的方式: 手工处理: 大多数简单的命令 getopts: 大多数复杂命令, 不支持长选项 getopt: 支持长选项, getopts和getopt功能相似但又不完全相同，其中getopt是独立的可执行文件，而getopts是由Bash内置的 1$ ./test.sh -v -f -out /test.log --prefix=/home 如果执行是permission denied: test.sh, 运行 chmod +x test.sh 赋予其可执行权限 或是 通过sh/bash 命令运行 手工处理 $0 : 在用sh 或者 ./执行脚本时，指的是脚本名，用source或.执行时，永运是bash，这也反应了sh 或者 ./执行脚本的原理和source的方式是不同的. $1 : -v,第一个参数. $2 : -f $3 : -out $4 : /test.log 依次类推 $5 $6 … $# : 参数的个数，不包括命令本身，上例中\$#为5. $@ : 参数本身的列表，也不包括命令本身，如上例为 -v -f -out /test.log –prefix=/home $* : 参数本身的列表，也不包括命令本身，但”$*” 和”\$@”(加引号)并不同，”$*“将所有的参数解释成一个字符串，而”$@”是一个参数数组。如下例所示： 1234567891011#!/bin/bashfor arg in "$*"do echo $argdonefor arg in "$@"do echo $argdone 123456-v -f -out /test.log --prefix=/home-v-f-out/test.log--prefix=/home 也就是说手工处理方式高度依赖命令行中参数的位置, 只适合简单的参数较少的命令, 手工处理方式能满足大多数的简单需求，配合shift使用也能构造出强大的功能 getopts先来看看参数传递的典型用法: ./test.sh -a -b -c ： 短选项，各选项不需参数 ./test.sh -abc ： 短选项，和上一种方法的效果一样，只是将所有的选项写在一起。 ./test.sh -a args -b -c ：短选项，其中-a需要参数，而-b -c不需参数。 ./test.sh –a-long=args –b-long ：长选项 getopts 用法变量 OPTIND: getopts 在解析传入 Shell 脚本的参数时（也就是 $@），并不会执行 shift 操作，而是通过变量 OPTIND 来记住接下来要解析的参数的位置。 OPTARG: getopts 在解析到选项的参数时，就会将参数保存在 OPTARG 变量当中；如果 getopts 遇到不合法的选项，择把选项本身保存在 OPTARG 当中。 1getopts OPTSTRING VARNAME [ARGS...] OPTSTRING 记录合法的选项列表（以及参数情况) VARNAME 则传入一个 Shell 变量的名字，用于保存 getopts 解析到的选项的名字（而不是参数值，参数值保存在 OPTARG 里） ATGS… 是可选的，默认是 $@，即传入 Shell 脚本的全部参数 通常来说，我们会将 getopts 放在 while 循环的条件判断式中。getopts 在顺利解析到参数的时候，会返回 TRUE；否则返回 FALSE，用以结束循环. 123while getopts ...; do ...done getopts 在两种情况下会停止解析并返回 FALSE： getopts 读入不以 - 开始的字符串；比如: sh test.sh flag getopts 读入连续的两个 - (i.e. –) OPTSTRING通过 OPTSTRING getopts 知道哪些参数是合法的，哪些参数又是需要接受参数的。OPTSTRING 的格式很简单，就是一个简单的字符串。字符串里，每一个字母（大小写均可，但区分大小写）都是一个选项的名字。 值得一提的是冒号 (:)在 OPTSTRING 中，冒号有两种含义： 首位的 : 表示「不打印错误信息」； 紧邻字母（选项名字）的 : 表示该选项接收一个参数。 例如: 12getopts aBcD VARNAME // 该脚本接受四个标签-a, -B, -c, -D, 均不接受参数getopts :aB:Cd VARNAME // 该脚本接受两个标签-a, -B, 两个短选项-C, -d 下面是实例: 1234567891011121314151617181920212223#!/bin/bashecho "$@"while getopts ":a:bc:" opt; do #不打印错误信息, -a -c需要参数 -b 不需要传参 case $opt in a) echo "-a arg:$OPTARG index:$OPTIND" #$OPTIND指的下一个选项的index ;; b) echo "-b arg:$OPTARG index:$OPTIND" ;; c) echo "-c arg:$OPTARG index:$OPTIND" ;; :) echo "Option -$OPTARG requires an argument." exit 1 ;; ?) #当有不认识的选项的时候arg为? echo "Invalid option: -$OPTARG index:$OPTIND" ;; esacdone 1234567891011121314151617181920212223$ ./test.sh -a ssss -b ssss -c &gt;&gt; -a ssss -b ssss -c -a arg:ssss index:3 -b arg: index:4 #-b并不接受参数, 解析到ssss时直接停止解析$ ./test.sh -c xxx -b -a ssssss &gt;&gt; -c xxx -b -a ssssss -c arg:xxx index:3 -b arg: index:4 -a arg:ssssss index:6$ ./test.sh -c -b -a ssssss // -c 后面没有参数 -b会解析成-c参数 &gt;&gt; -c -b -a ssssss -c arg:-b -a arg:ssssss $ ./test.sh -a &gt;&gt; a Option -a requires an argument. getopt getopt较bash内置的getopts更强大，其不仅支持短参-s，还支持–longopt的长参数，甚至支持-longopt的简化参数。相较于getopts ，getopts 不但支持长短选项，其还支持选项和参数放在一起写。 getopt 用法1getopt [options] -o|--options optstring [options] [--] parameters 选项说明： -a：使getopt长参数支持”-“符号打头，必须与-l同时使用 -l：后面接getopt支持长参数列表 -n program：如果getopt处理参数返回错误，会指出是谁处理的这个错误，这个在调用多个脚本时，很有用 -o：后面接短参数列表，这种用法与getopts类似 -u：不给参数列表加引号，默认是加引号的（不使用-u选项），例如在加引号的时候 –longoption “arg1 arg2” ，只会取到”arg1”，而不是完整的”arg1 arg2” 12345678910111213141516171819202122232425262728#!/bin/bash# A small example program for using the new getopt(1) program.# This program will only work with bash(1)# Note that we use `"$@"' to let each command-line parameter expand to a# separate word. The quotes around `$@' are essential!# We need TEMP as the `eval set --' would nuke the return value of getopt.TEMP=`getopt -o ab:c:: --long a-long,b-long:,c-long:: -n 'example.bash' -- "$@"`if [ $? != 0 ] ; then echo "Terminating..." &gt;&amp;2 ; exit 1 ; fi# Note the quotes around `$TEMP': they are essential!eval set -- "$TEMP"while true ; do case "$1" in -a|--a-long) echo "Option a" ; shift ;; -b|--b-long) echo "Option b, argument \`$2'" ; shift 2 ;; -c|--c-long) # c has an optional argument. As we are in quoted mode, # an empty parameter will be generated if its optional # argument is not found. case "$2" in "") echo "Option c, no argument"; shift 2 ;; *) echo "Option c, argument \`$2'" ; shift 2 ;; esac ;; --) shift ; break ;; *) echo "Internal error!" ; exit 1 ;; esacdoneecho "Remaining arguments:"for arg do echo '--&gt; '"\`$arg'" ; done 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/bin/bashARGS=`getopt -a -o I:D:T:e:k:LMSsth -l instence:,database:,table:,excute:,key:,list,master,slave,status,tableview,help -- "$@"`function usage() &#123; echo 'help'&#125;[ $? -ne 0 ] &amp;&amp; usage#set -- "$&#123;ARGS&#125;"eval set -- "$&#123;ARGS&#125;"while truedo case "$1" in -I|--instence) instence="$2" shift ;; -D|--database) database="$2" shift ;; -T|--table) table="$2" shift ;; -e|--excute) excute="yes" shift ;; -k|--key) key="$2" shift ;; -L|--list) LIST="yes" ;; -M|--master) MASTER="yes" ;; -S|--slave) SLAVE="yes" ;; -A|--alldb) ALLDB="yes" ;; -s|--status) STATUS="yes" ;; -t|--tableview) TABLEVIEW="yes" ;; -h|--help) usage ;; --) shift break ;; esacshiftdone echo instence:$instence database:$database table:$table excute:$excute key:$key 选项标准化在创建shell脚本时，尽量保持选项与Linux通用的选项含义相同，Linux通用选项有：12345678910111213141516-a 显示所有对象-c 生产一个计数-d 指定一个目录-e 扩展一个对象-f 指定读入数据的文件-h 显示命令的帮助信息-i 忽略文本大小写-l 产生输出得长格式文本-n 使用非交互模式-o 指定将所有输出重定向到输出文件-q 以安静模式运行 -r 递归的处理目录和文件-s 以安静模式运行 -v 生成详细输出 -x 排除某个对象 -y 对所有问题回答yes]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式 - 贪婪模式 回溯]]></title>
    <url>%2F2017%2F12%2F04%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20-%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%20%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本篇为转载:作者：撒网要见鱼链接：http://www.jianshu.com/p/a641aab7ee97 贪婪模式与非贪婪模式贪婪匹配模式定义正则表达式去匹配时，会尽量多的匹配符合条件的内容 标识符+，?，*，{n}，{n,}，{n,m} 匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容 示例123456var str='aacbacbc';var reg=/a.*b/;var res=str.match(reg);// aacbacb index为0console.log(res); 上例中，匹配到第一个a后，开始匹配.*，由于是贪婪模式，它会一直往后匹配，直到最后一个满足条件的b为止，因此匹配结果是aacbacb 123456var str='aacbacbc';var reg=/ac.*b/;var res=str.match(reg);// acbacb index为1console.log(res); 第一个匹配的是a，然后再匹配下一个字符a时，和正则不匹配，因此匹配失败，index挪到1，接下来匹配成功了ac，继续往下匹配，由于是贪婪模式，尽可能多的去匹配结果，直到最后一个符合要求的b为止，因此匹配结果是acbacb 非贪婪匹配模式定义正则表达式去匹配时，会尽量少的匹配符合条件的内容也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配) 标识符+?，??，*?，{n}?，{n,}?，{n,m}? 可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个? 示例123456var str='aacbacbc';var reg=/a.*?b/;var res=str.match(reg);// aacb index为0console.log(res); 上例中，匹配到第一个a后，开始匹配.*?，由于是非贪婪模式，它在匹配到了第一个b后，就匹配成功了，因此匹配结果是aacb 为什么是aacb而不是acb呢？因为前面有提到过一个正在匹配的优先规则: 最先开始的匹配拥有最高的优先权第一个a匹配到了，只要之后没有发生匹配失败的情况，它就会一直匹配下去，直到匹配成功 123456var str='aacbacbc';var reg=/ac.*?b/;var res=str.match(reg);// acb index为1console.log(res); 先匹配的a，接下来匹配第二个a时，匹配失败了index变为1，继续匹配ac成功，继续匹配b，由于是非贪婪模式，此时acb已经满足了正则的最低要求了，因此匹配成功，结果为acb 123456789101112var str='aacbacbc';var reg=/a.*?/;var res=str.match(reg);// a index为0console.log(res);var reg2=/a.*/;var res2=str.match(reg2);// aacbacbc index为0console.log(res2); 这一个例子则是对示例1的补充，可以发现，当后面没有b时，由于是非贪婪模式，匹配到第一个a就直接匹配成功了而后面一个贪婪模式的匹配则是会匹配所有 实例练习在初步理解了贪婪模式与非贪婪模式后，可以通过练习加深理解 提取HTML中的Div标签 给出一个HTML字符串，如下 12&lt;div&gt;&lt;span&gt;用户:&lt;span/&gt;&lt;span&gt;张三&lt;span/&gt;&lt;/div&gt;&lt;div&gt;&lt;span&gt;密码:&lt;span/&gt;&lt;span&gt;123456&lt;span/&gt;&lt;/div&gt; 需求: 提取出div包裹的内容(包括div标签本身)，并将各个结果存入数组 代码: 通过非贪婪模式的全局匹配来完成，如下 12345var reg=/&lt;div&gt;.*?&lt;\/div&gt;/g;var res=str.match(reg);// ["&lt;div&gt;&lt;span&gt;用户:&lt;span/&gt;&lt;span&gt;张三&lt;span/&gt;&lt;/div&gt;", "&lt;div&gt;&lt;span&gt;密码:&lt;span/&gt;&lt;span&gt;123456&lt;span/&gt;&lt;/div&gt;"]console.log(res); 详解: 用到了两个知识点，123456789.\*?的非贪婪模式匹配以及g全局匹配&lt;div&gt;.\*?&lt;\/div&gt;代表每次只会匹配一次div，这样可以确保每一个div不会越界最后的g代表全局匹配，即第一次匹配成功后，会将匹配结果放入数组，然后从下一个index重新开始匹配新的结果另外: 假设使用了/&lt;div&gt;.\*&lt;\/div&gt;/g进行贪婪模式的匹配，结果则是\["&lt;div&gt;&lt;span&gt;用户:&lt;span/&gt;&lt;span&gt;张三&lt;span/&gt;&lt;/div&gt;&lt;div&gt;&lt;span&gt;密码:&lt;span/&gt;&lt;span&gt;123456&lt;span/&gt;&lt;/div&gt;"]因为贪婪模式匹配了第一个&lt;div&gt;后会无限贪婪的匹配接下来的字符，直到最后一个符合条件的&lt;/div&gt;为止，导致了将中间所有的div标签都一起匹配上了 提取两个””中的子串，其中不能再包含””示例引用自: 正则表达式之 贪婪与非贪婪模式详解(http://www.jb51.net/article/31491.htm)1"The phrase \"regular expression\" is called \"Regex\" for short" 需求: 提取两个引号之间的子串，其中不能再包括引号，例如上述的提取结果应该是: “regular expression” 与 “Regex”(每一个结束的”后面都接空格)12345678错误解法: 通过如下的非贪婪匹配(请注意空格)var str='"The phrase \"regular expression\" is called \"Regex\" for short"';var reg=/".\*?" /g;var res=str.match(reg);// \['"The phrase "regular expression" ', '"Regex" ']console.log(res); 可以看到，上述的匹配完全就是匹配错误了，这个正则匹配到第一个符合条件的”+空格后就自动停下来了 正确解法: 使用贪婪模式进行匹配12345var reg=/"\[^"]\*" /g;var res=str.match(reg);// \['"regular expression" ', '"Regex" ']console.log(res); 这个匹配中 从第一个”开始匹配，接下来到12位时(“r的”)，不满足{FNXX==XXFN}，也不满足之后的”+空格，因此匹配失败了，index挪到下一个，开始下一次匹配 第二个匹配从”r的”开始，一直匹配到n”空格的空格，这一组刚刚好匹配成功(因为最后符合了正则的”空格)，匹配好了”regular expression”空格 第三个匹配匹配到了”Regex”空格(过程不再复述) 到最后时，仅剩一个”直接匹配失败(因为首先得符合”才能开始挣扎匹配) 至此，正则匹配结束，匹配成功，并且符合预期 最后: 这个例子相对来说复杂一点，如要更好的理解，可以参考引用来源中的文章，里面有就原理进行介绍另外，参考文章中还有对非贪婪模式的匹配失败，回溯影响性能等特性进行原理分析与讲解 回溯现象与匹配失败你真的已经理解了贪婪模式和非贪婪模式么？ 回溯现象不知道对上面最后例子中提到的回溯这词有没有概念？这里仍然以上例引用来源中的示例来分析 原字符串 “Regex” 贪婪匹配过程分析“.*“第一个”取得控制权，匹配正则中的”，匹配成功，控制权交给.* .取得控制权后，匹配接下来的字符，.代表匹配任何字符，代表可匹配可不匹配，这属于贪婪模式的标识符，会优先尝试匹配，于是接下来从1位置处的R开始匹配，依次成功匹配了R，e，g，e，x，接着继续匹配最后一个字符”，匹配成功，这时候已经匹配到了字符串的结尾，所以.*匹配结束，将控制符交给正则式中最后的” “取得控制权后，由于已经是到了字符串的结尾，因此匹配失败，向前查找可供回溯的状态，控制权交给.，.让出一个字符”，再把控制权交给”，此时刚好匹配成功 至此，整个正则表达式匹配完毕，匹配结果为”Regex”，匹配过程中回溯了1次 非贪婪匹配表达式1".\*?" 第一个”取得控制权，匹配正则中的”，匹配成功，控制权交给.*? .*?取得控制权后，由于这是非贪婪模式下的标识符，因此在可匹配可不匹配的情况下会优先不匹配，因此尝试不匹配任何内容，将控制权交给”，此时index在1处(R字符处) “取得控制权后，开始匹配1处的R，匹配失败，向前查找可供回溯的状态，控制权交给.?，.?吃进一个字符，index到了2处，再把控制权交给” “取得控制权后，开始匹配2处的e，匹配失败，重复上述的回溯过程，直到.*?吃进了x字符，再将控制权交给” “取得控制权后，开始匹配6处的”，匹配成功 至此，整个正则表达式匹配完毕，匹配结果为”Regex”，匹配过程中回溯了5次 优化去除回溯 上述的贪婪匹配中，出现了一次回溯现象，其实也可以通过优化表达式来防止回溯的，比如1"\[^"]\*" 这个表达式中构建了一个子表达式-中的^”，它的作用是排除”匹配，这样*的贪婪匹配就不会主动吃进”，这样最后就直接是”匹配”，匹配成功，不会进行回溯 总结上述的分析中可以看出，在匹配成功的情况下，贪婪模式进行了更少的回溯(可以自行通过更多的实验进行验证)，因此在应用中，在对正则掌握不是很精通的情况下，可以优先考虑贪婪模式的匹配，这样可以避免很多性能上的问题 匹配失败的情况 上述的回溯分析都是基于匹配成功的情况，那如果是匹配失败呢？12var str = '"Regex'var reg = /"\[^"]\*"/g; 这个原字符中，没有最后的”，因此匹配是会失败的，它的过程大致如下 “匹配”，接着的^”与*匹配R，e，g，e，x 接着到了最后，”获取控制权，由于到了最后，开始回溯 依次回溯的结果是让出x，e，g，e，R，直到已经无法再让出字符，第一轮匹配失败 接着index开始往下挪，依次用”匹配R，e，g，e，x都失败了，一直到最后也没有再匹配到结果，因此此次正则表达式的匹配失败，没有匹配到结果(或者返回null) 那非贪婪模式呢？1/"\[^"]\*?"/g “匹配”，接着尝试不匹配，”匹配R，失败，然后回溯，吃进R 接下来类似于上一步，依次回溯吃进e，g，e，x，一直到最后，再次回溯想吃进时，已经到了字符串结尾了，无法继续，因此第一轮匹配失败 接着index开始往下挪，依次用”匹配R，e，g，e，x都失败了，返回null 总结通过匹配失败的例子可以看出贪婪和非贪婪的模式区别。贪婪是先吃进，回溯再让出，非贪婪是先忽略，回溯再吃进 而且，在匹配失败的情况下，贪婪模式也会进行不少的回溯(非贪婪当然一直都很多回溯) 但是，实际情况中是可以通过子表达式优化的，比如构建^xxx，可以当匹配到不符合条件的时候提前匹配失败，这样就会少很多回溯12var str = '"cccccc'var reg = /"\[^"c]\*"/g; 这个由于直接排除了c，因此*不会吃进它，直接就匹配失败了，减少了很多回溯(当然，上述只是最简单的例子，实际情况要更复杂) 非贪婪匹配的效率12345可能有不少的人和我一样，有过这样的经历：当我们要匹配类似 "&lt;td&gt;内容&lt;/td&gt;" 或者 "[b]加粗[/b]" 这样的文本时，我们根据正向预搜索功能写出这样的表达式："&lt;td&gt;([^&lt;]|&lt;(?!/td&gt;))*&lt;/td&gt;" 或者 "&lt;td&gt;((?!&lt;/td&gt;).)*&lt;/td&gt;"。当发现非贪婪匹配之时，恍然大悟，同样功能的表达式可以写得如此简单："&lt;td&gt;.*?&lt;/td&gt;"。 顿时间如获至宝，凡是按边界匹配的地方，尽量使用简捷的非贪婪匹配 ".*?"。特别是对于复杂的表达式来说，采用非贪婪匹配 ".*?" 写出来的表达式的确是简练了许多。然而，当一个表达式中，有多个非贪婪匹配时，或者多个未知匹配次数的表达式时，这个表达式将可能存在效率上的陷阱。有时候，匹配速度慢得莫名奇妙，甚至开始怀疑正则表达式是否实用。 效率陷阱的产生： 在本站基础文章里，对非贪婪匹配的描述中说到：“如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。” 具体的匹配过程是这样的： “非贪婪部分” 先匹配最少次数，然后尝试匹配 “右侧的表达式”。 如果右侧的表达式匹配成功，则整个表达式匹配结束。如果右侧表达式匹配失败，则 “非贪婪部分” 将增加匹配一次，然后再尝试匹配 “右侧的表达式”。 如果右侧的表达式又匹配失败，则 “非贪婪部分” 将再增加匹配一次。再尝试匹配 “右侧的表达式”。 依此类推，最后得到的结果是 “非贪婪部分” 以尽可能少的匹配次数，使整个表达式匹配成功。或者最终仍然匹配失败。 当一个表达式中有多个非贪婪匹配，以表达式 “d(\w+?)d(\w+?)z” 为例，对于第一个括号中的 “\w+?” 来说，右边的 “d(\w+?)z” 属于它的 “右侧的表达式”，对于第二个括号中的 “\w+?” 来说，右边的 “z” 属于它的 “右侧的表达式”。 当 “z” 匹配失败时，第二个 “\w+?” 会 “增加匹配一次”，再尝试匹配 “z”。如果第二个 “\w+?” 无论怎样 “增加匹配次数”，直至整篇文本结束，”z” 都不能匹配，那么表示 “d(\w+?)z” 匹配失败，也就是说第一个 “\w+?” 的 “右侧” 匹配失败。此时，第一个 “\w+?” 会增加匹配一次，然后再进行 “d(\w+?)z” 的匹配。循环前面所讲的过程，直至第一个 “\w+?” 无论怎么 “增加匹配次数”，后边的 “d(\w+?)z” 都不能匹配时，整个表达式才宣告匹配失败。 其实，为了使整个表达式匹配成功，贪婪匹配也会适当的“让出”已经匹配的字符。因此贪婪匹配也有类似的情况。当一个表达式中有较多的未知匹配次数的表达式时，为了让整个表达式匹配成功，各个贪婪或非贪婪的表达式都要进行尝试减少或增加匹配次数，由此容易形成一个大循环的尝试，造成了很长的匹配时间。本文之所以称之为“陷阱”，因为这种效率问题往往不易察觉。 举例：”d(\w+?)d(\w+?)d(\w+?)z” 匹配 “ddddddddddd…” 时，将花费较长一段时间才能判断出匹配失败 。 效率陷阱的避免： 避免效率陷阱的原则是：避免“多重循环”的“尝试匹配”。并不是说非贪婪匹配就是不好的，只是在运用非贪婪匹配的时候，需要注意避免过多“循环尝试”的问题。1234567情况一：对于只有一个非贪婪或者贪婪匹配的表达式来说，不存在效率陷阱。也就是说，要匹配类似 "&lt;td&gt; 内容 &lt;/td&gt;" 这样的文本，表达式 "&lt;td&gt;([^&lt;]|&lt;(?!/td&gt;))*&lt;/td&gt;" 和 "&lt;td&gt;((?!&lt;/td&gt;).)*&lt;/td&gt;" 和 "&lt;td&gt;.*?&lt;/td&gt;" 的效率是完全相同的。情况二：如果一个表达式中有多个未知匹配次数的表达式，应防止进行不必要的尝试匹配。比如，对表达式 "&lt;script language='(.*?)'&gt;(.*?)&lt;/script&gt;" 来说， 如果前面部分表达式在遇到 "&lt;script language='vbscript'&gt;" 时匹配成功后，而后边的 "(.*?)&lt;/script&gt;" 却匹配失败，将导致第一个 ".*?" 增加匹配次数再尝试。而对于表达式真正目的，让第一个 ".*?" 增加匹配成“vbscript'&gt;”是不对的，因此这种尝试是不必要的尝试。因此，对依靠边界来识别的表达式，不要让未知匹配次数的部分跨过它的边界。前面的表达式中，第一个 ".*?" 应该改写成 "[^']*"。后边那个 ".*?" 的右边再没有未知匹配次数的表达式，因此这个非贪婪匹配没有效率陷阱。于是，这个匹配脚本块的表达式，应该写成："&lt;script language='([^']*)'&gt;(.*?)&lt;/script&gt;" 更好。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>RegEx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门指令]]></title>
    <url>%2F2017%2F12%2F04%2FDocker%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[镜像1.获取镜像12docker pull dl.dockerpool.com:5000/ubuntu:14.04(dl.dockerpool.com为注册服务器，5000为端口号，ubuntu为仓库名称，14.04是镜像也是版本号) 2.查看镜像信息1docker images(列出本地主机已有的所有镜像) 更改变迁信息12docker tag dl.dockerpool.com:5000/ubuntu:latest ubuntu:latestdocker inspect 000（000为镜像ID，显示这个镜像的详细信息） 3.搜寻镜像1docker search mysql （输出信息包括镜像名字、描述、星级、是否为官方创建、是否自动创建） 4.删除镜像1docker rmi dl.dockerpool.com:5000/ubuntu:latest 注：当有该镜像创建的容器存在时，镜像文件默认是无法删除的，所以删除镜像前最好是删除所有依赖该镜像的容器，请不要用强制删除。 5.创建镜像 有三种方法： a. 基于已有镜像的容器创建 1docker commit -m “add new image”-a "" 000(容器ID) test（新建image name） b. 基于本地模板导入 1cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04 c. 基于dockerfile创建 6.存出镜像1docker save -o ubuntu_14.04.tar ubuntu:14.04 7.载入镜像12docker load --input ubuntu_14.04.tar 或者docker load &lt; ubuntu_14.04.tar 8.上传镜像1docker push user/test:latest(user用户需要在dockerHub网站注册) 容器容器是镜像的一个运行实例，但它带有额外的可写层1.创建容器1docker create -it ubuntu:12.04 2.创建并启动容器1docker run -it ubuntu:12.04 /bin/bash 3.守护态运行1docker run -d ubuntu:12.04 4.查看容器信息1docker ps [-a -q 查看终止状态] 5.获取容器的输出信息1docker logs cet(cet是容器ID前三个字符) 6.终止容器1docker stop cet 7.启动容器1docker start cet 8.重启容器1docker restart cet 9.进入容器 1) attach命令 1docker attach nostalgic(nostalgic是docker的name) 缺点：所有窗口同步显示 2) exec命令 1docker exec -it 243... /bin/bash (243...为docker ID) 3) nsenter命令 a）找PID 1PID=$(docker-pid 243..) b）通过PID链接容器 1nsenter --target $PID --mount --uts --ipc --net --pid 10.删除容器1234docker rm [-f -l -v] cet-f 强行终止并删除-l 删除容器的链接，保留容器-v 删除挂载的数据卷 11.导出容器1docker export cet &gt;test.tar 12.导入容器（将容器快照导入到本地镜像库）123456cat test.tar | docker import - test/ubuntu:v1.0（重新指定标签为ubuntu的镜像名称，v1.0的版本号docker load 也可以导入镜像存储文件到本地镜像库，他比import方式的好处是：import导入镜像快照文件将丢失所有的历史记录和元数据信息。**注：**通过导出容器和导入容器可以实现容器迁移（拷贝文件） 仓库仓库是集中存放镜像的地方，一个注册服务器上有很多仓库，一个仓库中有很多镜像。 登录 1docker login 基本操作查找、上传、下载 自动创建 查看镜像 1http://www.dockerpool.com/downloads 更新镜像标签 1docker tag dl.dockerpool.com:5000/ubuntu:12.04 ubuntu:12.04(将前面的镜像更改为ubuntu:12.04) 创建私有仓库 1docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry(自动下载并启动registry容器，创建本地的私有仓库服务,默认仓库船舰的容器在/tmp/registry，可以通过-v参数来存放到指定路径上)7.管理私有仓库镜像 假设私有仓库地址为10.0.2.2，端口为5000， docker tag ubuntu:14.04 10.0.2.2:5000/test(更改标签名)docker push 10.0.2.2:5000/test(push镜像，会自动push到10.0.2.2地址的机器上)curl http://10.0.2.2:5000/v2/search(查看仓库10.0.2.2:5000中是否含有test镜像)docker pull 10.0.2.2:5000/test(在任何一台能访问到10.0.2.2地址的机器上下载镜像)``]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 7 安装 Docker Private Registry 和 Web UI]]></title>
    <url>%2F2017%2F12%2F04%2FCentos7%20%E5%AE%89%E8%A3%85%20Docker%20Private%20Registry%20%E5%92%8C%20Web%20UI%2F</url>
    <content type="text"><![CDATA[首先正确安装docker, 以下说明建立在此之上.注: 此示例并没有使用nginx服务器和SSL加密. use iptablesCentos 7 默认使用firewalld 而不是iptables管理防火墙, 如已使用iptables管理防火墙, 请跳过此步骤. install docker-composehttps://docs.docker.com/compose/reference/up/ 1$ pip2 install docker-compose docker run registry and registry-webhttps://github.com/mkuchin/docker-registry-web/tree/master/examples/auth-enabled 1. download examples files12$ curl -Ls https://github.com/mkuchin/docker-registry-web/releases/download/v0.1.2/examples.tar.gz | tar -xzv$ cd examples/auth-enabled/ 2. exec generate-keys.sh1$ ./generate-keys.sh 3. modify config file docker-compose.yml1$ vim docker-compose.yml 1registry:2.4.1 =&gt; registry:latest // latest 将image版本切换到最新版 修改 auth.token.realm1$ vim conf/registry/config.yml 1realm: http://localhost:8080/api/auth =&gt; realm: http://(ip/hostname):8080/api/auth 4. Start containers with docker-compose1$ docker-compose up -d 注: -d 后台运行, examples 默认采用-it 交互式运行方式, 关掉终端后, 进程将关闭 It will run docker registry (ip/hostname):5000 and web ui on http://(ip/hostname):8080/ 可以通过配置docker-compose.yml 文件设置一些启动参数如: restart: always(docker重启后自动运行) check if it working:Login into http://(ip/hostname):8080/ with admin/admin username/password Create test user and grant ‘write-all’ role to that user. local check: 123456docker login localhost:5000docker pull hello-worlddocker tag hello-world localhost:5000/hello-world:latestdocker push localhost:5000/hello-world:latestdocker rmi localhost:5000/hello-world:latestdocker run localhost:5000/hello-world:latest remote check: 123456docker login (ip/hostname):5000docker pull hello-worlddocker tag hello-world (ip/hostname):5000/hello-world:latestdocker push (ip/hostname):5000/hello-world:latestdocker rmi (ip/hostname):5000/hello-world:latestdocker run (ip/hostname):5000/hello-world:latest 问题1. iptables 报 No chain/target/match by that name参见: http://blog.jobbole.com/98869/关闭docker, 重启iptables, 再启动docker, 简单说就是docker应该在iptables之后启动 2. 登录远程私有仓库时 http: server gave HTTP response to HTTPS client1Error response from daemon: Get https://(ip/hostname)rs/: http: server gave HTTP response to HTTPS client 本地设置 DOCKER_OPTS=”–insecure-registry myregistrydomain.com:5000” in docker config. 本人 Mac使用的是 Docker添加 insecure registry 然后重启docker服务 3. getsockopt: connection refused1Error while pulling image: Get http://localhost:5000/v1/repositories/apiserver/images: dial tcp [::1]:5000: getsockopt: connection refused 参见: https://github.com/mkuchin/docker-registry-web/issues/48替换realm.token.auth 的ip或是域名, 上面已经操作过了. 4. 自行修改防火墙端口访问(5000, 8080)5. mac docker 添加国内源apply and restart]]></content>
      <categories>
        <category>Linux</category>
        <category>Centos 7</category>
      </categories>
      <tags>
        <tag>Centos 7</tag>
        <tag>Docker</tag>
        <tag>private registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 修改仓库镜像等默认路径]]></title>
    <url>%2F2017%2F12%2F04%2FDocker%20%E4%BF%AE%E6%94%B9%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E7%AD%89%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[默认情况下Docker的存放位置为:/var/lib/docker 修改镜像和容器的存放路径：很简单，指定镜像和容器存放路径的参数是–graph=/var/lib/docker。以下以’/docker’路径为例: 1.Docker的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致，在 Ubuntu 中的位置是：/etc/default/docker，在 CentOS中的位置是：/etc/sysconfig/docker。 如果是 CentOS6 则添加下面这行：1OPTIONS=--graph="/data/tools/docker"--selinux-enabled -H fd:// 如果是 Ubuntu 则添加下面这行（因为 Ubuntu 默认没开启 selinux）：123OPTIONS=--graph="/data/tools/docker" -H fd://#或者DOCKER_OPTS="-g /data/tools/docker" 最后重新启动，Docker 的路径就改成 /data/tools/docker 了。如果是CentOS7 就是用如下：修改docker.service文件，使用–graph参数指定存储位置123sudo vim /usr/lib/systemd/system/docker.service 文本内容：ExecStart=/usr/bin/dockerd下面添加如下内容： --graph /data/tools/docker 重启 Docker 服务Centos12$ sudo systemctl daemon-reload$ sudo systemctl restart docker.service ubuntu1$ sudo service docker restart]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 10.12 打开任何来源]]></title>
    <url>%2F2017%2F10%2F20%2FMac%2010.12%20%E6%89%93%E5%BC%80%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90%2F</url>
    <content type="text"><![CDATA[1sudo spctl --master-disable 关闭Mac GateKeeper]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>任何来源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7软件环境安装(Python3 nodejs nginx gitlab)]]></title>
    <url>%2F2017%2F10%2F13%2FCentos7%20%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85-python3-nodejs-nginx-gitlab%2F</url>
    <content type="text"><![CDATA[Node123456# nvm 安装 $ wget https://github.com/cnpm/nvm/archive/v0.23.0.tar.gz $ tar -xf v0.23.0.tar.gz $ cd v0.23.0 $ ./install.sh $ source ./bash_profile 或者 ./bashrc 按实际情况 1234# node 安装 $ nvm list-remote $ nvm install Vx.xx.x $ nvm alias default &lt;version&gt; // 设置默认node版本 否则找不到node命令 Python 3.x1234567891011121314151617181920212223# python 3.6 $ sudo mkdir /usr/local/python3 $ wget --no-check-certificate https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz # 注意：wget获取https的时候要加上：--no-check-certificate $ tar -xzvf Python-3.6.0.tgz $ cd Python-3.6.0 # 编译安装 $ sudo ./configure --prefix=/usr/local/python3 # 指定创建的目录 $ sudo make $ sudo make install # 创建 python3 软链 $ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3 # pip3 $ wget --no-check-certificate https://github.com/pypa/pip/arrchive/9.0.1.tar.gz $ tar -zvxf 9.0.1.tar.gz $ cd pip-9.0.1 $ python3 setup.py install # 创建 pip3 软链 $ sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3 nginx123$ yum -y update $ yum -y install nginx# 默认安装到 /etc/nginx 路径 Gitlab# 安装依赖 $ yum install curl policycoreutils openssh-server openssh-clients $ systemctl enable sshd &amp;&amp; systemctl start sshd $ yum install postfix $ systemctl enable postfix $ systemctl start postfix # start 出现错误: Job for postfix.service failed. See &apos;systemctl status postfix.service&apos; and &apos;journalctl -xn&apos; for details. $ systemctl status postfix.service # 查看错误详情 $ sudo vim /etc/postfix/main.cf inet_protocols = all =&gt; inet_protocols = ipv4 $ systemctl start postfix # 设置防火墙 $ firewall-cmd --permanent --add-service=http # 报错 FirewallD is not running $ sudo vim /etc/sysctl.conf 在文件最后一行添加新行 net.ipv4.ip_forward=1 $ sysctl -p $ systemctl start firewalld.service $ systemctl status firewalld -l # firewall 常用命令 # 添加新端口, 重启后生效 $ firewall-cmd --permanent --add-port=xxxx/tcp $ service firewalld restart 重启 $ service firewalld start 开启 $ service firewalld stop 关闭 $ systemctl status firewall 查看firewall服务状态 $ firewall-cmd --state 查看firewall的状态 # 查看防火墙规则 $ firewall-cmd --list-all # 安装Gitlab # 新建 /etc/yum.repos.d/gitlab-ce.repo [gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/ gpgcheck=0 enabled=1 $ sudo yum makecache $ sudo yum install gitlab-ce # 修改 /etc/gitlab/gitlab.rb $ sudo gitlab-ctl reconfigure $ sudo gitlab-ctl reload]]></content>
      <categories>
        <category>Linux</category>
        <category>Centos 7</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
        <tag>Nginx</tag>
        <tag>Centos 7</tag>
        <tag>Python3</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac sketch 缓存清理]]></title>
    <url>%2F2017%2F10%2F13%2FMac-sketch-clean%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; sketch自动保存机制导致的一些缓存文件,清理方法: 1.cd / 2.ls -la 3.sudo du -sh .DocumentRevisions-V100 4.password 5.delete files: sudo rm -rf .DocumentRevisions-V100]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>sketch 缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum]]></title>
    <url>%2F2017%2F10%2F13%2Fyum%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627Linux系统下yum命令查看安装了哪些软件包： $yum list installed //列出所有已安装的软件包 yum针对软件包操作常用命令： 1.使用YUM查找软件包 命令：yum search 2.列出所有可安装的软件包 命令：yum list 3.列出所有可更新的软件包 命令：yum list updates 4.列出所有已安装的软件包 命令：yum list installed 5.列出所有已安装但不在 Yum Repository 内的软件包 命令：yum list extras 6.列出所指定的软件包 命令：yum list 7.使用YUM获取软件包信息 命令：yum info 8.列出所有软件包的信息 命令：yum info 9.列出所有可更新的软件包信息 命令：yum info updates 10.列出所有已安装的软件包信息 命令：yum info installed 11.列出所有已安装但不在 Yum Repository 内的软件包信息 命令：yum info extras 12.列出软件包提供哪些文件 命令：yum provides]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS tuxera 移除卸载后烦人的提示框]]></title>
    <url>%2F2017%2F09%2F15%2FMac-OS-tuxera%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[https://discussions.apple.com/thread/7396598?start=0&amp;tstart=0 在/Library/FileSystems or /System/Library/Filesystems 目录下,找到fusefs_txantfs.fs 删除即可 或者 Terminal 执行 1sudo rm -rf "/System/Library/Filesystems/fusefs_txantfs.fs or 1sudo rm -rf "/Library/Filesystems/fusefs_txantfs.fs 这只是移除正常卸载Tuxera之后烦人的提示框]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Tuxera</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 浮点数计算和比较]]></title>
    <url>%2F2017%2F07%2F06%2FJavaScript%20%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[先看几个例子 (基于node 8.4环境的测试) 1234567891011121314151617181920212223242526272829303132333435363738&gt; console.log(0.2 === 0.2)true&gt; console.log(0.2 == 0.2)true&gt; console.log(0.2 == 0.1 + 0.1)true&gt; console.log(0.2 === 0.1 + 0.1)true&gt; console.log(0.20 === 0.1 + 0.1)true&gt; console.log(0.30 === 0.1 + 0.2)false&gt; console.log(0.3 === 0.1 + 0.2)false&gt; console.log(0.2 === 0.1 + 0.1)true&gt; console.log(0.1 + 0.1)0.2&gt; console.log(0.1 + 0.2)0.30000000000000004&gt; console.log(0.2 + 0.2)0.4&gt; console.log(0.2 + 0.3)0.5&gt; console.log(0.2 + 0.4)0.6000000000000001 这些例子显示js中浮点数计算并不是精确值, 因此并不能简单的判断浮点数是不是相等.原因在于 十进制到二进制的转换导致的精度问题！ 同样的问题出现在C/C++,Java,Javascript中，准确的说：“使用了IEEE 754浮点数格式”来存储浮点类型(float 32,double 64)的任何编程语言都有这个问题！ 原理:IEEE 754浮点格式：它用科学记数法以底数为2的小数来表示浮点数。IEEE浮点数（共32位）用1位表示数字符号，用8位表示指数，用23位来表示尾数（即小数部分）。此处指数用移码存储，尾数则是原码（没有符号位）。之所以用移码是因为移码的负数的符号位为0，这可以保证浮点数0的所有位都是0。双精度浮点数(64位)，使用1位符号位、11位指数位、52位尾数位来表示。 因为科学记数法有很多种方式来表示给定的数字，所以要规范化浮点数，以便用底数为2并且小数点左边为1的小数来表示（注意是二进制的，所以只要不为0则一定有一位为1），按照需要调节指数就可以得到所需的数字。例如：十进制的1.25 => 二进制的1.01 => 则存储时指数为0、尾数为1.01、符号位为0.（十进制转二进制） 实例为什么“0.1+0.2=0.30000000000000004”？首先声明这是javascript语言计算的结果（注意Javascript的数字类型是以64位的IEEE 754格式存储的）。正如同十进制无法精确表示1/3(0.33333…)一样，二进制也有无法精确表示的值。例如1/10。64位浮点数情况下： 123456789101112131415161718192021222324十进制0.1=&gt; 二进制0.00011001100110011...(循环0011)=&gt;尾数为1.1001100110011001100...1100（共52位，除了小数点左边的1），指数为-4（二进制移码为00000000010）,符号位为0=&gt; 存储为：0 00000000100 10011001100110011...11001=&gt; 因为尾数最多52位，所以实际存储的值为0.00011001100110011001100110011001100110011001100110011001十进制0.2=&gt; 二进制0.0011001100110011...(循环0011)=&gt;尾数为1.1001100110011001100...1100（共52位，除了小数点左边的1），指数为-3（二进制移码为00000000011）,符号位为0=&gt; 存储为：0 00000000011 10011001100110011...11001因为尾数最多52位，所以实际存储的值为0.0011001100110011001100110011001100110011001100110011001两者相加：0.00011001100110011001100110011001100110011001100110011001 +0.0011001100110011001100110011001100110011001100110011001 =0.01001100110011001100110011001100110011001100110011001111转换成10进制之后得到：0.30000000000000004！而 0.1 + 0.1 = 0.00011001100110011001100110011001100110011001100110011001 + 0.00011001100110011001100110011001100110011001100110011001 =0.001100110011001100110011001100110011001100110011001100100.0011001100110011001100110011001100110011001100110011001 === 0.2 基于上基本了解了浮点数计算问题的由来, 当然关于IEEE 754标准可以wiki, 还有标准的四种舍入方式: 舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中式以0结尾的）。 朝+∞方向舍入：会将结果朝正无限大的方向舍入。 朝-∞方向舍入：会将结果朝负无限大的方向舍入。 朝0方向舍入：会将结果朝0的方向舍入。 如何处理关于建议推荐这篇 http://yanhaijing.com/javascript/2014/03/14/what-every-javascript-developer-should-know-about-floating-points/以下为引用: 设计处理JavaScript数字的问题，已经存在很多的建议，好坏参半。大多数这些建议都是在算数运算之前或之后完成取舍。 到目前位置我见过的寥寥无几的建议就是把运算数全部存储为整数（无类型），然后格式化显示。通过一个例子可以看出，在账户中大量储存的美分而不是美元（不知道举的例子是什么账户）。这里有一个值得注意的问题——不是世界上所有的货币都是十进制的（毛里求斯币：毛里求斯卢比是毛里求斯共和国的流通货币。币值有25、50、100、200、500、1000和2000。辅币单位为分）。同时，吐槽了日元和人名币……。最终，你会重新创建浮点——有可能。 我见过处理浮点数最好的建议是使用库，像sinfuljs或mathjs。我个人比较喜欢mathjs（但实际上，任何和数学相关的我甚至不会使用JavaScript去做）。当需要任意精度数学计算的时候，BigDecimal也是非常有用的。 另一个被多次重复的建议是使用内置的toPrecision()和toFixed()方法。使用他们时最容易犯得逻辑错误是忘记这些方法的返回值字符串。所以如果你像下面这样会得不到想要的结果： 123456function foo(x, y) &#123; return x.toPrecision() + y.toPrecision()&#125;&gt; foo(0.1, 0.2)"0.10.2" 设计内置方法toPrecision()和toFixed()的目的仅是用于显示。谨慎使用！ 参考: 基础野：细说原码、反码和补码（http://www.cnblogs.com/fsjohnhuang/p/5060242.html） 基础野：细说无符号整数（http://www.cnblogs.com/fsjohnhuang/p/5078290.html） 基础野：细说有符号整数（http://www.cnblogs.com/fsjohnhuang/p/5082829.html） 基础野：细说浮点数（http://www.cnblogs.com/fsjohnhuang/p/5109766.html）]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 定时器]]></title>
    <url>%2F2017%2F07%2F05%2FJavaScript%20-%20%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[setTimeout() 和 setInterval() 可以用来实现延时 定时等功能, 但是 JavaScript 是单线程工作, 不能同时执行多个操作 , 只能按照队列先后顺序执行, 定时器仅仅是计划代码在未来执行什么时间执行, 但是这个时间是不能保证的(不能保证定时器延迟), 是不精确的. timer 工作原理(https://johnresig.com/blog/how-javascript-timers-work/) 首先，在JavaScript的第一个块中，启动两个定时器：10ms setTimeout和10ms setInterval。由于定时器启动的位置和时间，它实际上在我们实际完成第一个代码块之前触发。但请注意，它不会立即执行（由于线程，它无法执行此操作）。相反，延迟功能排队，以便在下一个可用时刻执行。 此外，在第一个JavaScript块中，我们看到鼠标单击。与此异步事件关联的JavaScript回调（我们永远不知道用户何时可以执行操作，因此它被认为是异步的）无法立即执行，因此，与初始计时器一样，它排队等待稍后执行。 在JavaScript的初始块完成后，执行浏览器会立即询问：什么等待执行？在这种情况下，鼠标单击处理程序和计时器回调都在等待。然后浏览器选择一个（鼠标单击回调）并立即执行它。计时器将等到下一个可能的时间，以便执行。 请注意，当鼠标单击处理程序执行时，执行第一个间隔回调。与计时器一样，它的处理程序排队等待以后执行。但是，请注意，当再次触发间隔时（执行计时器处理程序时），此时将删除处理程序执行。如果要在执行大块代码时排队所有间隔回调，结果将是一堆间隔执行时，它们之间没有延迟，完成后。相反，浏览器倾向于等待，直到排队更多时，不再有间隔处理程序排队（对于所讨论的间隔）。 事实上，我们可以看到，当间隔本身正在执行时，第三个间隔回调会触发。这向我们展示了一个重要的事实：Intervals不关心当前正在执行的内容，它们将不加选择地排队，即使这意味着将牺牲回调之间的时间。 最后，在第二个间隔回调完成执行后，我们可以看到JavaScript引擎没有任何内容可以执行。这意味着浏览器现在等待发生新的异步事件。当间隔再次发射时，我们得到50ms的标记。然而，这次没有任何东西阻止它的执行，所以它会立即触发。 setTimeout() 和 setInterval()123var id = setTimeout(fn, delay); // 启动单个定时器，在延迟后调用指定的功能。该函数返回一个唯一的ID，可以在以后取消定时器。var id = setInterval(fn, delay); // 类似setTimeout但不断地调用函数（每次都有延迟），直到它被取消。clearInterval(id);，clearTimeout(id); // 接受计时器ID（由上述任一功能返回）并停止发生计时器回调。 12345678setTimeout(function()&#123; /* Some long block of code... */ setTimeout(arguments.callee, 10); // setTimeout 链式调用&#125;, 10); setInterval(function()&#123; /* Some long block of code... */&#125;, 10); 这两段代码乍一看似乎在功能上等同，但它们不是。值得注意的是，setTimeout代码在前一次回调执行后总是至少有10ms的延迟（它可能最终会更多，但永远不会更少, setTimeout 链式调用是为了防止定时器 setInterval() 因为延迟而可能出现的两个缺点: 1) 某些间隔会被跳过 2) 多个定时器的代码执行之间的间隔可能会比预期小 )，而setInterval无论最后一次回调何时被执行，它都会尝试每10ms执行一次回调。 如何得到相对精确的倒计时(秒杀活动, 不同的人得到的时间不一致问题) 不使用客户端的时间, 使用服务器的时间, 但是使用服务器时间也有传输时间消耗和渲染时间消耗, 所以不能做到绝对精确, 但是可以通过优化来达到相对的精确, 控制误差. 当前服务器时间 = 服务器系统返回时间 + 网络传输时间 + 前端渲染时间 通过计算获得服务器时间后到前端渲染完成的时间差, 来动态调整定时器的间隔来缩小误差. 123456789101112131415161718192021222324252627282930//线程占用setInterval(function()&#123; var j = 0; while(j++ &lt; 100000000); &#125;, 0); //倒计时var interval = 1000, ms = 50000, //从服务器和活动开始时间计算出的时间差，这里测试用50000ms count = 0, startTime = new Date().getTime();if( ms &gt;= 0)&#123; var timeCounter = setTimeout(countDownStart,interval); &#125; function countDownStart()&#123; count++; var offset = new Date().getTime() - (startTime + count * interval); var nextTime = interval - offset; var daytohour = 0; if (nextTime &lt; 0) &#123; nextTime = 0 &#125;; ms -= interval; console.log("误差：" + offset + "ms，下一次执行：" + nextTime + "ms后，离活动开始还有：" + ms + "ms"); if(ms &lt; 0)&#123; clearTimeout(timeCounter); &#125;else&#123; timeCounter = setTimeout(countDownStart,nextTime); &#125;&#125;思路来源: http://imgcache.gtimg.cn/club/common/lib/zero/widgets/date/Date.1.1.1.js]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 类型比较及判空]]></title>
    <url>%2F2017%2F07%2F05%2FJavaScript%20-%20%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E5%8F%8A%E5%88%A4%E7%A9%BA%2F</url>
    <content type="text"><![CDATA[typeof适合用来检测一个对象是否已经定义或者是否已经赋值 typeof对于基本数据类型可以正确判断其类型, 对于引用数据类型, 只会返回’object’, 而不是其正确类型, null 会返回’object’, 因为null本质是指向空对象的指针, undefined 会返回’undefined’ instanceofinstanceof 操作符应该仅仅用来比较来自同一个 JavaScript 上下文的自定义对象instanceof 左操作数是一个类，右操作数是标识对象的类.如果左侧的对象是右侧类的实例，则返回true.而js中对象的类是通过初始化它们的构造函数来定义的。即instanceof的右操作数应当是一个函数。所有的对象都是object的实例。如果左操作数不是对象，则返回false,如果右操作数不是函数，则抛出typeError。注: instanceof 用来比较属于不同 JavaScript上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。 ==相等运算符相等运算符在比较相同类型的值时, 结果和严格运算符结果完全一致在比较不同类型的值时, 会先转换为同一类型, 在进行比较转换规则: 原始类型值原始类型的值会转换成数值类型在进行比较. 字符串和布尔值都会转换成数值 对象和原始值比较对象转换成原始类型的值在进行比较 null 与 undefined 与其他值比较时都返回false 他们之间进行比较时会返回true 相等运算符隐藏的类型转换, 会带来一些违反直觉的结果 ===严格运算符 如果类型不一样 直接返回false 同一类型的原始类型值(字符, 数值, 布尔值), 值相等则返回true, 值不相等则返回false 同一类型的复合类型值(数组, 对象, 函数), 不是比较他们的值是否相等, 而是比较他们是否指向同一个对象 null 和 undefined 严格相等 12null === null trueundefined === undefined true 终极类型比较 (Object.prototype.toString.call(obj).slice(8, -1)) 12345678910111213141516&gt; Object.prototype.toString.call('s').slice(8, -1)'String'&gt; Object.prototype.toString.call([]).slice(8, -1)'Array'&gt; Object.prototype.toString.call(function()&#123;&#125;).slice(8, -1)'Function'&gt; Object.prototype.toString.call(false).slice(8, -1)'Boolean'&gt; Object.prototype.toString.call(&#123;&#125;).slice(8, -1)'Object'&gt; Object.prototype.toString.call(null).slice(8, -1)'Null'&gt; Object.prototype.toString.call(undefined).slice(8, -1)'Undefined'&gt; Object.prototype.toString.call(3.4).slice(8, -1)'Number' 123function getType(obj) &#123; return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();&#125; 判断对象不存在 !obj 除了对象是否存在，还要判断对象是否有null值 typeof myObj == “undefined” 只判断对象是否存在 在Javascript语言中，null和undefined容易产生混淆。在可能同时涉及两者的情况下，建议使用”精确比较”运算符（===）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>类型比较</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 数据类型及隐式转换]]></title>
    <url>%2F2017%2F07%2F05%2FJavaScript%20-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[数据类型 基础数据类型: undefined, null, Number, String, Boolean, Symbol (ES6+) 引用数据类型: Object(Object, Array, Date, RegExp, Function) 基础数据类型 值直接存储在相应 栈内存 上的, 使用时是按值访问; 引用数据类型 地址存储在 占内存上, 内容存储在 堆内存上, 使用时是按 引用访问; 注: Number, Boolean, String 三种类型 也可以通过 new 关键字创建对应的 基本包装类型, 包装类型的实例 隐式转换 涉及到隐式转换的运算符最多的是 + 和 ==, -*/等运算符只会针对 number 类型, 结果也只转换为 number 类型; 将值转换为原始值 ToPrimitive() 将值转换为数字 ToNumber(); 将值转化为字符串 ToString(); ToPrimitive(input, PreferredType?) input是要转换的值，PreferredType是可选参数，可以是Number或String类型, 只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值(或者报错), 也就是说设置 Number 时也可能转换为 string, 设置为 String 时 也可能转化为 Number; 当 PreferredType 未设置时, 按照下面规则设置: 121. input 是 Date 类型时, PreferredType = String;2. 否则, PreferredType = Number; PreferredType = Number: 1234567 1. input 是原始值, 返回原始值; 2. input 不是原始值, 调用 input.valueOf(); 如果返回值是原始值则返回原始值结果; 3. 如果 2 的结果不是原始值, 调用 input.toString(), 如果返回值是原始值则返回原始值结果; 4. 如果 3 的结果不是原始值, 抛出 TypeError 异常``` PreferredType = String: 类似于 Number 1. input 是原始值, 返回原始值; 2. input 不是原始值, 调用 input.toString(); 如果返回值是原始值则返回原始值结果; 3. 如果 2 的结果不是原始值, 调用 input.valueOf(), 如果返回值是原始值则返回原始值结果; 4. 如果 3 的结果不是原始值, 抛出 TypeError 异常 12 #### ToNumber undefined NaN null +0 boolean true: 1/ false: +0 number number string &apos;123&apos;: 123 / &apos;qwer&apos;: NaN object ToPrimitive(input, Number).ToNumber() 12 #### ToString undefined &quot;undefined&quot; null &quot;null&quot; boolean true: &quot;true&quot;/ false: &quot;false&quot; number &quot;number&quot; string string object ToPrimitive(input, String).ToString() 12345 ##### valueOf方法和toString方法详解 首先 valueOf() 和 toString() 是 Object.prototype 的方法, 也就是所有的对象都有这两个方法; - valueOf() _**总的原则是能转化为原始值则转化为原始值, 不能转化为原始值的返回 this, 也就是对象本身, Date 对象转化为 毫秒级数值**_ Number(&apos;123&apos;).valueOf() // 123 String(&apos;123fs&apos;).valueOf() // &apos;123fs&apos; Boolean(true).valueOf() // true new Date().valueOf() // 1530706938289 var arr = [&apos;1&apos;, &apos;2&apos;]; arr.valueOf() // [ &apos;1&apos;, &apos;2&apos; ] === arr =&gt; true 等于 自身 var obj = {}; obj.valueOf() // {} === obj =&gt; true 等于自身 12 - toString() _**将对象转化成字符串形式, 重写了 toString() 的调用自己的 toString() 方法, 其余的调用 Object.prototype.toString() **_ Number.prototype.hasOwnProperty(&apos;toString&apos;); // true Boolean.prototype.hasOwnProperty(&apos;toString&apos;); // true String.prototype.hasOwnProperty(&apos;toString&apos;); // true Array.prototype.hasOwnProperty(&apos;toString&apos;); // true Date.prototype.hasOwnProperty(&apos;toString&apos;); // true RegExp.prototype.hasOwnProperty(&apos;toString&apos;); // true Function.prototype.hasOwnProperty(&apos;toString&apos;); // var num = new Number(&apos;123sd&apos;); num.toString(); // &apos;NaN&apos; var str = new String(&apos;12df&apos;); str.toString(); // &apos;12df&apos; var bool = new Boolean(&apos;fd&apos;); bool.toString(); // &apos;true&apos; var arr = new Array(1,2); arr.toString(); // &apos;1,2&apos; var d = new Date(); d.toString(); // &quot;Wed Jul 04 2018 20:22:09 GMT+0800 (CST)&quot; var func = function () {} func.toString(); // &quot;function () {}&quot; var obj = new Object({}); obj.toString(); // &quot;[object Object]&quot; Math.toString(); // &quot;[object Math]&quot; 123 ### 隐式转换的例子 &apos;&apos; == 0 // true &apos;0&apos; == 0 // true &apos;0&apos; == &apos;&apos; // false类型相同 不进行隐式转换 [] == !{} // []==false =&gt; &apos;&apos;==0 =&gt; 0==0 =&gt; true ({} + {}) = ? // &quot;[object Object]&quot; + &quot;[object Object]&quot; = &quot;[object Object][object Object]&quot; 2 * {} = ? // 2 * NaN = NaN 2 * [] = ? // 2 * &apos;&apos;.toString() = 2 * 0 = 0 1 const a = { i: 1, toString: function () { return a.i++; } } if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) { console.log(&apos;hello world!&apos;); } ``` 1、当执行a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 时，会从左到右一步一步解析，首先 a == 1，会进行上面第9步转换。ToPrimitive(a， Number) == 1。 2、ToPrimitive(a, Number)，按照上面原始类型转换规则，会先调用valueOf方法，a的valueOf方法继承自Object.prototype。返回a本身，而非原始类型，故会调用toString方法。 3、因为toString被重写，所以会调用重写的toString方法，故返回1，注意这里是i++，而不是++i，它会先返回i，在将i+1。故ToPrimitive(a, Number) = 1。也就是1 == 1，此时i = 1 + 1 = 2。 4、执行完a == 1返回true，会执行a == 2，同理，会调用ToPrimitive(a, Number)，同上先调用valueOf方法，在调用toString方法，由于第一步，i = 2此时，ToPrimitive(a, Number) = 2， 也就是2 == 2, 此时i = 2 + 1。 5、同上可以推导 a == 3也返回true。故最终结果 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3返回true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - 原型链和继承]]></title>
    <url>%2F2017%2F07%2F04%2FJavaScript%20-%20%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型对象和原型链JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象 (prptotype)，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法. 这种继承模型提供了一个强大而可扩展的功能系统。 准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。 几种创建对象的方式及其原型链: 语法结构创建 12345678910111213141516171819202122232425var o = &#123;a: 1&#125;;// o 这个对象继承了Object.prototype上面的所有属性// o 自身没有名为 hasOwnProperty 的属性// hasOwnProperty 是 Object.prototype 的属性// 因此 o 继承了 Object.prototype 的 hasOwnProperty// Object.prototype 的原型为 null// 原型链如下:// o ---&gt; Object.prototype ---&gt; nullvar a = ["yo", "whadup", "?"];// 数组都继承于 Array.prototype // (Array.prototype 中包含 indexOf, forEach等方法)// 原型链如下:// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; nullfunction f()&#123; return 2;&#125;// 函数都继承于Function.prototype// (Function.prototype 中包含 call, bind等方法)// 原型链如下:// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null 构建器创建 1234567891011121314function Graph() &#123; this.vertices = []; this.edges = [];&#125;Graph.prototype = &#123; addVertex: function(v)&#123; this.vertices.push(v); &#125;&#125;;var g = new Graph();// g是生成的对象,他的自身属性有'vertices'和'edges'.// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype. Object.create() 创建 ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数： 12345678910111213var a = &#123;a: 1&#125;; // a ---&gt; Object.prototype ---&gt; nullvar b = Object.create(a);// b ---&gt; a ---&gt; Object.prototype ---&gt; nullconsole.log(b.a); // 1 (继承而来)var c = Object.create(b);// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; nullvar d = Object.create(null);// d ---&gt; nullconsole.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype __proto__, prptotype, constructor, new 和实例 对象之间的关系:例子:1234567891011121314151617function A(name, age) &#123; this.age = age; this.name = name;&#125;A.fullname = function (obj) &#123; return `fullname: $&#123;obj.name&#125; $&#123;obj.age&#125;`;&#125;A.prototype.info = function () &#123; return `name: $&#123;this.name&#125; age: $&#123;this.age&#125;`;&#125;var aaa = new A('aa', '23');console.log(aaa);console.log(aaa.info())console.log(A.fullname(aaa)) aaa.__proto__ === A.prptotype === Object.getPrototypeOf(aaa) 注: 只有 prototype 对象里面的属性和方法会被继承, 像A.fullname 并不会被继承, 像 Object.is(), Object.keys() 方法等. 通过 prototype 对象可以给原有的对象动态添加 属性和方法, 以达到扩展的目的, 但是 Object.prototype 尽量不做修改. 扩展内置原型的唯一理由是支持JavaScript 引擎的新特性，如Array.forEach; 但是 prototype 定义属性当属性不是很灵活, 当直接使用 this 的时候还会出现问题, 一般在构造函数里面定义属性, 在 prototype 中定义方法. 因为原型链的机制, 查找属性和方法时会一直遍历对象的原型对象及原型对象的原型对象, 直到找到对应的方法属性为止, 或者 到 null 抛出异常, 而在原型链上查找属性是很耗时的操作, 原型链太长会导致性能下降. 继承ES6 之前的写法: B 继承自 A: 123456789101112131415161718192021222324252627282930function B(name, age, gender) &#123; A.call(this, name, age); this.gender = gender;&#125;// B.prototype = Object.create(A.prototype, &#123;// info: &#123;// value: function () &#123;return `name: $&#123;this.name&#125; age: $&#123;this.age&#125; ... `&#125;,// enumerable: true, // configurable: true, // writable: true // &#125;, // 重写// infoB: &#123; // value: function () &#123;// return `name: $&#123;this.name&#125; age: $&#123;this.age&#125; gender: $&#123;this.gender&#125;`;// &#125;,// enumerable: true, // configurable: true, // writable: true // &#125;// &#125;)B.prototype = Object.create(A.prototype)B.prototype.infoB = function ()&#123; return `name: $&#123;this.name&#125; age: $&#123;this.age&#125; gender: $&#123;this.gender&#125;`;&#125;B.prototype.info = function ()&#123; // 重写 const p = A.prototype.info.apply(this); return p + ' gender: ahu ' + this.gender;&#125;B.prototype.constructor = B; 注: B 并没有 fullname 方法, 通过重新设置 B.prototype.info() 以达到重写 A,prototype,info() 的目的; ES6 之后的写法: 1234567891011121314151617181920212223242526class A &#123; constructor (name, age) &#123; this.name = name; this.age = age; this.info = function () &#123; return `name: $&#123;this.name&#125; age: $&#123;this.age&#125;`; &#125; &#125; static fullname(obj) &#123; return `fullname: $&#123;obj.name&#125; $&#123;obj.age&#125;`; &#125;&#125;class B extends A &#123; constructor(name, age, gender) &#123; super(name, age); this.gender = gender; this.info = function () &#123; return `name: $&#123;this.name&#125; age: $&#123;this.age&#125; ...`; &#125; this.infoB = function () &#123; return `name: $&#123;this.name&#125; age: $&#123;this.age&#125; gender: $&#123;this.gender&#125;`; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型链和继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - this 原理]]></title>
    <url>%2F2017%2F07%2F03%2F%10JavaScript%20-%20this%20%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于 this: 普通函数中的this: 1.this 总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj 2.在默认情况(非严格模式下,未使用 ‘use strict’),没找到直接调用者,则this指的是 window (约定俗成) 3.在严格模式下,没有直接调用者的函数中的this是 undefined 4.使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象 箭头函数中的this: 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this 有点绕, 看不懂继续往下看 例子:12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2 现象解释: this 指的是函数运行时所在的环境(上下文 context)。对于 obj.foo() 来说，foo 运行在 obj 环境，所以 this 指向 obj；对于 foo() 来说，foo 运行在全局环境，所以 this 指向全局环境。 原理: this 设计与 JavaScript 内存的数据结构有关系, 回忆 JavaScript 数据类型的知识以及各数据类型存储的方式, 上面的例子的变种: 123var f = function () &#123; console.log(x);&#125;; 引用型对象将对象内容存储在 堆内存中, 地址存储在变量的栈内存中. 也就是说 obj 存储在栈内存上, 内容为一个堆内存的地址, 而堆内存存储的才是对象的真正内容. 同理 JavaScript 中函数也是一个对象, foo 也是一个堆内存地址, 函数内容存储另外的内存上. 而在 JavaScript 中, 函数内可以引用当前运行环境的变量, 函数又可以在不同的环境中运行, 那么当函数在不同环境中运行时, 如何引用当前运行环境中的变量呢, this 就是起这样的作用的, 在函数体中指代当前的运行环境, 以引用 context 中的变量. 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 123456789101112131415// 箭头函数var x = 2;function F() &#123; this.x = 3; this.foo = () =&gt; &#123; var x = 1; console.log(x, this.x) &#125;&#125;const f = new F();const foo = f.foo;foo(); // 1, 3f.foo(); // 1, 3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - CSS3]]></title>
    <url>%2F2017%2F07%2F02%2FJavaScript%20-%20CSS3%2F</url>
    <content type="text"><![CDATA[CSS3 语法 123@media mediatype and | not | only (media feature) &#123; css-code; &#125;//也可以针对不同的媒体使用不同的stylesheets: &lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt; 标签 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放 CSS2 对 media 的支持 CSS2 已经支持 Media 的用法, 但是只能在 head 标签中插入对应的 stylesheet link. 123&lt;link rel="stylesheet" href="styleA.css" media="screen"&gt; &lt;link rel="stylesheet" href="styleB.css" media="screen and (max-width: 800px)"&gt; &lt;link rel="stylesheet" href="styleC.css" media="screen and (max-width: 600px)"&gt; CSS3 @media 媒体类型1.all 所有媒体2.braille 盲文触觉设备3.embossed 盲文打印机4.print 手持设备5.projection 打印预览6.screen 彩屏设备7.speech ‘听觉’类似的媒体类型8.tty 不适用像素的设备9.tv 电视 参数汇总width:浏览器可视宽度。height:浏览器可视高度。device-width:设备屏幕的宽度。device-height:设备屏幕的高度。orientation:检测设备目前处于横向还是纵向状态。aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9)device-aspect-ratio:检测设备的宽度和高度的比例。color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色）color-index:检查设备颜色索引表中的颜色，他的值不能是负数。monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到）resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。grid:检测输出的设备是网格的还是位图设备。 常用宽度设定 123456789101112131415@media screen and (min-width: 1200px) &#123; css-code;&#125;@media screen and(min-width: 960px) and (max-width: 1199px) &#123; css-code;&#125;@media screen and(min-width: 768px) and (max-width: 959px) &#123; css-code;&#125;@media screen and(min-width: 480px) and (max-width: 767px) &#123; css-code;&#125;@media screen and (max-width: 479px) &#123; css-code;&#125; CSS3 相对 CSS2 写法的优势, 是 CSS 样式在同一个文件中, 减少了http请求资源的次数 CSS3 不是生效时, 依次检查 CSS样式本身不正确 未在 head 标签中设置 属性 viewport 属性. 格式错误, and 后面必须有空格@media screen and {max-width: 200px){} 样式冲突, CSS 按顺序执行, 后面的样式会覆盖前面的样式 括号中的 CSS code 不能包括 ‘;’]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript - the Ways to Bind JavaScript’s this Keyword in React, ES6 & ES7]]></title>
    <url>%2F2017%2F07%2F02%2FJavaScript%20-%20the%20Ways%20to%20Bind%20JavaScript%E2%80%99s%20this%20Keyword%20in%20React%2C%20ES6%20%26%20ES7%2F</url>
    <content type="text"><![CDATA[The ProblemReact 将 this 关键字绑定到组件的上下文12345this.setState(&#123; loading: true &#125;);fetch('/').then(function loaded() &#123; this.setState(&#123; loading: false &#125;);&#125;); 这种情况下会出现 TypeError: this.setStatate is not a function因为 Promise 内部回调函数的 this 对象不是 react 的组件, 而是 Promise 对象; The Options Alias This 123456var component = this;component.setState( &#123;loading: true&#125; );fetch('/').then(function loaded() &#123; component.setState( &#123;loading: true&#125; );&#125;); 轻量简单的解决办法 Bind This 12345this.setState(&#123; loading: true &#125;);fetch('/').then(function loaded() &#123; this.setState(&#123; loading: false &#125;);&#125;.bind(this)); 这种解决方式会在运行时向回调函数注入正确的 context;所有的JavaScript function 都有一个 bind 方法, 允许用户指定 this 对象的值,但是这种方式在使用多层嵌套和异步的代码时, 会很混乱, 不易读. React Component Methods 12345678componentWillMount: function() &#123; this.setState(&#123; loading: true &#125;); fetch('/').then(this.loaded);&#125;,loaded: function loaded() &#123; this.setState(&#123; loading: false &#125;);&#125; 一种优雅的解决方式 The best Option ES2015 Arrows 12345this.setState(&#123; loading: true &#125;);fetch('/').then(() =&gt; &#123; this.setState(&#123; loading: false &#125;);&#125;); 我觉得是最简单的解决方法, ES5 的箭头函数, 不管嵌套多少层 this 都是正确的 context. 关于 this: 普通函数中的this: 1. this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj 2.在默认情况(非严格模式下,未使用 &apos;use strict&apos;),没找到直接调用者,则this指的是 window (约定俗成) 3.在严格模式下,没有直接调用者的函数中的this是 undefined 4.使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象 箭头函数中的this 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS - Cocoa Touch 框架结构]]></title>
    <url>%2F2016%2F10%2F26%2FiOS-Cocoa-touch-layer%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; Cocoa是在Mac OS X系统上原生的一个编译环境。他包含两个框架，其实就是一系列的类库，Foundation和AppKit。 &emsp;&emsp;在你的iPhone等掌上设备上，使用的则是他的一个子类 - Cocoa Touch 。他所支持的Foundation框架与Cocoa相同，但他的用户图形类库为UIKit，它是为掌上设备特殊设计，提供了你设备上的界面。&emsp;&emsp; Cocoa Touch与Cocoa一个比较鲜明的区别就是Cocoa Touch并不支持垃圾回收机制，这就意味着你必须在你的代码里管理好你的内存。而Cocoa与Cocoa Touch共同点就是二者都包含Objective-C运行时和两个核心框架： Cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序。 Cocoa Touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序。 Cocoa是 Mac OS X 的开发环境，Cocoa Touch是 iPhone OS的开发环境。框架 &emsp;&emsp; Foundation框架实现了NSObjec类（即根类），这个类定义基本对象行为。此外，该框架还实现了用于表示基本类型（例如，字符串和数字）和群体类型（例如，数组和字典）的类，同时也提供一些基本工具，例如用于国际化、对象持久化、文件管理以及XML处理的工具。你还可以使用Foundation框架中的类访问底层系统的实体和服务，例如可以用它来访问端口、线程、锁和进程。Foundation框架以Core Foundation框架为基础，Core Foundation框架提供的是过程化（ANSI C）接口。 &emsp;&emsp;你可以使用 AppKit 和UIKit 框架开发应用程序的用户接口。二者用途相同，但是针对平台不同。框架中的类很多，各有不同用途：有的用于事件处理、有的用于画图、有的用于图像处理、有的用于文本处理、有的用于用户排版、还有用于应用程序间数据传输。框架中还包含表视图、滑动条、按键、文本字段以及警告对话框等用户接口元素。 iOS layer: 思维导图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Layers of iOS</tag>
        <tag>Cocoa Touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS - 沙盒路径结构]]></title>
    <url>%2F2016%2F10%2F25%2FiOS-sanbox%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; iOS系统的沙盒机制规定每个应用都只能访问当前沙盒目录下面的文件（也有例外，比如系统通讯录能在用户授权的情况下被第三方应用访问） 一 沙盒目录结构&emsp;&emsp;每个应用的沙盒目录都是相似的，主要包含图中所示的4个目录： 1. .app① 存放内容该目录包含了应用程序本身的数据，包括资源文件和可执行文件等。程序启动以后，会根据需要从该目录中动态加载代码或资源到内存，这里用到了lazy loading的思想。 ② 整个目录是只读的为了防止被篡改，应用在安装的时候会将该目录签名。非越狱情况下，该目录中内容是无法更改的；在越狱设备上如果更改了目录内容，对应的签名就会被改变，这种情况下苹果官网描述的后果是应用程序将无法启动，我没实践过。 ③是否会被iTunes同步否 2. Documents① 存放内容我们可以将应用程序的数据文件保存在该目录下。不过这些数据类型仅限于不可再生的数据，可再生的数据文件应该存放在Library/Cache目录下。 ② 是否会被iTunes同步是 2.1 Documents/Inbox① 存放内容该目录用来保存由外部应用请求当前应用程序打开的文件。比如我们的应用叫A，向系统注册了几种可打开的文件格式，B应用有一个A支持的格式的文件F，并且申请调用A打开F。由于F当前是在B应用的沙盒中，我们知道，沙盒机制是不允许A访问B沙盒中的文件，因此苹果的解决方案是讲F拷贝一份到A应用的Documents/Inbox目录下，再让A打开F。 ② 是否会被iTunes同步是 3. Library① 存放内容苹果建议用来存放默认设置或其它状态信息。 ② 是否会被iTunes同步是，但是要除了Caches子目录外 3.1 Library/Caches① 存放内容主要是缓存文件，用户使用过程中缓存都可以保存在这个目录中。前面说过，Documents目录用于保存不可再生的文件，那么这个目录就用于保存那些可再生的文件，比如网络请求的数据。鉴于此，应用程序通常还需要负责删除这些文件。 ② 是否会被iTunes同步否。 3.2 Library/Preferences① 存放内容应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，这就是所谓的写入plist中！ ② 是否会被iTunes同步是 4. tmp① 存放内容各种临时文件，保存应用再次启动时不需要的文件。而且，当应用不再需要这些文件时应该主动将其删除，因为该目录下的东西随时有可能被系统清理掉，目前已知的一种可能清理的原因是系统磁盘存储空间不足的时候。 ② 是否会被iTunes同步否 二、获取主要目录路径的方式1. 沙盒目录NSLog(@&quot;%@&quot;,NSHomeDirectory()); output: /var/mobile/Applications/332542A4-6f37-4C45-BA5E-7391F2034673 2. tmpNSLog(@&quot;%@&quot;,NSTemporaryDirectory()); output: /private/var/mobile/Applications/332542A4-6f37-4C45-BA5E-7391F2034673/tmp/ 3. .appNSLog(@&quot;%@&quot;,[[NSBundle mainBundle] bundlePath]); output: /var/mobile/Applications/332542A4-6f37-4C45-BA5E-7391F2034673/xx.app 4. DocumentsNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [paths objectAtIndex:0]; NSLog(@&quot;%@&quot;,path); output: /var/mobile/Applications/332542A4-6f37-4C45-BA5E-7391F2034673/Documents &emsp;&emsp;这里用到的NSSearchPathForDirectoriesInDomains方法需要解释下，其声明如下： FOUNDATION_EXPORT NSArray *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);&emsp;&emsp;该方法用于返回指定范围内的指定名称的目录的路径集合。有三个参数： directory &emsp;&emsp; NSSearchPathDirectory类型的enum值，表明我们要搜索的目录名称，比如这里用NSDocumentDirectory表明我们要搜索的是Documents目录。如果我们将其换成NSCachesDirectory就表示我们搜索的是Library/Caches目录。 domainMask &emsp;&emsp; NSSearchPathDomainMask类型的enum值，指定搜索范围，这里的NSUserDomainMask表示搜索的范围限制于当前应用的沙盒目录。还可以写成NSLocalDomainMask（表示/Library）、NSNetworkDomainMask（表示/Network）等。 expandTilde &emsp;&emsp; BOOL值，表示是否展开波浪线~. 我们知道在iOS中~的全写形式是/User/userName，该值为YES即表示写成全写形式，为NO就表示直接写成“~”。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>沙盒路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS - 应用崩溃日志分析]]></title>
    <url>%2F2016%2F10%2F25%2FiOS-APPcrash%2F</url>
    <content type="text"><![CDATA[学习iOS 应用崩溃日志分析 http://www.cocoachina.com/industry/20130725/6677.html 漫谈iOS APP crash 收集框架 https://nianxi.net/ios/ios-crash-reporter.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>崩溃日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 5.7 Mac EI 安装卸载]]></title>
    <url>%2F2016%2F10%2F24%2Fmysql-mac%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; MySQL 5.7+ 安装成功以后会弹出一个临时密码 后面需要通过临时密码设置新的密码 重置root密码安装成功后，使用临时密码登陆：敲入命令 mysqladmin -u root -p password 这时会提醒你输入密码，输入临时密码登陆成功后，会再提醒你修改密码，修改完成后你就可以正常登陆了. 如果没有保存密码有两个方式重置root密码: 1.卸载重新安装 下面有卸载方式 dmg文件里面没有uninstall 只能手动安装 卸载方式:(Mac) sudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* vim /etc/hostconfig (and removed the line MYSQLCOM=-YES-) rm -rf ~/Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.*&quot; 2.安全方式 更新root 密码 说实话 这种方式我的不好使(囧) MySQL修改密码关闭服务系统偏好设置->MySQL->Stop MySQL Server 安全模式进入MySQL jacob@JacobdeMacBook-Pro:~$ sudo mysqld_safe --skip-grant-tables 重新打开一个终端 进入MySQL控制台 jacob@JacobdeMacBook-Pro:~$ mysql -u root Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 3 Server version: 5.7.7-rc MySQL Community Server (GPL) Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement. 提示已经成功进入控制台 修改密码，sql语句 mysql&gt; update mysql.user set password=password(&apos;123456&apos;) where user=&apos;root&apos;; 坑爹的地方来了，输入后报如下错误 ERROR 1054 (42S22): Unknown column &apos;password&apos; in &apos;field list&apos; 神马情况，&apos;password&apos;列不存在，这个地方花了好多时间，原因其实很简单啊啊。 MySQL 5.7 版本中 user表中的密码字段列名称变了，从password变成了authentication_string可以直接看一下user表中的字段 mysql&gt; use mysql; mysql&gt; desc user; 部分字段如下 Field Type Null Key Default Extra Host char(60) NO PRI User char(16) NO PRI authentication_string text YES NULL password_expired enum(‘N’,’Y’) NO N password_last_changed timestamp YES NULL password_lifetime smallint(5) unsigned YES NULL 最后用如下如下语句修改 mysql&gt; update mysql.user set authentication_string=PASSWORD(&apos;123456&apos;) where user=&apos;root&apos;; Query OK, 1 row affected, 1 warning (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 1 mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec) 修改成功，再次进入控制台 mysql&gt; show databases; 这次可以进去了，但是随便执行一条语句依然报错啊 ERROR 1820 (HY000): You must SET PASSWORD before executing this statement 按照提示再次设置密码 mysql&gt; set password for root@localhost=password(&apos;12345&apos;); Query OK, 0 rows affected, 1 warning (0.00 sec) 便捷设置为方便使用 MySQL 方法1 cd /etc sudo chmod +w bashrc sudo vi bashrc 在bashrc最后添加下面两行 alias mysql=&apos;/usr/local/mysql/bin/mysql&apos; alias mysqladmin=&apos;/usr/local/mysql/bin/mysqladmin&apos; 方法2 打开终端,输入： cd ~ 会进入文件夹(表示用户根目录) 然后输入： touch .bash_profile; 回车执行 再输入： vim .bash_profile； 这时会在vim中打开这个文件（如果以前没有配置过环境变量，那么这应该是一个空白文档）。 如果有内容，即在结束符前输入，如果没有内容，直接输入如下语句： export PATH=${PATH}:/usr/local/mysql/bin 然后保存，退出vim，关闭终端并退出。 重启机器。 手动开启关闭MySQL sudo /usr/local/mysql/support-files/mysql.server start/stop]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS - 绘图(Core Graphics/QuartZ 2D)]]></title>
    <url>%2F2016%2F10%2F23%2FiOS-drawing%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; iOS支持两套图形API族：Core Graphics/QuartZ 2D 和OpenGL ES。OpenGL ES是跨平台的图形API，属于OpenGL的一个简化版本。QuartZ 2D是苹果公司开发的一套API，它是Core Graphics Framework的一部分。需要注意的是：OpenGL ES只定义了一套规范，具体的实现由设备制造商根据规范去, 而日常iOS 开发涉及不到OpenGL. &emsp;&emsp;Core Graphics Framework是一套基于C的API框架，使用了Quartz作为绘图引擎。它提供了低级别、轻量级、高保真度的2D渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩以及PDF文档的创建、显示和分析。&emsp;&emsp;开发中经常使用两种绘图方式: UIKit方式 &emsp;&emsp;其实所谓UIKit方式也是基于Core Graphics的, 它只是对Core Graphics, 使用UIBezierPath面向对象的封装.实现简单, 适用于需求简单的场景,__只能基于当前Context绘制__&emsp;&emsp;使用UIKit实现自定义绘图主要是通过UIBezierPath,创建基于矢量的路径,和sketch及ps中的路径是同一个概念. Core Graphics方式 &emsp;&emsp;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>绘图</tag>
        <tag>Core Graphics/QuartZ 2D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基本使用]]></title>
    <url>%2F2016%2F10%2F21%2Fzhengze%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;总结基本的正则表达式符号 及 简单用法, 以备忘, 长篇大论, 不喜勿喷…o.o\\\ 1.正则表达式基本符号两个特殊的符号 ‘^’ 和 ‘$’。他们的作用是分别指出一个字符串的开始和结束。例子如下：123"^The"：表示所有以 "The" 开始的字符串（"There"，"The cat"等）； "of despair$"：表示所以以 "of despair" 结尾的字符串； "notice"：表示任何包含 "notice" 的字符串。 最后那个例子，如果你不使用两个特殊字符，你就在表示要查找的串在被查找串的任意部分——你并不把它定位在某一个位置。 其它还有 ‘*‘，’+’ 和 ‘?’, 这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示 “没有或更多”，”一次或更多” 还有 “没有或一次”。下面是几个例子：1234"ab*"：表示一个字符串有一个a后面跟着零个或若干个b。（"a", "ab", "abbb",……）； "ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多； "ab?"：表示一个字符串有一个a后面跟着零个或者一个b； "a?b+$"：表示在字符串的末尾有零个或一个a跟着一个或几个b。 你也可以使用范围，用大括号括起，用以表示重复次数的范围。123"ab&#123;2&#125;"：表示一个字符串有一个a跟着2个b（"abb"）； "ab&#123;2,&#125;"：表示一个字符串有一个a跟着至少2个b ("abb…")； "ab&#123;3,5&#125;"：表示一个字符串有一个a跟着3到5个b。 注意 你必须指定范围的下限 (如：”{0,2}” 而不是 “{,2}” ).还有， 你可能注意到了，’*‘，’+’ 和 ‘?’ 相当于 “{0,}”，”{1,}” 和 “{0,1}”。 还有一个 ‘|’，表示 “或” 操作：123"hi|hello"：表示一个字符串里有 "hi" 或者 "hello"； "(b|cd)ef"：表示 "bef" 或 "cdef"； "(a|b)*c"：表示一串 "a" "b" 混合的字符串后面跟一个 "c"； ‘.’ 可以替代任何字符：12"a.[0-9]"：表示一个字符串有一个 "a" 后面跟着一个任意字符和一个数字； "^.&#123;3&#125;$"：表示有任意三个字符的字符串（长度为3个字符）； [] 方括号表示某些字符允许在一个字符串中的某一特定位置出现：123456"[ab]"：表示一个字符串有一个 "a" 或 "b"（相当于 "a|b"）； "[a-d]"：表示一个字符串包含小写的'a'到'd'中的一个（相当于"a|b|c|d"或者"[abcd]"）； "^[a-zA-Z]"：表示一个以字母开头的字符串； "[0-9]%"：表示一个百分号前有一位的数字； ",[a-zA-Z0-9]$"：表示一个字符串以一个逗号后面跟着一个字母或数字结束。你也可以在方括号里用'^'表示不希望出现的字符，'^' 应在方括号里的第一位。（如："%[^a-zA-Z]%"表示两个百分号中不应该出现字母）。 为了逐字表达，你必须在 “^.$()|*+?{“ 这些字符前加上转移字符 ‘\’。请注意在方括号中，不需要转义字符。 特殊字符作用123456789101112131415161718. 匹配任何字符、空格和Tab键 eg. 正则表达式：a.b 匹配：abb, acb, a@b等 \d 匹配数字 &lt;==&gt; [0-9] eg. 正则表达式: \dd 匹配：1d, 2d等 \D 匹配非数字 &lt;==&gt; [^0-9] eg. 正则表达式: \Dd 匹配：ad, bd等，不匹配1d,2d \s 匹配空白字符串 eg. 正则表达式：\sd 匹配：(空格)d \S 匹配非空白字符 eg. 正则表达式：\Sd 匹配: ad, bd等 \w 匹配单词字符 &lt;==&gt; [a-zA-Z0-9] eg. 正表表达式：\wd 匹配：ad, bd等，不匹配: _d , @d \W 匹配非单词字符 &lt;==&gt; [^\w] eg. 正则表达式：\Wd 匹配: !d, @d, 不匹配1d,ad [] 匹配包含其中的单个字符 eg. 正则表达式：a[bcd]m 匹配: abm, acm () 匹配一组表达式(可以由特殊字符组成) eg. 正则表达式：a([bcd]n)m 匹配：abnm, acnm，adnm 正则表达式中/i,/g,/ig,/gi,/m的区别和含义12345/i (忽略大小写 ignore ) /g (全文查找出现的所有匹配字符 global) /m (多行查找 multiple) /gi (全文查找、忽略大小写) /ig (全文查找、忽略大小写) 2. 零宽断言零宽断言分为4类• 正向零宽先行断言（?=exp）目标字符出现的位置的右边必须匹配到exp这个表达式 • 负向零宽先行断言（?!exp）目标字符出现的位置的右边不能匹配到exp这个表达式 • 正向零宽后发断言（?\&lt;=exp）javascript不支持后瞻目标字符出现的位置的左边必须匹配到exp这个表达式 • 负向零宽后发断言（?\&lt;!exp）但javascript不支持后瞻目标字符出现的位置的左边不能匹配到exp这个表达式 3. 贪婪模式和非贪婪模式 贪婪模式正则表达式去匹配时，会尽量多的匹配符合条件的内容标识符+，?，*，{n}，{n,}，{n,m}匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容 非贪婪模式正则表达式去匹配时，会尽量少的匹配符合条件的内容也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)标识符+?，??，*?，{n}?，{n,}?，{n,m}?可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个? 12345var str='aaabccbcxxxxabcxxxxbcmmm';var reg=/abc.*bc/g;var reg2 =/abc.*?bc/g;var res=str.match(reg); // abccbcxxxxabcxxxxbc var res2 = str.match(reg2); // [ 'abccbc', 'abcxxxxbc' ] 4.常用的正则表达式校验是否全由数字组成12345678^[0-9]&#123;1,20&#125;$ ^ 表示打头的字符要匹配紧跟^后面的规则 $ 表示打头的字符要匹配紧靠$前面的规则 [] 内部的内容是可选字符集 [0-9] 表示要求字符范围在0-9之间 [1,20] 表示数字字符串长度合法为1到20，即为[0-9]中的字符出现次数的范围是1到20次。 ^和$ 成对使用应该是表示要求整个字符串完全匹配定义的规则，而不是只匹配字符串中的一个子串。 校验登录名：只能输入5-20个以字母开头、可带数字、”_“、”.” 的字串123^[a-zA-Z]&#123;1&#125;([a-zA-Z0-9]|[._])&#123;4,19&#125;$ ^[a-zA-Z]&#123;1&#125; 表示第一个字符要求是字母。 ([a-zA-Z0-9]|[._])&#123;4,19&#125; 表示从第二位开始（因为它紧跟在上个表达式后面）的一个长度为4到9位的字符串，它要求是由大小写字母、数字或者特殊字符集[._]组成。 校验用户姓名：只能输入1-30个以字母开头的字串1^[a-zA-Z]&#123;1,30&#125;$ 校验密码：只能输入6-20个字母、数字、下划线123^(\w)&#123;6,20&#125;$ \w：用于匹配字母，数字或下划线字符 校验普通电话、传真号码：可以 “+” 或数字开头，可含有 “-“ 和 “ “12345^[+]&#123;0,1&#125;(\d)&#123;1,3&#125;[ ]?([-]?((\d)|[ ])&#123;1,12&#125;)+$ \d：用于匹配从0到9的数字； "?" 元字符规定其前导对象必须在目标对象中连续出现零次或一次 可以匹配的字符串如：+123 -999 999；+123-999 999；123 999 999；+123 999999等 校验URL12345^http[s]&#123;0,1&#125;:/.+$ 或 ^http[s]&#123;0,1&#125;:/.&#123;1,n&#125;$ (表示url串的长度为length("https://") + n ) / 表示字符 "/"。 . 表示所有字符的集 + 等同于&#123;1,&#125;，就是1到正无穷吧。 校验纯中文字符1^[\u4E00-\u9FA5]+$ 12345678910111213141516171819202122232425262728293031323334353637383940414243^\d+$ // 非负整数（正整数 + 0) ^[0-9]\*&#123;1-9&#125;[0-9]\*$ // 正整数 ^((-\d+)|(0+))$ // 非正整数（负整数 + 0） ^-[0-9]\*&#123;1-9&#125;[0-9]\*$ // 负整数 ^-?\d+$ // 整数 ^\d+(.\d+)?$ // 非负浮点数（正浮点数 + 0） ^(([0-9]+.[0-9]*&#123;1-9&#125;0-9*)|([0-9]*&#123;1-9&#125;[0-9]*.[0-9]+)|([0-9]*&#123;1-9&#125;[0-9]*))$ // 正浮点数 ^((-\d+(.\d+)?)|(0+(.0+)?))$ // 非正浮点数（负浮点数 + 0） ^(-(([0-9]+.[0-9]\*&#123;1-9&#125;[0-9]\*)|([0-9]\*&#123;1-9&#125;[0-9]\*.[0-9]+)|([0-9]\*&#123;1-9&#125;[0-9]\*)))$ // 负浮点数 ^(-?\d+)(.\d+)?$ // 浮点数 ^[A-Za-z]+$ // 由26个英文字母组成的字符串 ^[A-Z]+$ // 由26个英文字母的大写组成的字符串 ^[a-z]+$ // 由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ //由数字和26个英文字母组成的字符串 ^\w+$ // 由数字、26个英文字母或者下划线组成的字符串 ^[\w-]+(.[\w-]+)\*@[\w-]+(.[\w-]+)+$ // email地址 ^[a-zA-z]+://(\w+(-\w+)\*)(.(\w+(-\w+)\*))\*(?\S\*)?$ // url /^(\d&#123;2&#125;|\d&#123;4&#125;)-((0([1-9]&#123;1&#125;))|(11|2))-(([0-2][1])|(3[0|1]))$ // 年-月-日 /^((0([1-9]&#123;1&#125;))|(1[1|2]))/(([0-2][2])|(3[0|1]))/(\d&#123;2&#125;|\d&#123;4&#125;)$/ // 月/日/年 ^([w-.][3]+)@(([[0-9][4]1,3.[0-9][5]1,3.[0-9][6]1,3.)|(([w-][7]+.)+))([a-zA-Z][8]2,4|[0-9][9]1,3)(]?)$ // Email ^([0-9A-F][10]2)(-[0-9A-F][11]2)5$ // MAC地址的正则表达式 ^[-+][12]?d+(.d+)?$ // 值类型正则表达式]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
